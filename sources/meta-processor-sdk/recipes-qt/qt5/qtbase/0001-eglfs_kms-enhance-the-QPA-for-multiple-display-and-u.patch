From b13a98d7334ba57cbb584b7c88ba94e689a2596b Mon Sep 17 00:00:00 2001
From: Manisha Agrawal <manisha.agrawal@ti.com>
Date: Fri, 14 Jun 2019 13:43:23 -0400
Subject: [PATCH] eglfs_kms: enhance the QPA for multiple display and user
 buffer

Enhance the QPA to support multiple screens and to accept the buffers
from user application to overlay on QT drawn surface utilizing the
underneath display IP scaling, overlaying and alphablending feature.

rebase for QT5.11.3

This QPA has following limitations -
1. It only supports importing user overlay buffer. It doesn't
suport allocating the buffer for overlay plane inside QPA and exporting to user
application.
2. Dynamic creation and destruction of user plane (createPlane,
distroyPlane) is not supported. Meaning you can create the plane once
at the start of application and destroy it before exiting the
application.
3. There is an API called startDispPlane which will trigger displaying
of user/overlay plane. There is no corresponding API as stopDispPlane to
stop displaying of user/overlay plane.

Signed-off-by: Manisha Agrawal <manisha.agrawal@ti.com>
Signed-off-by: Eric Ruei <e-ruei1@ti.com>
---
 .../kmsconvenience/qkmsdevice.cpp             | 207 ++++++++++++-
 .../kmsconvenience/qkmsdevice_p.h             |  12 +-
 .../eglfs/api/qeglfsdeviceintegration.cpp     |  87 ++++++
 .../eglfs/api/qeglfsdeviceintegration_p.h     |  14 +
 .../platforms/eglfs/api/qeglfsintegration.cpp | 104 ++++++-
 .../eglfs_kms/qeglfskmsgbmdevice.cpp          |  89 ++++++
 .../eglfs_kms/qeglfskmsgbmdevice.h            |  10 +-
 .../eglfs_kms/qeglfskmsgbmintegration.cpp     | 102 ++++++
 .../eglfs_kms/qeglfskmsgbmintegration.h       |  13 +
 .../eglfs_kms/qeglfskmsgbmscreen.cpp          | 292 +++++++++++++++---
 .../eglfs_kms/qeglfskmsgbmscreen.h            |  47 ++-
 11 files changed, 922 insertions(+), 55 deletions(-)

diff --git a/src/platformsupport/kmsconvenience/qkmsdevice.cpp b/src/platformsupport/kmsconvenience/qkmsdevice.cpp
index a5895559e60..5b96375922a 100644
--- a/src/platformsupport/kmsconvenience/qkmsdevice.cpp
+++ b/src/platformsupport/kmsconvenience/qkmsdevice.cpp
@@ -63,6 +63,179 @@ enum OutputConfiguration {
     OutputConfigModeline
 };
 
+int QKmsDevice::getDrmPropId(drmModeObjectPropertiesPtr props,
+                                  const char *name, uint32_t *propId)
+{
+    drmModePropertyPtr p;
+    unsigned int i;
+    *propId = 0;/* Property ID should always be > 0 */
+
+    for (i = 0; i < props->count_props; i++) {
+        p = drmModeGetProperty(m_dri_fd, props->props[i]);
+        if (!strcmp(p->name, name)){
+            *propId = p->prop_id;
+            break;
+        }
+        drmModeFreeProperty(p);
+    }
+    if (!*propId) {
+        qWarning() << "getDrmPropId: Could not find" <<  name << "property";
+        return(-1);
+    }
+
+    return i;
+}
+
+int QKmsDevice::setPlaneProperties(uint32_t objectType, uint32_t crtcId,
+                                        uint32_t planeId, uint8_t num_prop, const char **propName,
+                                        uint32_t *propVal)
+{
+    int ret, i;
+    uint32_t objectId;
+    if(objectType == DRM_MODE_OBJECT_PLANE){
+        objectId = planeId;
+    }
+    else{
+        objectId = crtcId;
+    }
+    drmModeObjectProperties	*props = drmModeObjectGetProperties(m_dri_fd, objectId,
+        objectType);
+
+    if(props == NULL){
+        qWarning() << "setPlaneProperties: drm object properties for objectId" << objectId << "is NULL";
+        return (-1);
+    }
+
+    drmModeAtomicReqPtr req = drmModeAtomicAlloc();
+    uint32_t propId;
+
+    for(i = 0; i < num_prop; i++)
+    {
+        if (getDrmPropId(props, propName[i], &propId) < 0){
+            qWarning() << "setPlaneProperties: failed to get the DRM property id for " <<  propName[i];
+            goto error_exit;
+        }
+        if(drmModeAtomicAddProperty(req, objectId, propId, propVal[i]) < 0){
+            qWarning() << "setPlaneProperties: failed to add DRM property for" << propName[i];
+            goto error_exit;
+        }
+    }
+
+    if(objectType == DRM_MODE_OBJECT_PLANE){
+        if(getDrmPropId(props, "CRTC_ID", &propId) < 0){
+            qWarning() << "setPlaneProperties: failed to get the DRM property id for CRTC_ID";
+            goto error_exit;
+        }
+        if(drmModeAtomicAddProperty(req, planeId, propId, crtcId) < 0){
+            qWarning() << "setPlaneProperties: failed to add DRM property for CRTC_ID";
+            goto error_exit;
+        }
+    }
+
+    ret = drmModeAtomicCommit(m_dri_fd, req, DRM_MODE_ATOMIC_TEST_ONLY, 0);
+
+    if(!ret){
+        drmModeAtomicCommit(m_dri_fd, req, 0, 0);
+    }
+    else{
+        qWarning() << "setPlaneProperties: ret from drmModeAtomicCommit = " <<  ret;
+        goto error_exit;
+    }
+
+    drmModeAtomicFree(req);
+    drmModeFreeObjectProperties(props);
+    return 0;
+
+error_exit:
+    drmModeAtomicFree(req);
+    drmModeFreeObjectProperties(props);
+    return -1;
+}
+
+int QKmsDevice::getPlaneProperty(uint32_t objectType, uint32_t planeId,
+                                      const char *propName)
+{
+    uint32_t propId;
+    int propVal = -1, propIndx;
+
+    drmModeObjectProperties	*props = drmModeObjectGetProperties(m_dri_fd, planeId,
+        objectType);
+
+    if(props == NULL){
+        qWarning() << "getPlaneProperty: drm obeject properties for plane type is NULL\n";
+        return (-1);
+    }
+
+    propIndx = getDrmPropId(props, propName, &propId);
+
+    if(propIndx >= 0){
+        propVal = props->prop_values[propIndx];
+    }
+    else{
+        qWarning() << "getPlaneProperty: Couldn't get DRM plane property for" << *propName;
+        return -1;
+    }
+    drmModeFreeObjectProperties(props);
+
+    return propVal;
+}
+
+int QKmsDevice::getPlane(uint32_t crtc_id, uint8_t planeType)
+{
+    uint32_t i;
+    drmModeObjectProperties *props;
+    drmModePlaneRes *res = drmModeGetPlaneResources(m_dri_fd);
+
+    if(res == NULL){
+        qWarning() << "plane resources not found\n";
+        return -1;
+    }
+
+    for (i = 0; i < res->count_planes; i++) {
+        uint32_t planeId = res->planes[i];
+        unsigned int typeVal;
+
+        drmModePlane *plane = drmModeGetPlane(m_dri_fd, planeId);
+        if(plane == NULL){
+            qWarning() << "getPlane: Plane not found";
+            goto error_exit;
+        }
+
+        props = drmModeObjectGetProperties(m_dri_fd, plane->plane_id, DRM_MODE_OBJECT_PLANE);
+
+        if(props == NULL){
+            qWarning() << "getPlane: plane (%d) properties not found\n" << plane->plane_id;
+            drmModeFreePlane(plane);
+            goto error_exit;
+        }
+
+        typeVal = getPlaneProperty(DRM_MODE_OBJECT_PLANE, plane->plane_id, "type");
+
+        drmModeFreeObjectProperties(props);
+        drmModeFreePlane(plane);
+
+        if(typeVal == planeType){
+            if(planeType == DRM_PLANE_TYPE_PRIMARY){
+                if((plane->crtc_id == crtc_id) || (!plane->crtc_id)){
+                    plane->crtc_id = crtc_id;
+                    drmModeFreePlaneResources(res);
+                    return planeId;
+                }
+            }
+            else if (!(m_plane_allocator & ((quint64)1<<planeId))){
+                m_plane_allocator |= ((quint64)1 << planeId);
+                drmModeFreePlaneResources(res);
+                return planeId;
+            }
+        }
+    }
+
+    qWarning("getPlane: Plane for crtc %d not found", crtc_id);
+error_exit:
+    drmModeFreePlaneResources(res);
+    return -1;
+}
+
 int QKmsDevice::crtcForConnector(drmModeResPtr resources, drmModeConnectorPtr connector)
 {
     for (int i = 0; i < connector->count_encoders; i++) {
@@ -179,6 +352,7 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
     QSize configurationSize;
     int configurationRefresh = 0;
     drmModeModeInfo configurationModeline;
+    int primary_plane_id;
 
     auto userConfig = m_screenConfig->outputSettings();
     QVariantMap userConnectorConfig = userConfig.value(QString::fromUtf8(connectorName));
@@ -296,14 +470,14 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
 
     int selected_mode = -1;
 
-    if (configured >= 0)
-        selected_mode = configured;
+    if (current >= 0)
+        selected_mode = current;
     else if (preferred >= 0)
         selected_mode = preferred;
-    else if (current >= 0)
-        selected_mode = current;
     else if (best >= 0)
         selected_mode = best;
+    else if (configured >= 0)
+        selected_mode = configured;
 
     if (selected_mode < 0) {
         qWarning() << "No modes available for output" << connectorName;
@@ -316,6 +490,12 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
                                   << '@' << refresh << "hz for output" << connectorName;
     }
 
+    primary_plane_id = getPlane(crtc_id, DRM_PLANE_TYPE_PRIMARY);
+
+    if(primary_plane_id < 0){
+        return nullptr;
+    }
+
     // physical size from connector < config values < env vars
     int pwidth = qEnvironmentVariableIntValue("QT_QPA_EGLFS_PHYSICAL_WIDTH");
     if (!pwidth)
@@ -385,7 +565,7 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
     output.forced_plane_set = false;
     output.drm_format = drmFormat;
     output.clone_source = cloneSource;
-
+    output.primary_plane_id = primary_plane_id;
     QString planeListStr;
     for (const QKmsPlane &plane : qAsConst(m_planes)) {
         if (plane.possibleCrtcs & (1 << output.crtc_index)) {
@@ -424,6 +604,19 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
 
     vinfo->output = output;
 
+    drmModeObjectProperties	*props = drmModeObjectGetProperties(m_dri_fd, primary_plane_id,
+        DRM_MODE_OBJECT_PLANE);
+    if(props == NULL){
+		qWarning() << "drm object properties for planeId:" << primary_plane_id << "is NULL";
+        return nullptr;
+    }
+
+    if(getDrmPropId(props, "FB_ID", &m_prop_fbId) < 0){
+        drmModeFreeObjectProperties(props);
+        qWarning() << "Couldn't get DRM property id for FB_ID";
+        return nullptr;
+    }
+    drmModeFreeObjectProperties(props);
     return createScreen(output);
 }
 
@@ -461,10 +654,12 @@ drmModePropertyBlobPtr QKmsDevice::connectorPropertyBlob(drmModeConnectorPtr con
 }
 
 QKmsDevice::QKmsDevice(QKmsScreenConfig *screenConfig, const QString &path)
-    : m_screenConfig(screenConfig)
+    : m_prop_fbId(0)
+    , m_screenConfig(screenConfig)
     , m_path(path)
     , m_dri_fd(-1)
     , m_crtc_allocator(0)
+    , m_plane_allocator(0)
 {
     if (m_path.isEmpty()) {
         m_path = m_screenConfig->devicePath();
diff --git a/src/platformsupport/kmsconvenience/qkmsdevice_p.h b/src/platformsupport/kmsconvenience/qkmsdevice_p.h
index 5eecedec393..ae973dbe16a 100644
--- a/src/platformsupport/kmsconvenience/qkmsdevice_p.h
+++ b/src/platformsupport/kmsconvenience/qkmsdevice_p.h
@@ -191,7 +191,7 @@ struct QKmsOutput
     uint32_t drm_format = DRM_FORMAT_XRGB8888;
     QString clone_source;
     QVector<QKmsPlane> available_planes;
-
+    uint32_t primary_plane_id;
     void restoreMode(QKmsDevice *device);
     void cleanup(QKmsDevice *device);
     QPlatformScreen::SubpixelAntialiasingType subpixelAntialiasingTypeHint() const;
@@ -221,6 +221,12 @@ public:
     QString devicePath() const;
 
     QKmsScreenConfig *screenConfig() const;
+    int setPlaneProperties(uint32_t objectType, uint32_t crtcId, uint32_t planeId,
+        uint8_t numProp, const char **propName, uint32_t *propVal);
+    int getPlaneProperty(uint32_t objectType, uint32_t planeId,
+        const char *propName);
+    int getPlane(uint32_t crtcId, uint8_t planeType);
+    uint32_t m_prop_fbId;
 
 protected:
     virtual QPlatformScreen *createScreen(const QKmsOutput &output) = 0;
@@ -249,10 +255,12 @@ protected:
     int m_dri_fd;
 
     quint32 m_crtc_allocator;
-
+    quint64 m_plane_allocator; // TBD: m_planes are new
     QVector<QKmsPlane> m_planes;
 
 private:
+    int getDrmPropId(drmModeObjectPropertiesPtr props,
+        const char *name, unsigned int *propId);
     Q_DISABLE_COPY(QKmsDevice)
 };
 
diff --git a/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration.cpp b/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration.cpp
index f1517134008..ba948ccb902 100644
--- a/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration.cpp
+++ b/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration.cpp
@@ -393,4 +393,91 @@ EGLConfig QEglFSDeviceIntegration::chooseConfig(EGLDisplay display, const QSurfa
     return chooser.chooseConfig();
 }
 
+int QEglFSDeviceIntegration::exportBuffer(const QScreen *screen, uint32_t width, uint32_t height,
+                                        uint32_t pixel_format, uint32_t *strides, uint32_t *offsets,
+                                        uint32_t buf_fd, uint32_t *bufId)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(width);
+    Q_UNUSED(height);
+    Q_UNUSED(pixel_format);
+    Q_UNUSED(strides);
+    Q_UNUSED(offsets);
+    Q_UNUSED(buf_fd);
+    Q_UNUSED(bufId);
+
+    return -1;
+}
+
+int QEglFSDeviceIntegration::distroyBuffer(const QScreen *screen, uint32_t bufId)
+{
+    Q_UNUSED(screen)
+        Q_UNUSED(bufId);
+
+    return -1;
+}
+
+int QEglFSDeviceIntegration::setPlaneProperties(const QScreen *screen,
+                                              uint8_t planeType, uint8_t idx, uint8_t numProp,
+                                              const char **propName, uint32_t *propVal)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(planeType);
+    Q_UNUSED(idx);
+    Q_UNUSED(numProp);
+    Q_UNUSED(propName);
+    Q_UNUSED(propVal);
+
+    return -1;
+}
+
+int QEglFSDeviceIntegration::getPlaneProperty(const QScreen *screen,
+                                            uint8_t planeType, uint8_t idx,
+                                            const char *propName)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(planeType);
+    Q_UNUSED(idx);
+    Q_UNUSED(propName);
+
+    return -1;
+}
+
+int QEglFSDeviceIntegration::createPlane(const QScreen *screen)
+{
+    Q_UNUSED(screen);
+    return -1;
+}
+
+int QEglFSDeviceIntegration::distroyPlane(const QScreen *screen, int planeId)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(planeId);
+    return -1;
+}
+
+int QEglFSDeviceIntegration::queuePlane(QScreen *screen,
+                                      uint32_t idx, uint32_t fbId)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(idx);
+    Q_UNUSED(fbId);
+
+    return -1;
+}
+
+int QEglFSDeviceIntegration::startDispPlane(QScreen *screen)
+{
+    Q_UNUSED(screen);
+	return -1;
+}
+
+int QEglFSDeviceIntegration::userCallBackHandle(QScreen *screen, void (*fnPtr)(void *), void *data)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(fnPtr);
+    Q_UNUSED(data);
+    return -1;
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration_p.h b/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration_p.h
index 71ffb4c69a4..5d3b065085b 100644
--- a/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration_p.h
+++ b/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration_p.h
@@ -109,6 +109,20 @@ public:
     virtual void *wlDisplay() const;
 
     static EGLConfig chooseConfig(EGLDisplay display, const QSurfaceFormat &format);
+    virtual int exportBuffer(const QScreen *screen, uint32_t width,
+        uint32_t height, uint32_t pixel_format, uint32_t *strides,
+        uint32_t *offsets, uint32_t buf_fd, uint32_t *buf_id);
+    virtual int distroyBuffer(const QScreen *screen, uint32_t buf_id);
+    virtual int setPlaneProperties(const QScreen *screen, uint8_t planeType,
+        uint8_t idx, uint8_t numProp, const char **propName,
+        uint32_t *propVal);
+    virtual int getPlaneProperty(const QScreen *screen, uint8_t planeType,
+        uint8_t idx, const char *propName);
+    virtual int createPlane(const QScreen *screen);
+    virtual int distroyPlane(const QScreen *screen, int plane_id);
+    virtual int queuePlane(QScreen *screen, uint32_t idx, uint32_t fb_id);
+    virtual int startDispPlane(QScreen *screen);
+    virtual int userCallBackHandle(QScreen *screen, void (*fnPtr)(void *), void *data);
 };
 
 class Q_EGLFS_EXPORT QEglFSDeviceIntegrationPlugin : public QObject
diff --git a/src/plugins/platforms/eglfs/api/qeglfsintegration.cpp b/src/plugins/platforms/eglfs/api/qeglfsintegration.cpp
index 33878a5f50f..419df30e319 100644
--- a/src/plugins/platforms/eglfs/api/qeglfsintegration.cpp
+++ b/src/plugins/platforms/eglfs/api/qeglfsintegration.cpp
@@ -287,7 +287,16 @@ enum ResourceType {
     NativeDisplay,
     XlibDisplay,
     WaylandDisplay,
-    EglSurface
+    EglSurface,
+    ExportBuffer,
+    DistroyBuffer,
+    SetPlaneProperties,
+    GetPlaneProperty,
+    CreatePlane,
+    DistroyPlane,
+    QueuePlane,
+    StartDispPlane,
+    UserCallBackHandl,
 };
 
 static int resourceType(const QByteArray &key)
@@ -300,7 +309,16 @@ static int resourceType(const QByteArray &key)
         QByteArrayLiteral("nativedisplay"),
         QByteArrayLiteral("display"),
         QByteArrayLiteral("server_wl_display"),
-        QByteArrayLiteral("eglsurface")
+        QByteArrayLiteral("eglsurface"),
+        QByteArrayLiteral("export_buffer"),
+        QByteArrayLiteral("distroy_buffer"),
+        QByteArrayLiteral("set_plane_properties"),
+        QByteArrayLiteral("get_plane_property"),
+        QByteArrayLiteral("create_plane"),
+        QByteArrayLiteral("distroy_plane"),
+        QByteArrayLiteral("queue_plane"),
+        QByteArrayLiteral("start_disp_plane"),
+        QByteArrayLiteral("user_call_back_handle"),
     };
     const QByteArray *end = names + sizeof(names) / sizeof(names[0]);
     const QByteArray *result = std::find(names, end, key);
@@ -309,6 +327,61 @@ static int resourceType(const QByteArray &key)
     return int(result - names);
 }
 
+static int exportBuffer(const QScreen *screen, uint32_t width, uint32_t height,
+                        uint32_t pixel_format, uint32_t *strides, uint32_t *offsets,
+                        uint32_t buf_fd, uint32_t *buf_id)
+{
+    return(qt_egl_device_integration()->exportBuffer(screen, width,
+        height, pixel_format, strides, offsets, buf_fd, buf_id));
+}
+
+static int distroyBuffer(const QScreen *screen, uint32_t buf_id)
+{
+    return(qt_egl_device_integration()->distroyBuffer(screen, buf_id));
+}
+
+static int setPlaneProperties(const QScreen *screen, uint8_t planeType,
+                              uint32_t idx, uint8_t num_prop, const char **prop_name, uint32_t *prop_val)
+{
+    return (qt_egl_device_integration()->setPlaneProperties(
+        screen, planeType, idx, num_prop, prop_name, prop_val));
+}
+
+static int getPlaneProperty(const QScreen *screen, uint8_t planeType, uint32_t idx,
+                            const char *propName)
+{
+    return (qt_egl_device_integration()->getPlaneProperty(
+        screen, planeType, idx, propName));
+}
+
+static int createPlane(QScreen *screen)
+{
+    return(qt_egl_device_integration()->createPlane(screen));
+}
+
+static int distroyPlane(QScreen *screen, int plane_id)
+{
+    return (qt_egl_device_integration()->distroyPlane(screen, plane_id));
+}
+
+static int queuePlane(QScreen *screen,
+                      uint32_t idx, uint32_t fb_id)
+{
+    return (qt_egl_device_integration()->queuePlane(screen,
+        idx, fb_id));
+}
+
+static int startDispPlane(QScreen *screen)
+{
+    return (qt_egl_device_integration()->startDispPlane(screen));
+}
+
+static int userCallBackHandle(QScreen *screen,  void (*funPtr)(void *), void *data)
+{
+    return (qt_egl_device_integration()->userCallBackHandle(screen,
+        funPtr, data));
+}
+
 void *QEglFSIntegration::nativeResourceForIntegration(const QByteArray &resource)
 {
     void *result = 0;
@@ -323,6 +396,33 @@ void *QEglFSIntegration::nativeResourceForIntegration(const QByteArray &resource
     case WaylandDisplay:
         result = qt_egl_device_integration()->wlDisplay();
         break;
+    case ExportBuffer:
+        result = reinterpret_cast<void *>(exportBuffer);
+        break;
+    case DistroyBuffer:
+        result = reinterpret_cast<void *>(distroyBuffer);
+        break;
+    case CreatePlane:
+        result = reinterpret_cast<void *>(createPlane);
+        break;
+    case DistroyPlane:
+        result = reinterpret_cast<void *>(distroyPlane);
+        break;
+    case SetPlaneProperties:
+        result = reinterpret_cast<void *>(setPlaneProperties);
+        break;
+    case GetPlaneProperty:
+        result = reinterpret_cast<void *>(getPlaneProperty);
+        break;
+    case QueuePlane:
+        result = reinterpret_cast<void *>(queuePlane);
+        break;
+    case StartDispPlane:
+        result = reinterpret_cast<void *>(startDispPlane);
+        break;
+    case UserCallBackHandl:
+        result = reinterpret_cast<void *>(userCallBackHandle);
+        break;
     default:
         result = qt_egl_device_integration()->nativeResourceForIntegration(resource);
         break;
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.cpp b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.cpp
index 20127ae7f78..bf1fc4c5b4d 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.cpp
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.cpp
@@ -46,13 +46,91 @@
 
 #include <QtCore/QLoggingCategory>
 #include <QtCore/private/qcore_unix_p.h>
+#include <QThread>
 
+#include <sys/select.h>
 #define ARRAY_LENGTH(a) (sizeof (a) / sizeof (a)[0])
 
 QT_BEGIN_NAMESPACE
 
 Q_DECLARE_LOGGING_CATEGORY(qLcEglfsKmsDebug)
 
+class DrmPageFlipHandler : public QThread
+{
+public:
+    DrmPageFlipHandler(QEglFSKmsGbmDevice *gbm_device)
+        : m_abort(false), m_gbm_device(gbm_device)  {}
+    bool m_abort;
+    void run();
+
+private:
+    QEglFSKmsGbmDevice *m_gbm_device;
+};
+
+void DrmPageFlipHandler::run()
+{
+    drmEventContext drmEvent = {
+        DRM_EVENT_CONTEXT_VERSION,
+        Q_NULLPTR,      // vblank handler
+        QEglFSKmsGbmDevice::pageFlipHandler // page flip handler
+    };
+
+	struct timeval timeout = {
+		.tv_sec = 0,
+		.tv_usec = 5 * 1000  /* 5ms polling for dRM events */
+	};
+
+	fd_set fds;
+	int res;
+
+	while(m_abort == false){
+
+		FD_ZERO(&fds);
+		FD_SET(m_gbm_device->fd(), &fds);
+
+		res = select(m_gbm_device->fd() + 1, &fds, NULL, NULL, &timeout);
+
+		switch (res)
+		{
+			case 0:
+				/* timeout occurs */
+				break;
+
+			case -1:
+				if (errno != EINTR)
+				{
+					qErrnoWarning("%s: Select failed waiting for flip event: %d",
+								__func__, errno);
+				}
+				break;
+
+			default:
+				drmHandleEvent(m_gbm_device->fd(), &drmEvent);
+				break;
+		}
+	}
+}
+
+void QEglFSKmsGbmDevice::pageFlipHandler(int fd, unsigned int sequence, unsigned int tv_sec, unsigned int tv_usec, void *user_data)
+{
+    Q_UNUSED(fd);
+    Q_UNUSED(sequence);
+    Q_UNUSED(tv_sec);
+    Q_UNUSED(tv_usec);
+
+    QEglFSKmsGbmScreen *screen = static_cast<QEglFSKmsGbmScreen *>(user_data);
+
+    if(screen->m_qpa_flip_call == true){
+        screen->flipFinished();
+    }
+
+    if(screen->m_user_flip_call == true){
+        screen->m_hndl_user_callback(screen->m_user_data);
+    }
+
+    screen->m_flip_event.release(1);
+}
+
 QEglFSKmsGbmDevice::QEglFSKmsGbmDevice(QKmsScreenConfig *screenConfig, const QString &path)
     : QEglFSKmsDevice(screenConfig, path)
     , m_gbm_device(nullptr)
@@ -81,8 +159,12 @@ bool QEglFSKmsGbmDevice::open()
         return false;
     }
 
+    drmSetClientCap(fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+    drmSetClientCap(fd, DRM_CLIENT_CAP_ATOMIC, 1);
     setFd(fd);
 
+    m_drm_page_flip_handler = new DrmPageFlipHandler(this);
+    m_drm_page_flip_handler->start();
     return true;
 }
 
@@ -95,7 +177,14 @@ void QEglFSKmsGbmDevice::close()
         m_gbm_device = nullptr;
     }
 
+    m_drm_page_flip_handler->m_abort = true;
+    m_drm_page_flip_handler->wait();
+    delete m_drm_page_flip_handler;
+    m_drm_page_flip_handler = 0;
+
     if (fd() != -1) {
+        drmSetClientCap(fd(), DRM_CLIENT_CAP_UNIVERSAL_PLANES, 0);
+        drmSetClientCap(fd(), DRM_CLIENT_CAP_ATOMIC, 0);
         qt_safe_close(fd());
         setFd(-1);
     }
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.h b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.h
index 518e2ce58b1..98a06024f0b 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.h
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.h
@@ -50,7 +50,7 @@
 QT_BEGIN_NAMESPACE
 
 class QEglFSKmsScreen;
-
+class DrmPageFlipHandler;
 class QEglFSKmsGbmDevice: public QEglFSKmsDevice
 {
 public:
@@ -71,12 +71,20 @@ public:
                                QPlatformScreen *screenThisScreenClones,
                                const QVector<QPlatformScreen *> &screensCloningThisScreen) override;
 
+    static void pageFlipHandler(int fd,
+                                unsigned int sequence,
+                                unsigned int tv_sec,
+                                unsigned int tv_usec,
+                                void *user_data);
+
 private:
     Q_DISABLE_COPY(QEglFSKmsGbmDevice)
 
     gbm_device *m_gbm_device;
 
     QEglFSKmsGbmCursor *m_globalCursor;
+
+    DrmPageFlipHandler *m_drm_page_flip_handler;
 };
 
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp
index eb241756eff..a08c682697f 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp
@@ -150,4 +150,106 @@ QEglFSWindow *QEglFSKmsGbmIntegration::createWindow(QWindow *window) const
     return new QEglFSKmsGbmWindow(window, this);
 }
 
+int QEglFSKmsGbmIntegration::exportBuffer(const QScreen *screen, uint32_t width, uint32_t height,
+                                          uint32_t pixel_format, uint32_t *strides, uint32_t *offsets,
+                                          uint32_t buf_fd, uint32_t *buf_id)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return (gbmScreen->addOverlayBuffer(width,
+            height, pixel_format, strides, offsets, buf_fd, buf_id));
+    }
+
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::distroyBuffer(const QScreen *screen, uint32_t buf_id)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return (gbmScreen->removeOverlayBuffer(buf_id));
+    }
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::setPlaneProperties(const QScreen *screen,
+                                                uint8_t planeType, uint8_t idx, uint8_t num_prop,
+                                                const char **propName, uint32_t *propVal)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return(gbmScreen->setPlaneProperties(planeType, idx, num_prop, propName, propVal));
+    }
+
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::getPlaneProperty(const QScreen *screen,
+                                              uint8_t planeType, uint8_t idx, const char *propName)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return(gbmScreen->getPlaneProperty(planeType, idx, propName));
+    }
+
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::createPlane(const QScreen *screen)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return(gbmScreen->createOverlayPlane());
+    }
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::distroyPlane(const QScreen *screen, int planeId)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return(gbmScreen->distroyOverlayPlane(planeId));
+    }
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::queuePlane(QScreen *screen,
+                                        uint32_t idx, uint32_t fbId)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return(gbmScreen->queueOverlayPlane(idx, fbId));
+    }
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::startDispPlane(QScreen *screen)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+        return(gbmScreen->startDispOverlayPlane());
+    }
+    return -1;
+}
+
+int QEglFSKmsGbmIntegration::userCallBackHandle(QScreen *screen,  void (*hndlUserCallBack)(void *), void *userData)
+{
+    if(device())
+    {
+        QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen->handle());
+		gbmScreen->m_hndl_user_callback = hndlUserCallBack;
+		gbmScreen->m_user_data = userData;
+        return 0;
+    }
+    return -1;
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.h b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.h
index 6467a21d93f..a842d5d0585 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.h
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.h
@@ -67,6 +67,19 @@ public:
     QPlatformCursor *createCursor(QPlatformScreen *screen) const override;
     void presentBuffer(QPlatformSurface *surface) override;
     QEglFSWindow *createWindow(QWindow *window) const override;
+    int exportBuffer(const QScreen *screen, uint32_t width,
+        uint32_t height, uint32_t pixel_format, uint32_t *strides,
+        uint32_t *offsets, uint32_t buf_fd, uint32_t *buf_id) override;
+    int distroyBuffer(const QScreen *screen,uint32_t buf_id) override;
+    int setPlaneProperties(const QScreen *screen, uint8_t planeType,
+        uint8_t idx, uint8_t numProp, const char **propName, uint32_t *propVal) override;
+    int getPlaneProperty(const QScreen *screen, uint8_t planeType,
+        uint8_t idx, const char *propName) override;
+    int createPlane(const QScreen *screen) override;
+    int distroyPlane(const QScreen *screen, int planeId) override;
+    int queuePlane(QScreen *screen, uint32_t idx, uint32_t fbId) override;
+    int startDispPlane(QScreen *screen) override;
+    int userCallBackHandle(QScreen *screen, void (*fnPtr)(void *), void *data) override;
 
 protected:
     QKmsDevice *createDevice() override;
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp
index 1b52bdf3ec9..16be46973d0 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp
@@ -50,10 +50,25 @@
 #include <QtFbSupport/private/qfbvthandler_p.h>
 
 #include <errno.h>
+#include <QThread>
+#include <QMutex>
+#include <string.h>
 
 QT_BEGIN_NAMESPACE
 
 Q_DECLARE_LOGGING_CATEGORY(qLcEglfsKmsDebug)
+class DrmPageFlip : public QThread
+{
+
+public:
+    DrmPageFlip(QEglFSKmsGbmScreen *screen)
+        : m_abort(false), m_gbm_screen(screen) {}
+    bool m_abort;
+    void run();
+
+private:
+    QEglFSKmsGbmScreen *m_gbm_screen;
+};
 
 static inline uint32_t drmFormatToGbmFormat(uint32_t drmFormat)
 {
@@ -111,13 +126,22 @@ QEglFSKmsGbmScreen::FrameBuffer *QEglFSKmsGbmScreen::framebufferForBufferObject(
 
 QEglFSKmsGbmScreen::QEglFSKmsGbmScreen(QKmsDevice *device, const QKmsOutput &output, bool headless)
     : QEglFSKmsScreen(device, output, headless)
+    , m_qpa_flip_call(false)
+    , m_user_flip_call(false)
+    , m_start_flip_overlay_plane(false)
     , m_gbm_surface(nullptr)
     , m_gbm_bo_current(nullptr)
     , m_gbm_bo_next(nullptr)
     , m_flipPending(false)
     , m_cursor(nullptr)
     , m_cloneSource(nullptr)
+    , m_flip_primary_plane(false)
+    , m_plane_id{0}
+    , m_plane_idx(0)
+    , m_primary_plane_fb(0)
 {
+    m_drm_page_flip = new DrmPageFlip(this);
+    m_drm_page_flip->start();
 }
 
 QEglFSKmsGbmScreen::~QEglFSKmsGbmScreen()
@@ -126,6 +150,100 @@ QEglFSKmsGbmScreen::~QEglFSKmsGbmScreen()
     qCDebug(qLcEglfsKmsDebug, "Screen dtor. Remaining screens: %d", remainingScreenCount);
     if (!remainingScreenCount && !device()->screenConfig()->separateScreens())
         static_cast<QEglFSKmsGbmDevice *>(device())->destroyGlobalCursor();
+    m_drm_page_flip->m_abort = true;
+    m_drm_page_flip->wait();
+    delete m_drm_page_flip;
+    m_drm_page_flip = 0;
+}
+
+/* This thread periodically cheks if there is any user submitted buffer for
+overlay with primary plane or if QT has drawn new surface (primary plane)
+to be displayed. In any or both of the case, this thread will do atomic
+submission of the new framebuffer id to the DRM device for display.
+Access to overlay plane queue and primary plane resources are Mutex protected
+with respective threads.
+*/
+void DrmPageFlip::run(){
+    while(m_abort == false){
+        drmModeAtomicReqPtr req = drmModeAtomicAlloc();
+        bool commit_overlay_plane = false;
+        bool commit_primary_plane = false;
+        uint32_t primary_plane_fb_id;
+        int ret = -1;
+
+        m_gbm_screen->m_primary_mutex.lock();
+        commit_primary_plane = m_gbm_screen->m_flip_primary_plane;
+        primary_plane_fb_id = m_gbm_screen->m_primary_plane_fb;
+        m_gbm_screen->m_flip_primary_plane = false;
+        m_gbm_screen->m_primary_mutex.unlock();
+
+        if(commit_primary_plane == true){
+            if((ret = drmModeAtomicAddProperty(req, m_gbm_screen->m_output.primary_plane_id,
+                m_gbm_screen->device()->m_prop_fbId, primary_plane_fb_id)) < 0){
+                    qWarning("failed to add property with error code = %d\n", ret);
+            }
+        }
+
+        //Check for any new buffer queued by user application
+        if (m_gbm_screen->m_start_flip_overlay_plane == true) {
+            m_gbm_screen->m_overlay_mutex.lock();
+            for(uint32_t i = 0 ; i < m_gbm_screen->m_plane_idx; i++) {
+                if (!m_gbm_screen->overlayPlaneFbIdQueue[i].isEmpty()) {
+                    uint32_t planeId = m_gbm_screen->m_plane_id[i];
+                    uint32_t fbId = m_gbm_screen->overlayPlaneFbIdQueue[i].dequeue();
+                    if((ret = drmModeAtomicAddProperty(req, planeId, m_gbm_screen->device()->m_prop_fbId, fbId)) < 0){
+                        qWarning("failed to add property with error code = %d\n", ret);
+                    }
+                    commit_overlay_plane = true;
+                }
+            }
+            m_gbm_screen->m_overlay_mutex.unlock();
+        }
+
+        if ((commit_primary_plane == true) || (commit_overlay_plane == true)) {
+            ret = drmModeAtomicCommit(m_gbm_screen->device()->fd(), req,
+                DRM_MODE_ATOMIC_TEST_ONLY, 0);
+
+            if (!ret) {
+                if(commit_overlay_plane == true) {
+                    m_gbm_screen->m_user_flip_call = true;
+                }
+
+                if(commit_primary_plane == true) {
+                    m_gbm_screen->m_qpa_flip_call = true;
+                }
+
+                drmModeAtomicCommit(m_gbm_screen->device()->fd(), req,
+                    DRM_MODE_PAGE_FLIP_EVENT | DRM_MODE_ATOMIC_NONBLOCK, m_gbm_screen);
+
+                //sleeping for 5 msec, assuming that display is not running at more than 120 fps
+                msleep(5);
+                while(m_gbm_screen->m_flip_event.tryAcquire(1) == false) {
+                    usleep(500);
+                }
+                m_gbm_screen->m_qpa_flip_call = false;
+                m_gbm_screen->m_user_flip_call = false;
+
+                msleep(1);
+            }
+            else {
+                if (m_gbm_screen->m_qpa_flip_call == true) {
+                    qErrnoWarning("Could not queue DRM page flip!");
+                    gbm_surface_release_buffer(m_gbm_screen->m_gbm_surface, m_gbm_screen->m_gbm_bo_next);
+                    m_gbm_screen->m_gbm_bo_next = Q_NULLPTR;
+                }
+
+                if (commit_overlay_plane == true) {
+                    qErrnoWarning("Could not page flip user overlay plane!");
+                    m_gbm_screen->m_hndl_user_callback(m_gbm_screen->m_user_data);
+                }
+            }
+        }
+        else{
+            msleep(1);
+        }
+        drmModeAtomicFree(req);
+    }
 }
 
 QPlatformCursor *QEglFSKmsGbmScreen::cursor() const
@@ -251,14 +369,10 @@ void QEglFSKmsGbmScreen::waitForFlip()
         return;
 
     QMutexLocker lock(&m_waitForFlipMutex);
-    while (m_gbm_bo_next) {
-        drmEventContext drmEvent;
-        memset(&drmEvent, 0, sizeof(drmEvent));
-        drmEvent.version = 2;
-        drmEvent.vblank_handler = nullptr;
-        drmEvent.page_flip_handler = pageFlipHandler;
-        drmHandleEvent(device()->fd(), &drmEvent);
+    while (m_gbm_bo_next){
+        usleep(200);
     }
+
 }
 
 void QEglFSKmsGbmScreen::flip()
@@ -287,22 +401,12 @@ void QEglFSKmsGbmScreen::flip()
     FrameBuffer *fb = framebufferForBufferObject(m_gbm_bo_next);
     ensureModeSet(fb->fb);
 
-    QKmsOutput &op(output());
-    const int fd = device()->fd();
-    m_flipPending = true;
-    int ret = drmModePageFlip(fd,
-                              op.crtc_id,
-                              fb->fb,
-                              DRM_MODE_PAGE_FLIP_EVENT,
-                              this);
-    if (ret) {
-        qErrnoWarning("Could not queue DRM page flip on screen %s", qPrintable(name()));
-        m_flipPending = false;
-        gbm_surface_release_buffer(m_gbm_surface, m_gbm_bo_next);
-        m_gbm_bo_next = nullptr;
-        return;
-    }
+    m_primary_mutex.lock();
+    m_primary_plane_fb = fb->fb;
+    m_flip_primary_plane = true;
+    m_primary_mutex.unlock();
 
+#if 0 // new code: handle this case later
     for (CloneDestination &d : m_cloneDests) {
         if (d.screen != this) {
             d.screen->ensureModeSet(fb->fb);
@@ -318,17 +422,7 @@ void QEglFSKmsGbmScreen::flip()
             }
         }
     }
-}
-
-void QEglFSKmsGbmScreen::pageFlipHandler(int fd, unsigned int sequence, unsigned int tv_sec, unsigned int tv_usec, void *user_data)
-{
-    Q_UNUSED(fd);
-    Q_UNUSED(sequence);
-    Q_UNUSED(tv_sec);
-    Q_UNUSED(tv_usec);
-
-    QEglFSKmsGbmScreen *screen = static_cast<QEglFSKmsGbmScreen *>(user_data);
-    screen->flipFinished();
+#endif
 }
 
 void QEglFSKmsGbmScreen::flipFinished()
@@ -338,7 +432,6 @@ void QEglFSKmsGbmScreen::flipFinished()
         return;
     }
 
-    m_flipPending = false;
     updateFlipStatus();
 }
 
@@ -357,9 +450,6 @@ void QEglFSKmsGbmScreen::updateFlipStatus()
 {
     Q_ASSERT(!m_cloneSource);
 
-    if (m_flipPending)
-        return;
-
     for (const CloneDestination &d : m_cloneDests) {
         if (d.cloneFlipPending)
             return;
@@ -373,4 +463,132 @@ void QEglFSKmsGbmScreen::updateFlipStatus()
     m_gbm_bo_next = nullptr;
 }
 
+int QEglFSKmsGbmScreen::addOverlayBuffer(uint32_t width,
+                                         uint32_t height,
+                                         uint32_t pixel_format,
+                                         uint32_t *strides,
+                                         uint32_t *offsets,
+                                         uint32_t buf_fd,
+                                         uint32_t *buf_id)
+{
+    /* Get the buffer handle from the exported buffer fd */
+    uint32_t bo_handle;
+    drmPrimeFDToHandle(m_device->fd(), buf_fd, &bo_handle);
+    int ret = drmModeAddFB2(m_device->fd(), width, height, pixel_format, &bo_handle,\
+        strides, offsets, buf_id, 0);
+
+    if (ret) {
+		qWarning() << "addOverlayBuffer: drmModeAddFB2 failed:" << strerror(errno) << ret;
+        return -1;
+    }
+    return ret;
+}
+
+int QEglFSKmsGbmScreen::removeOverlayBuffer(uint32_t buf_id)
+{
+    int ret = drmModeRmFB(m_device->fd(), buf_id);
+
+    if (ret) {
+		qWarning() << "removeOverlayBuffer: drmModeRmFB failed:" << strerror(errno) << ret;
+        return -1;
+    }
+    return ret;
+}
+
+int QEglFSKmsGbmScreen::setPlaneProperties(uint8_t planeType, uint8_t idx,
+                                           uint8_t numProp, const char **propName, uint32_t *propVal)
+{
+    uint32_t planeId, crtcId;
+    uint32_t objectType;
+    crtcId = m_output.crtc_id;
+
+	if (idx > MAX_NUM_PLANES){
+		qWarning("queueOverlayPlane: invalid plane index\n");
+		return -1;
+    }
+
+    if(planeType == DRM_PLANE_TYPE_OVERLAY){
+        planeId = m_plane_id[idx];
+        objectType = DRM_MODE_OBJECT_PLANE;
+    }
+    else if(planeType == DRM_PLANE_TYPE_PRIMARY){
+        objectType = DRM_MODE_OBJECT_CRTC;
+        planeId = crtcId;
+    }
+    else{
+		qWarning() << "setPlaneProperties: invalid plane type";
+        return -1;
+    }
+    return m_device->setPlaneProperties(objectType, crtcId, planeId, numProp, propName, propVal);
+}
+
+int QEglFSKmsGbmScreen::getPlaneProperty(uint8_t planeType, uint8_t idx, const char *propName)
+{
+    uint32_t planeId, crtcId;
+    uint32_t objectType;
+    crtcId = m_output.crtc_id;
+
+	if (idx > MAX_NUM_PLANES){
+		qWarning("queueOverlayPlane: invalid plane index\n");
+		return -1;
+    }
+
+    if(planeType == DRM_PLANE_TYPE_OVERLAY){
+        planeId = m_plane_id[idx];
+        objectType = DRM_MODE_OBJECT_PLANE;
+    }
+    else if(planeType == DRM_PLANE_TYPE_PRIMARY){
+        objectType = DRM_MODE_OBJECT_CRTC;
+        planeId = crtcId;
+    }
+    else{
+		qWarning() << "getPlaneProperty: invalid plane type";
+        return -1;
+    }
+    return m_device->getPlaneProperty(objectType, planeId, propName);
+}
+
+int QEglFSKmsGbmScreen::createOverlayPlane()
+{
+    int planeId = m_device->getPlane(0, DRM_PLANE_TYPE_OVERLAY);
+    if (planeId > 0){
+        uint8_t pcnt = m_plane_idx++;
+        if(pcnt > MAX_NUM_PLANES){
+			qWarning() << "createOverlayPlane: Don't support number of planes greater then" <<  MAX_NUM_PLANES;
+        }
+        m_plane_id[pcnt] = planeId;
+        return pcnt;
+    }
+    else {
+        qWarning() << "createOverlayPlane: cannot find free plane";
+        return -1;
+    }
+}
+
+int QEglFSKmsGbmScreen::distroyOverlayPlane(int pcnt)
+{
+    int planeId = m_plane_id[pcnt];
+    Q_UNUSED(planeId);
+    //nothing to be done to distroy the plane
+    return 0;
+}
+
+int QEglFSKmsGbmScreen::queueOverlayPlane(uint32_t idx, uint32_t fbId)
+{
+    if (idx > MAX_NUM_PLANES){
+        qWarning("queueOverlayPlane: invalid plane index\n");
+        return -1;
+    }
+    m_overlay_mutex.lock();
+    overlayPlaneFbIdQueue[idx].enqueue(fbId);
+    m_overlay_mutex.unlock();
+    return 0;
+}
+
+int QEglFSKmsGbmScreen::startDispOverlayPlane()
+{
+    m_start_flip_overlay_plane = true;
+    return 0;
+}
+
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.h b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.h
index b94f44b7b1e..ca9e7a4bbca 100644
--- a/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.h
+++ b/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.h
@@ -44,12 +44,18 @@
 
 #include "qeglfskmsscreen.h"
 #include <QtCore/QMutex>
+#include <QtCore/QSemaphore>
+#include <QtCore/QQueue>
 
 #include <gbm.h>
 
 QT_BEGIN_NAMESPACE
 
+#define MAX_NUM_PLANES 10
+
 class QEglFSKmsGbmCursor;
+class DrmPageFlip;
+typedef void (*m_fnptr_user_callback)(void *data);
 
 class QEglFSKmsGbmScreen : public QEglFSKmsScreen
 {
@@ -68,19 +74,37 @@ public:
     void waitForFlip() override;
 
     void flip();
+    void flipFinished();
+
+    int addOverlayBuffer(uint32_t width,
+        uint32_t height,
+        uint32_t pixel_format,
+        uint32_t *strides,
+        uint32_t *offsets,
+        uint32_t buf_fd,
+        uint32_t *buf_id);
+    int removeOverlayBuffer(uint32_t buf_id);
+    int setPlaneProperties(uint8_t planeType, uint8_t idx,
+        uint8_t numProp, const char **propName, uint32_t *propVal);
+    int getPlaneProperty(uint8_t planeType, uint8_t idx, const char *propName);
+    int createOverlayPlane();
+    int distroyOverlayPlane(int pcnt);
+    int queueOverlayPlane(uint32_t idx, uint32_t fbId);
+    int startDispOverlayPlane();
+    m_fnptr_user_callback m_hndl_user_callback;
+    void *m_user_data;
+    bool m_qpa_flip_call;
+    bool m_user_flip_call;
+    bool m_start_flip_overlay_plane;
+    QMutex m_flip_mutex;
+    QSemaphore m_flip_event;
+    friend class DrmPageFlip;
 
 private:
-    void flipFinished();
     void ensureModeSet(uint32_t fb);
     void cloneDestFlipFinished(QEglFSKmsGbmScreen *cloneDestScreen);
     void updateFlipStatus();
 
-    static void pageFlipHandler(int fd,
-                                unsigned int sequence,
-                                unsigned int tv_sec,
-                                unsigned int tv_usec,
-                                void *user_data);
-
     gbm_surface *m_gbm_surface;
 
     gbm_bo *m_gbm_bo_current;
@@ -103,6 +127,15 @@ private:
     QVector<CloneDestination> m_cloneDests;
 
     static QMutex m_waitForFlipMutex;
+
+    bool m_flip_primary_plane;
+    QMutex m_overlay_mutex;
+    QMutex m_primary_mutex;
+    QQueue<uint32_t> overlayPlaneFbIdQueue[MAX_NUM_PLANES];
+    uint32_t m_plane_id[MAX_NUM_PLANES];
+    uint8_t m_plane_idx;
+    uint32_t m_primary_plane_fb;
+    DrmPageFlip *m_drm_page_flip;
 };
 
 QT_END_NAMESPACE
-- 
2.17.1

