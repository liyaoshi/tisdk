From e564712f1e48d1c92ef3cd4b080dd83f21080072 Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Tue, 9 May 2017 11:12:53 -0400
Subject: [PATCH 03/12] IEC-62439-3-MIB: update lreInterfaceConfigTable for MFD
 interface

Previous version of the lreInterfaceConfigTable was based on example
table, however it is recommended to use MFD interface for advanced
table since this create a template code for everything except for the
data access methods to implement the table. So switch to MFD based code
generated mib2c tool using mib2c.mfd.conf. Add dummy values for now
to test the initial version.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
---
 .../defaults/node-lreDupListResideMaxTime.m2d      |   35 +
 .../defaults/node-lreDuplicateDiscard.m2d          |   35 +
 .../defaults/node-lreEvaluateSupervision.m2d       |   35 +
 .../defaults/node-lreHsrLREMode.m2d                |   35 +
 .../defaults/node-lreInterfaceConfigIndex.m2d      |   35 +
 .../defaults/node-lreLinkStatusA.m2d               |   35 +
 .../defaults/node-lreLinkStatusB.m2d               |   35 +
 .../defaults/node-lreMacAddress.m2d                |   43 +
 .../defaults/node-lreNodeName.m2d                  |   43 +
 .../defaults/node-lreNodeType.m2d                  |   35 +
 .../defaults/node-lreNodesTableClear.m2d           |   35 +
 .../defaults/node-lrePortAdminStateA.m2d           |   35 +
 .../defaults/node-lrePortAdminStateB.m2d           |   35 +
 .../defaults/node-lreProxyNodeTableClear.m2d       |   35 +
 .../defaults/node-lreRedBoxIdentity.m2d            |   35 +
 .../defaults/node-lreRowStatus.m2d                 |   35 +
 .../defaults/node-lreSwitchingEndNode.m2d          |   35 +
 .../defaults/node-lreTransparentReception.m2d      |   35 +
 .../defaults/node-lreVersionName.m2d               |   43 +
 .../defaults/table-lreInterfaceConfigTable.m2d     |  103 +
 .../lreInterfaceConfigTable-README-FIRST.txt       |  167 +
 ...eConfigTable-README-lreInterfaceConfigTable.txt | 1578 ++++++++++
 .../lreInterfaceConfigTable.c                      |  241 ++
 .../lreInterfaceConfigTable.h                      |  286 ++
 .../lreInterfaceConfigTable_data_access.c          |  771 +++++
 .../lreInterfaceConfigTable_data_access.h          |   79 +
 .../lreInterfaceConfigTable_data_get.c             | 1209 ++++++++
 .../lreInterfaceConfigTable_data_get.h             |   76 +
 .../lreInterfaceConfigTable_data_set.c             | 3268 ++++++++++++++++++++
 .../lreInterfaceConfigTable_data_set.h             |  140 +
 .../lreInterfaceConfigTable_enums.h                |  290 ++
 .../lreInterfaceConfigTable_interface.c            | 2913 +++++++++++++++++
 .../lreInterfaceConfigTable_interface.h            |   99 +
 .../lreInterfaceConfigTable_oids.h                 |   94 +
 .../mibgroup/IEC-62439-3-MIB/lreManufacturerName.c |   62 +
 .../mibgroup/IEC-62439-3-MIB/lreManufacturerName.h |   12 +
 agent/mibgroup/iec-62439-3-mib.h                   |    4 +-
 .../iec-62439-3-mib/lreInterfaceConfigTable.c      |  243 --
 .../iec-62439-3-mib/lreInterfaceConfigTable.h      |   39 -
 .../mibgroup/iec-62439-3-mib/lreManufacturerName.c |   64 -
 .../mibgroup/iec-62439-3-mib/lreManufacturerName.h |   12 -
 41 files changed, 12079 insertions(+), 360 deletions(-)
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreDupListResideMaxTime.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreDuplicateDiscard.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreEvaluateSupervision.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreHsrLREMode.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreInterfaceConfigIndex.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreLinkStatusA.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreLinkStatusB.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreMacAddress.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreNodeName.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreNodeType.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreNodesTableClear.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lrePortAdminStateA.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lrePortAdminStateB.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreProxyNodeTableClear.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreRedBoxIdentity.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreRowStatus.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreSwitchingEndNode.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreTransparentReception.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreVersionName.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/table-lreInterfaceConfigTable.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable-README-FIRST.txt
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable-README-lreInterfaceConfigTable.txt
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_access.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_access.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_get.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_get.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_set.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_set.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_enums.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_interface.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_interface.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_oids.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreManufacturerName.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreManufacturerName.h
 delete mode 100644 agent/mibgroup/iec-62439-3-mib/lreInterfaceConfigTable.c
 delete mode 100644 agent/mibgroup/iec-62439-3-mib/lreInterfaceConfigTable.h
 delete mode 100644 agent/mibgroup/iec-62439-3-mib/lreManufacturerName.c
 delete mode 100644 agent/mibgroup/iec-62439-3-mib/lreManufacturerName.h

diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreDupListResideMaxTime.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreDupListResideMaxTime.m2d
new file mode 100644
index 0000000..b4cbc1c
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreDupListResideMaxTime.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreDupListResideMaxTime
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreDuplicateDiscard.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreDuplicateDiscard.m2d
new file mode 100644
index 0000000..f674ae8
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreDuplicateDiscard.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreDuplicateDiscard
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreEvaluateSupervision.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreEvaluateSupervision.m2d
new file mode 100644
index 0000000..5016008
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreEvaluateSupervision.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreEvaluateSupervision
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreHsrLREMode.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreHsrLREMode.m2d
new file mode 100644
index 0000000..ff52791
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreHsrLREMode.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreHsrLREMode
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreInterfaceConfigIndex.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreInterfaceConfigIndex.m2d
new file mode 100644
index 0000000..f4e65a9
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreInterfaceConfigIndex.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreInterfaceConfigIndex
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreLinkStatusA.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreLinkStatusA.m2d
new file mode 100644
index 0000000..2f7eb01
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreLinkStatusA.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreLinkStatusA
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreLinkStatusB.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreLinkStatusB.m2d
new file mode 100644
index 0000000..0952a96
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreLinkStatusB.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreLinkStatusB
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreMacAddress.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreMacAddress.m2d
new file mode 100644
index 0000000..eb1c67c
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreMacAddress.m2d
@@ -0,0 +1,43 @@
+########################################################################
+##
+## mib2c node setting for lreMacAddress
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = char@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 1@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
+########################################################################
+## Allow realloc when data size exceeds length? If your data
+## store for this node is a pointer allocated with one of the
+## alloc family functions, you can set this to 1 to use realloc
+## when a new value length exceeds the old lenght. If you are
+## using a fixed size buffer, this value should be 0.
+##
+## @eval $m2c_node_realloc = 0@
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreNodeName.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreNodeName.m2d
new file mode 100644
index 0000000..8df3d31
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreNodeName.m2d
@@ -0,0 +1,43 @@
+########################################################################
+##
+## mib2c node setting for lreNodeName
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = char@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 1@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
+########################################################################
+## Allow realloc when data size exceeds length? If your data
+## store for this node is a pointer allocated with one of the
+## alloc family functions, you can set this to 1 to use realloc
+## when a new value length exceeds the old lenght. If you are
+## using a fixed size buffer, this value should be 0.
+##
+## @eval $m2c_node_realloc = 0@
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreNodeType.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreNodeType.m2d
new file mode 100644
index 0000000..eaa894a
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreNodeType.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreNodeType
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreNodesTableClear.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreNodesTableClear.m2d
new file mode 100644
index 0000000..f8fda0b
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreNodesTableClear.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreNodesTableClear
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lrePortAdminStateA.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lrePortAdminStateA.m2d
new file mode 100644
index 0000000..048cf2d
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lrePortAdminStateA.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lrePortAdminStateA
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lrePortAdminStateB.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lrePortAdminStateB.m2d
new file mode 100644
index 0000000..7a9d2a8
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lrePortAdminStateB.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lrePortAdminStateB
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreProxyNodeTableClear.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreProxyNodeTableClear.m2d
new file mode 100644
index 0000000..944c074
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreProxyNodeTableClear.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreProxyNodeTableClear
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreRedBoxIdentity.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreRedBoxIdentity.m2d
new file mode 100644
index 0000000..977786b
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreRedBoxIdentity.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreRedBoxIdentity
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreRowStatus.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreRowStatus.m2d
new file mode 100644
index 0000000..11eb443
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreRowStatus.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreRowStatus
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreSwitchingEndNode.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreSwitchingEndNode.m2d
new file mode 100644
index 0000000..6a5f83b
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreSwitchingEndNode.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreSwitchingEndNode
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreTransparentReception.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreTransparentReception.m2d
new file mode 100644
index 0000000..381511f
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreTransparentReception.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreTransparentReception
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreVersionName.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreVersionName.m2d
new file mode 100644
index 0000000..f7ba1a9
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/node-lreVersionName.m2d
@@ -0,0 +1,43 @@
+########################################################################
+##
+## mib2c node setting for lreVersionName
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = char@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 1@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
+########################################################################
+## Allow realloc when data size exceeds length? If your data
+## store for this node is a pointer allocated with one of the
+## alloc family functions, you can set this to 1 to use realloc
+## when a new value length exceeds the old lenght. If you are
+## using a fixed size buffer, this value should be 0.
+##
+## @eval $m2c_node_realloc = 0@
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/table-lreInterfaceConfigTable.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/table-lreInterfaceConfigTable.m2d
new file mode 100644
index 0000000..e253ba5
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/defaults/table-lreInterfaceConfigTable.m2d
@@ -0,0 +1,103 @@
+## ########################################################################
+##
+## mib2c Table setting for lreInterfaceConfigTable
+##
+## ########################################################################
+##
+## User context structure type
+##
+@eval $m2c_context_reg = "netsnmp_data_list"@
+##
+## ########################################################################
+##
+## Allocate data structure in row structure? (vs embedd)
+##
+@eval $m2c_data_allocate = 0@
+##
+## ########################################################################
+##
+## Generate code to cache data?
+##
+@eval $m2c_data_cache = 1@
+##
+## ########################################################################
+##
+## Data context structure type
+##
+@eval $m2c_data_context = "generated"@ [generated|NAME]
+##
+## ########################################################################
+##
+## Generate function to initialize row context when created?
+##
+@eval $m2c_data_init = 1@
+##
+## ########################################################################
+##
+## Persistence of data context
+## // 0:persistent, 1:semi-transient, 2:transient
+##
+@eval $m2c_data_transient = 2@
+##
+## ########################################################################
+##
+## Include some example code?
+##
+@eval $m2c_include_examples = 1@
+##
+## ########################################################################
+##
+## Generate code for irreversible_commit mode?
+##
+@eval $m2c_irreversible_commit = 0@
+##
+## ########################################################################
+##
+## Data access method
+##
+@eval $m2c_table_access = "container-cached"@
+##
+## ########################################################################
+##
+## Generate row dependency function?
+##
+@eval $m2c_table_dependencies = 1@
+##
+## ########################################################################
+##
+## Generate data store/restore functions for persistent storage?
+##
+@eval $m2c_table_persistent = 1@
+##
+## ########################################################################
+##
+## Generate code for dynamic row creation?
+##
+@eval $m2c_table_row_creation = 1@
+##
+## ########################################################################
+##
+## Generate code for settable objects?
+##
+@eval $m2c_table_settable = 1@
+##
+## ########################################################################
+##
+## Skip mapping between data context and MIB formats?
+## // 0:generate maps, 1:skip maps, -1:skip unless enum/oid
+##
+@eval $m2c_table_skip_mapping = 1@
+##
+## ########################################################################
+##
+## Generate code for sparse tables?
+##
+@eval $m2c_table_sparse = 0@
+##
+## ########################################################################
+##
+## Generate Makefile/AgentX code?
+##
+@eval $mfd_generate_makefile = 0@
+@eval $mfd_generate_subagent = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable-README-FIRST.txt b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable-README-FIRST.txt
new file mode 100644
index 0000000..e410dd3
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable-README-FIRST.txt
@@ -0,0 +1,167 @@
+************************************************************************
+lreInterfaceConfigTable README
+------------------------------------------------------------------------
+This document describes the results of the mib2c code generation
+system using the mfd code generation template.  The resulting files
+are documented both in this README file as well as per-table specific
+README files.  All of the files generated by this run of mib2c will
+begin with the lreInterfaceConfigTable prefix.
+
+Quick Start
+-----------
+For those interested in a quick start, to get a pseudo-todo list, try
+this command in directory with the generated code:
+
+ grep -n "TODO:" *.[ch] | sed 's/\([^ ]*\) \(.*\)TODO\(.*\)/\3 (\1)/' | sort -n
+
+Key:
+  :o: Optional
+  :r: Recommended
+  :M: Mandatory
+  :A: Advanced users
+
+This will give you and ordered list of places in the code that you
+may (or must) take a closer look at).
+
+You may also want to take a look at the on-line tutorial, found here:
+
+    http://www.net-snmp.org/tutorial/tutorial-5/toolkit/mfd/index.html
+
+
+MIBs For Dummies Overview
+-------------------------
+The MIBs For Dummies (MFD) configuration files have been written to help
+SNMP novices implement SNMP MIBs. This section will be a brief
+introduction to some of the general concepts you should be familar with.
+
+  Managed Information Base (MIB)
+  ------------------------------
+  A SNMP MIB (Managed information base) is a text file that describes the
+  syntax for some set of data objects. The MIB creates a correlation
+  between an ASCII name for an object and a number OID (Object Identifier).
+  The SNMP protocol communicates information using the OIDs, and the MIB
+  allows tools to display a name, which we humans find easier to deal with.
+
+  To use an analogy, a MIB is much like a menu at a restaurant. If you've
+  ever been to a reataurant and ordered a meal, and later received a bill
+  that simply had '#6' on it, you get the idea. The name is easier for
+  the customers to remember, and the waiters and chefs use the number for
+  efficency.
+
+
+    Scalars
+    -------
+    A scalar variable is a unique object in a MIB which can represent
+    a single value. For example, the SNMP standard MIB-II defines a
+    variable, sysContact.0, which is a string containing the contact
+    information for the person in charge of a particular agent. Note
+    that scalar variable always end with '.0'.
+
+
+    Rows and Tables
+    ---------------
+    When a group of related attributes occur more than once, they can be
+    grouped together in a table. A table has an index, which uniquely
+    identifies a particular row, and data columns, which contain the
+    attributes for that row.
+
+    For example, the SNMP standard MIB-II defines a table, ifTable, which
+    contains information on the ethernet interfaces on a system.
+
+
+  Data Structures
+  ---------------
+  The code generated by the MFD configuration files has a few important
+  structures.
+
+
+    The Data Context
+    ----------------
+    The data context structure should contain the necessary information
+    to provide the data for the columns in a given row. As long as you
+    can extract the data for a column for the data context, the data context
+    can be anything you want: a pointer to an existing structure, the
+    parameters needed for a function call or an actual copy of the data.
+
+    By default, a data context structure is generated with storage for
+    all the data in a row. Information on changing the default is presented
+    later on in this help.
+
+
+    The MIB Context
+    ---------------
+    The MIB context structure is generated with storage for all the
+    indexes of a table. This data will be used when searching for the
+    correct row to process for a request.
+
+
+    The Row Request Context
+    -----------------------
+    Each table will have a unique data structure for holding data during
+    the processing of a particular row. The row request context contains
+    the registration context (that you supply during initilization),
+    the data context, the MIB context, the undo context (for settable
+    tables) and other data. There is also a netsnmp_data_list, which can
+    be used to temporary storage during processing.
+
+
+    The Table Registration Pointer
+    ------------------------------
+    During initilization, you may provide a pointer to arbitrary data for
+    you own use. This pointer will be saved in the row request context,
+    and is passed as a parameter to several functions. It is not required,
+    and is provided as a way for you to access table specific data in
+    the generated code.
+
+
+
+These files are top-level files potentially useful for all the tables:
+------------------------------------------------------------------------
+
+  File    : lreInterfaceConfigTable_Makefile
+  ----------------------------------------------------------------------
+  Purpose : Make file for compiling a (sub)agent.  This file is only
+            useful if you don't want to compile your code directly
+            into the Net-SNMP master agent.
+  Editable: Optional
+  Usage   : make -f lreInterfaceConfigTable_Makefile
+
+
+  File    : lreInterfaceConfigTable_subagent.c
+  ----------------------------------------------------------------------
+  Purpose : This file contains a main() function for an agent or
+            sub-agent and is compiled using the Makefile above.
+
+
+
+
+Table specific README files
+------------------------------------------------------------------------
+Each table for which code was generated has its own README file
+describing the files specifically associated with each table.  You
+should probably read these next:
+
+   lreInterfaceConfigTable-README-lreInterfaceConfigTable.txt
+
+
+
+These are miscellaneous auto-generated code files you generally
+shouldn't edit.  They contain code that ties your code together with
+the Net-SNMP agent.
+------------------------------------------------------------------------
+  File    : lreInterfaceConfigTable.h
+  Purpose : Header file for the module set.  Includes config_require
+            macros to auto-load the other code pieces when compiled
+            into the agent.
+
+  File    : lreInterfaceConfigTable_oids.h
+  Purpose : C #define definitions of the tables, columns, and OIDs
+
+  File    : lreInterfaceConfigTable_enums.h
+  Purpose : C #define definitions of the enumerated type values for
+            each column of each table that requires them.
+
+  File    : lreInterfaceConfigTable_interface.c
+  Purpose : MFD interface to Net-SNMP.  This auto-generated code ties the
+            functions you will fill out to the code that the agent needs.
+
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable-README-lreInterfaceConfigTable.txt b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable-README-lreInterfaceConfigTable.txt
new file mode 100644
index 0000000..f2bfe4f
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable-README-lreInterfaceConfigTable.txt
@@ -0,0 +1,1578 @@
+************************************************************************
+lreInterfaceConfigTable README
+------------------------------------------------------------------------
+  This readme file describes the code generated by mib2c (using the MIBs
+  for Dummies (MFD) configuration file). The code generated was
+  generated specifically for the following SNMP table:
+
+     lreInterfaceConfigTable
+
+  Your code will be called when the snmp agent receives requests for
+  the lreInterfaceConfigTable table.  The agent will start by looking for the right
+  row in your existing data to operate on, if one exists.
+
+
+  Configuration Variables
+  ------------------------------------------------------------
+  Some variables used for code generation may be set to affect the code
+  generation. You may override these variables by setting them in the
+  file defaults/table-lreInterfaceConfigTable.m2d, and then re-running mib2c.
+
+    m2c_table_settable (currently '1')
+    --------------------------------------------------------
+    This variable determines whether or not code is generated to support
+    MIB object which have an access of read-write or read-create. The
+    default is set based on whether or not the table contains writable
+    objects, but can be over-ridden.
+
+    Syntax: @eval $m2c_table_settable = 0@
+
+
+    m2c_table_dependencies (currently '1')
+    --------------------------------------------------------
+    This variable determines whether or not code is generated to support
+    checking dependencies between columns, rows or tables. The default
+    is set based on whether or not the table contains writable objects,
+    but can be over-ridden.
+
+    Syntax: @eval $m2c_table_dependencies = 0@
+
+
+    m2c_table_row_creation (currently '1')
+    --------------------------------------------------------
+    This variable determines whether or not code is generated to support
+    checking creation of new rows via SNMP. The default is set based on
+    whether or not the table contains read-create objects, but can be
+    over-ridden.
+
+    Syntax: @eval $m2c_table_row_creation = 0@
+
+
+    m2c_context_reg (currently 'netsnmp_data_list')
+    --------------------------------------------------------
+    This variable contains the structure name to typedef for the
+    lreInterfaceConfigTable_registration.
+
+    During initilization, you will provide a pointer to a structure of
+    this type. This pointer is used as a parameter to many functions so
+    that you have access to your registration data. The default is a
+    netsnmp_data_list pointer, which will allow you to keep multiple
+    pointers tagged by a text name. If you have a new or existing structure
+    you would rather use, you can redefine this variable.
+
+
+    To avoid regenerating code, you may also change this typedef directly
+    in the lreInterfaceConfigTable.h header.
+
+    Syntax: @eval $m2c_context_reg = "struct my_registration_context@
+
+
+    m2c_data_context (currently 'generated')
+    --------------------------------------------------------
+    This variable contains the structure name to typedef for the
+    lreInterfaceConfigTable_data.
+
+    This typedef is used in the row request context structure for the table,
+    lreInterfaceConfigTable_rowreq_ctx.
+
+    The typedef in the primary table context will be used for the data and
+    undo structure types. This structure should contain all the data
+    needed for all the columns in the table. The default is 'generated',
+    which will cuase a new data strcuture to be generated with data members
+    for each column.
+
+    To avoid regenerating code, you may also change this typedef directly
+    in the lreInterfaceConfigTable.h header.
+
+    Syntax: @eval $m2c_data_context = "struct my_data_context"@
+
+
+    m2c_data_allocate (currently '0')
+    --------------------------------------------------------
+    This variable determines whether or not the data context (see above)
+    requires memory to be allocated. The default generated data structure
+    does not. If you are using a custom data context which needs to
+    allocate memory, override this value and two additional functions
+    will be generated:
+
+      lreInterfaceConfigTable_allocate_data
+      lreInterfaceConfigTable_release_data
+
+    Syntax: @eval $m2c_data_allocate = 1@
+
+
+    m2c_data_init (currently '1')
+    --------------------------------------------------------
+    This variable determines whether or not the data context (see above)
+    or any other items you have added to the table context requires
+    initialization. The default generated data structure does not. If you
+    are using a custom data context or have added items needing initialization
+    to the table context, override this value and two additional functions
+    will be generated:
+
+      lreInterfaceConfigTable_rowreq_ctx_init
+      lreInterfaceConfigTable_rowreq_ctx_cleanup
+
+    Syntax: @eval 1 = 1@
+
+
+    m2c_table_access (currently 'container-cached')
+    ------------------------------------------------------------------
+    This variable determines which data interface will be use to generate
+    code for looking up data for a given index. The default is the
+    'container-cached' access code, which caches the data in a netsnmp-
+    container (usually a sorted array).
+
+    Available options can be determined by checking for mib2c configuration
+    files that begin with 'mfd-access-*'.
+
+    Syntax: @eval $m2c_table_access = 'container-cached'@
+
+
+    m2c_include_examples (currently '1')
+    ------------------------------------------------------------------
+    This variable determines whether or not to generate example code. The
+    default is to generate example code.
+
+    Syntax: @eval $m2c_include_examples = 0@
+
+
+    m2c_data_transient (currently '2')
+    ------------------------------------------------------------------
+    This variable determines how the generated example code deals with the
+    data during data lookup. See the table readme file for details on how
+    the current table access method interprets this value. In general,
+    a value of 0 indicates persistent data, 1 indicates semi-transient and
+    2 indicates transient data.
+
+    Syntax: @eval $m2c_data_transient = 0@
+
+
+ Index(es) for the lreInterfaceConfigTable table
+  ------------------------------------------------------------
+  The index(es) for the lreInterfaceConfigTable table are:
+
+     lreInterfaceConfigIndex:
+        Syntax:      UNSIGNED32
+        DataType:    UNSIGNED32
+        ASN type:    ASN_UNSIGNED
+        C-code type: u_long
+
+  You should know how to set all these values from your data context,
+  lreInterfaceConfigTable_data.
+
+
+************************************************************************
+lreInterfaceConfigTable File Overview
+------------------------------------------------------------------------
+  Several files have been generated to implement the lreInterfaceConfigTable
+  table. We'll go through these files, one by one, explaining each and
+  letting you know which you need to edit.
+
+
+File: lreInterfaceConfigTable_data_access.[c|h]
+------------------------------------------------------------------------
+  The lreInterfaceConfigTable_data_access file contains the interface to your data in
+  its raw format.  These functions are used to build the row cache or
+  locate the row (depending on the table access method).
+
+  Set MIB context
+  -----------------
+  TODO : Set MIB index values
+  FUNC : lreInterfaceConfigTable_indexes_set
+  WHERE: lreInterfaceConfigTable_data_access.c
+
+  This is a convenience function for setting the index context from
+  the native C data. Where necessary, value mapping should be done.
+
+  This function should update the table index values (found in
+  tbl_idx) for the given raw data.
+
+
+  container summary
+  ------------------------
+    The container data access code is for cases when you want to
+    store your data in the agent/sub-agent.
+
+    ... to be continued...
+
+
+  cache summary
+  ------------------------
+    The container-cached data access code is for cases when you want to
+    cache your data in the agent/sub-agent.
+
+    ... to be continued...
+
+
+
+
+File: lreInterfaceConfigTable_enums.h
+------------------------------------------------------------------------
+  This file contains macros for mapping enumeration values when the
+  enumerated values defined by the MIB do not match the values used
+  internally.
+
+  Review this file to see if any values need to be updated.
+
+
+File: lreInterfaceConfigTable_data_get.c
+------------------------------------------------------------------------
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreRowStatus_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreNodeType_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreNodeName_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreVersionName_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreMacAddress_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lrePortAdminStateA_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lrePortAdminStateB_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreLinkStatusA_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreLinkStatusB_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreDuplicateDiscard_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreTransparentReception_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreHsrLREMode_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreSwitchingEndNode_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreRedBoxIdentity_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreEvaluateSupervision_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreNodesTableClear_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreProxyNodeTableClear_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreDupListResideMaxTime_get
+
+
+
+File: lreInterfaceConfigTable_data_set.c
+------------------------------------------------------------------------
+
+  This code was generated based on the following assumptions or settings:
+
+  1) None of the values for this table have DEPENDENCIES on other objects.
+
+  DEPENDENCIES on other objects complicates SET request processing. When
+  one or more columns in a table depend on another object (in the same
+  table, or in another table), a DEPENDENCY exists. For example, if you
+  have a table that determine a color with three columns (red, green and
+  blue) that define the percentage of each primary color, the total for
+  the three columns must equal 100 percent. So, in addition to checking
+  that each colums has a valid value between 0 and 100, the total of
+  all three columns must equal 100.
+
+  Set $m2c_table_dependencies = 0 in defaults/table-lreInterfaceConfigTable.m2d
+  and regenerate code if this assumption is incorrect.
+
+  2) This table supports ROW CREATION.
+
+  Supporting ROW CREATION allows new rows to be created via SNMP requests.
+
+  To support row creation, the index component of an incoming set request must
+  be validated. A funciton is generated for each individual index component,
+  and another for validating all the index components together.
+
+
+  Validate index component
+  ------------------------
+  TODO : validate the specified index component
+  FUNC : lreInterfaceConfigIndex_check_index
+
+
+  Validate index
+  --------------
+  TODO : check that all index components are valid
+  FUNC : lreInterfaceConfigTable_validate_index
+
+
+  Check dependencies
+  ------------------
+  TODO : check that all dependencies have been satisfied
+  FUNC : lreInterfaceConfigTable_check_dependencies
+
+  This function will be called after all the individual columns have been
+  set to their new values. Check for any dependencies between rows or
+  tables in this function.
+
+
+  Undo setup
+  ----------
+  TODO : save data for undo
+  FUNC : lreInterfaceConfigTable_undo_setup
+
+  This function will be called before the individual undo_setup functions are
+  called. This is where you should save any undo information which is not
+  directly related to a particular column. This function will only be called
+  once per row. After this function is called, any column which is being
+  set will have its individual node undo_setup function called.
+
+
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lreRowStatus_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lreRowStatus_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lreRowStatus_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lreRowStatus_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lreNodeType_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lreNodeType_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lreNodeType_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lreNodeType_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lreNodeName_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lreNodeName_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lreNodeName_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lreNodeName_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lreMacAddress_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lreMacAddress_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lreMacAddress_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lreMacAddress_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lrePortAdminStateA_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lrePortAdminStateA_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lrePortAdminStateA_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lrePortAdminStateA_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lrePortAdminStateB_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lrePortAdminStateB_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lrePortAdminStateB_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lrePortAdminStateB_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lreDuplicateDiscard_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lreDuplicateDiscard_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lreDuplicateDiscard_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lreDuplicateDiscard_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lreTransparentReception_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lreTransparentReception_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lreTransparentReception_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lreTransparentReception_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lreHsrLREMode_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lreHsrLREMode_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lreHsrLREMode_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lreHsrLREMode_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lreSwitchingEndNode_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lreSwitchingEndNode_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lreSwitchingEndNode_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lreSwitchingEndNode_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lreRedBoxIdentity_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lreRedBoxIdentity_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lreRedBoxIdentity_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lreRedBoxIdentity_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lreEvaluateSupervision_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lreEvaluateSupervision_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lreEvaluateSupervision_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lreEvaluateSupervision_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lreNodesTableClear_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lreNodesTableClear_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lreNodesTableClear_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lreNodesTableClear_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lreProxyNodeTableClear_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lreProxyNodeTableClear_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lreProxyNodeTableClear_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lreProxyNodeTableClear_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+  Check value for column
+  ----------------------
+  TODO : perform additional validations on values for a set request
+  FUNC : lreDupListResideMaxTime_check_value
+
+  The generated code will automatically validate incoming requests against
+  all the requirements specified by the syntax of the MIB. However, it is
+  often the case that additional requirements are specified in the
+  description of a MIB object. Those type of validations should be checked
+  in this function.
+
+
+  Undo setup for column
+  ---------------------
+  TODO : save the value for column
+  FUNC : lreDupListResideMaxTime_undo_setup
+
+  After the table level undo setup function has been called, the individual
+  node undo setup functions will be called for columns which are being set.
+
+
+  Set value for column
+  --------------------
+  TODO : set the value for column
+  FUNC : lreDupListResideMaxTime_set
+
+  After all the validations have been passed, this function will be called to
+  set the new value.
+
+
+  Undo value for column
+  ---------------------
+  TODO : undo set for column
+  FUNC : lreDupListResideMaxTime_undo
+
+  If an error occurs after a column has been set, this function will be called
+  to undo the set and restore the previous state.
+
+
+
+  Commit changes
+  --------------
+  TODO : commit changes
+  FUNC : lreInterfaceConfigTable_commit
+
+  After all values have been set, the commit function will be called.
+
+
+
+
+
+************************************************************************
+lreInterfaceConfigTable Reference
+------------------------------------------------------------------------
+
+Function flow
+----------------------------------------------------
+To give you the general idea of how the functions flow works, this
+example flow is from a complete table implementation.
+
+NOTE: Depending on your configuration, some of the functions used in the
+      examples below  may not have been generated for the
+      lreInterfaceConfigTable table.
+
+      Conversely, the examples below may not include some functions that
+      were generated for the lreInterfaceConfigTable table.
+
+To watch the flow of the lreInterfaceConfigTable table, use the
+following debug tokens:
+
+        snmp_agent
+        helper:table:req
+        lreInterfaceConfigTable
+        verbose:lreInterfaceConfigTable
+        internal:lreInterfaceConfigTable
+
+e.g.
+        snmpd -f -Le -DlreInterfaceConfigTable,verbose:lreInterfaceConfigTable,internal:lreInterfaceConfigTable
+
+
+Initialization
+--------------------------------
+init_xxxTable: called                           xxx.c
+   initialize_table_xxxTable                    xxx.c
+      _xxxTable_initialize_interface            xxx_interface.c
+         xxxTable_init_data                     xxx_data_access.c
+      _xxxTable_container_init                  xxx_interface.c
+         xxxTable_container_init                xxx_data_access.c
+
+
+GET Request
+--------------------------------
+_cache_load                                     xxx_interface.c
+   xxxTable_cache_load                          xxx_data_access.c
+      xxxTable_allocate_rowreq_ctx              xxx_interface.c
+         xxxTable_allocate_data                 xxx_data_get.c
+         xxxTable_rowreq_ctx_init               xxx_data_get.c
+      xxxTable_indexes_set                      xxx_data_get.c
+         xxxTable_indexes_set_tbl_idx           xxx_data_get.c
+
+xxxTable_pre_request
+
+_mfd_xxxTable_object_lookup                     xxx_interface.c
+   xxxTable_row_prep                            xxx_data_access.c
+
+_mfd_xxxTable_get_values                        xxx_interface.c
+   _mfd_xxxTable_get_column                     xxx_interface.c
+      yyy_get                                   xxx_data_get.c
+
+xxxTable_post_request
+
+
+GETNEXT Request
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request                            ...
+_mfd_xxxTable_object_lookup                     ...
+_mfd_xxxTable_get_values                        ...
+xxxTable_post_request                           ...
+
+
+SET Request: success
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request
+_mfd_xxxTable_object_lookup                     ...
+
+_mfd_xxxTable_check_objects                     xxx_interface.c
+   _xxxTable_check_column                       xxx_interface.c
+      yyy_check_value                           xxx_data_set.c
+
+_mfd_xxxTable_undo_setup                        xxx_interface.c
+   xxxTable_allocate_data                       ...
+   xxxTable_undo_setup                          xxx_interface.c
+      _xxxTable_undo_setup_column               xxx_interface.c
+         yyy_undo_setup                         xxx_data_set.c
+
+_mfd_xxxTable_set_values                        xxx_interface.c
+   _xxxTable_set_column                         xxx_interface.c
+      yyy_set                                   xxx_data_set.c
+
+_mfd_xxxTable_check_dependencies                xxx_interface.c
+   xxxTable_check_dependencies                  xxx_data_set.c
+
+_mfd_xxxTable_commit                            xxx_interface.c
+   xxxTable_commit                              xxx_data_set.c
+
+_mfd_xxxTable_undo_cleanup                      xxx_interface.c
+   xxxTable_undo_cleanup                        xxx_data_set.c
+      xxxTable_release_data                     ...
+
+xxxTable_post_request                           ...
+
+
+SET Request: row creation
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request
+
+_mfd_xxxTable_object_lookup                     ...
+   xxxTable_index_from_oid                      xxx_interface.c
+   xxxTable_allocate_rowreq_ctx                 ...
+      ...
+   _xxxTable_check_indexes                      xxx_interface.c
+      yyy_check_index                           xxx_data_set.c
+      xxxTable_validate_index                   xxx_data_set.c
+
+_mfd_xxxTable_check_objects                     ...
+   _xxxTable_check_column                       ...
+      yyy_check_value                           ...
+   _xxxTable_check_column                       ...
+      yyy_check_value                           ...
+
+_mfd_xxxTable_undo_setup                        ...
+_mfd_xxxTable_set_values                        ...
+_mfd_xxxTable_check_dependencies                ...
+_mfd_xxxTable_commit                            ...
+_mfd_xxxTable_undo_cleanup                      ...
+xxxTable_post_request                           ...
+
+
+SET Resuest: value error
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request                            ...
+_mfd_xxxTable_object_lookup                     ...
+
+_mfd_xxxTable_check_objects                     ...
+   _xxxTable_check_column                       ...
+      yyy_check_value                           ...
+      ERROR:"yyy value not supported"
+
+xxxTable_post_request                           ...
+
+
+SET Request: commit failure
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request                            ...
+_mfd_xxxTable_object_lookup                     ...
+_mfd_xxxTable_check_objects                     ...
+_mfd_xxxTable_undo_setup                        ...
+_mfd_xxxTable_set_values                        ...
+_mfd_xxxTable_check_dependencies                ...
+
+_mfd_xxxTable_commit                            ...
+   xxxTable_commit                              ...
+   ERROR: bad rc -1
+
+_mfd_xxxTable_undo_commit                       xxx_interface.c
+   xxxTable_undo_commit                         xxx_data_set.c
+
+_mfd_xxxTable_undo_values                       xxx_interface.c
+   _xxxTable_undo_column                        xxx_interface.c
+      yyy_undo                                  xxx_data_set.c
+
+_mfd_xxxTable_undo_cleanup                      ...
+xxxTable_post_request                           ...
+
+
+Row release (user initiated)
+--------------------------------
+xxxTable_release_rowreq_ctx                     xxx_interface.c
+   xxxTable_rowreq_ctx_cleanup                  xxx_data_get.c
+   xxxTable_release_data                        xxx_data_get.c
+
+
+
+Table / column details
+----------------------------------------------------
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceConfigTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceConfigTable is subid 1 of lreConfigurationInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.0.1.0.1, length: 9
+*/
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreInterfaceConfigIndex
+ * lreInterfaceConfigIndex is subid 1 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is NoAccess.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.1
+ * Description:
+A unique value for each LRE.
+ *
+ * Attributes:
+ *   accessible 0     isscalar 0     enums  0      hasdefval 0
+ *   readable   0     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
+ * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
+ *
+ *
+ *
+ * NOTE: NODE lreInterfaceConfigIndex IS NOT ACCESSIBLE
+ *
+ *
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreRowStatus
+ * lreRowStatus is subid 2 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is Create.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.2
+ * Description:
+indicates the status of the LRE table entry
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 6/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
+ *
+ * Its syntax is RowStatus (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreNodeType
+ * lreNodeType is subid 3 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.3
+ * Description:
+
+                specifies the operation mode of the LRE:
+                PRP mode 1 (1)
+                HSR mode (2)
+                Note: PRP mode 0 is considered deprecated and is not supported by this
+                revision of the MIB
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  prpmode1(1), hsr(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreNodeName
+ * lreNodeName is subid 4 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.4
+ * Description:
+specifies this LRE's node name
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 1      hashint   1
+ *   settable   1
+ *   hint: 255a
+ *
+ * Ranges:  0 - 255;
+ *
+ * Its syntax is DisplayString (based on perltype OCTETSTR)
+ * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
+ * This data type requires a length.  (Max 255)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreVersionName
+ * lreVersionName is subid 5 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.5
+ * Description:
+specifies the version of this LRE's software
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 1      hashint   0
+ *   settable   0
+ *
+ * Ranges:  1 - 32;
+ *
+ * Its syntax is OCTETSTR (based on perltype OCTETSTR)
+ * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
+ * This data type requires a length.  (Max 32)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreMacAddress
+ * lreMacAddress is subid 6 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.6
+ * Description:
+
+                Specifies the MAC address to be used by this LRE. MAC
+                addresses are
+                identical for all ports of a single LRE
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 1      hashint   1
+ *   settable   1
+ *   hint: 1x:
+ *
+ * Ranges:  6;
+ *
+ * Its syntax is MacAddress (based on perltype OCTETSTR)
+ * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
+ * This data type requires a length.  (Max 6)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lrePortAdminStateA
+ * lrePortAdminStateA is subid 7 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.7
+ * Description:
+
+                Specifies whether the port A shall be active or not Active
+                through
+                administrative action (Default: active).
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  notActive(1), active(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lrePortAdminStateB
+ * lrePortAdminStateB is subid 8 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.8
+ * Description:
+
+                Specifies whether the port B shall be active or not Active
+                through
+                administrative action (Default: active).
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  notActive(1), active(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreLinkStatusA
+ * lreLinkStatusA is subid 9 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.9
+ * Description:
+shows the actual link status of the LRE's port A
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ * Enum range: 2/8. Values:  up(1), down(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreLinkStatusB
+ * lreLinkStatusB is subid 10 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.10
+ * Description:
+shows the actual link status of the LRE's port B
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ * Enum range: 2/8. Values:  up(1), down(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreDuplicateDiscard
+ * lreDuplicateDiscard is subid 11 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.11
+ * Description:
+
+                specifies whether a duplicate discard algorithm is used at
+                reception
+                (Default: discard).
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  doNotDiscard(1), discard(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreTransparentReception
+ * lreTransparentReception is subid 12 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.12
+ * Description:
+
+                if removeRCT is configured, the RCT is removed when
+                forwarding to the upper
+                layers, only applicable for PRP LRE (Default: removeRCT).
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  removeRCT(1), passRCT(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreHsrLREMode
+ * lreHsrLREMode is subid 13 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.13
+ * Description:
+
+                This enumeration is only applicable if the LRE is an HSR
+                bridging node or RedBox.
+                It shows the mode of the HSR LRE:
+                (1) Default mode: The HSR LRE is in mode h and bridges tagged HSR traffic
+                (2) Optional mode: The HSR LRE is in mode n and bridging between its HSR ports
+                Is disabled.
+                Traffic is HSR tagged.
+                (3) Optional mode: The HSR LRE is in mode t and bridges non-tagged HSR traffic
+                between its HSR ports
+                (4) Optional mode: The HSR LRE is in mode u and behaves like in mode h, except it
+                does not remove unicast messages
+                (5) Optional mode: The HSR LRE is configured in mixed mode. HSR frames are handled
+                according to mode h. Non-HSR frames are handled according to
+                802.1D bridging rules.
+                (6) Optional mode: The HSR LRE is in mode x and behaves like in mode h, except it
+                does not send a frame that is a duplicate of a frame that is received completely
+                and correctly from the opposite direction
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 4/8. Values:  modeh(1), moden(2), modet(3), modeu(4), modem(5), modex(6)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreSwitchingEndNode
+ * lreSwitchingEndNode is subid 14 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.14
+ * Description:
+
+                This enumeration shows which feature is enabled in this
+                particular LRE:
+                (1): an unspecified non-bridging node, e.g. SRP.
+                (2): an unspecified bridging node, e.g. RSTP.
+                (3): a PRP node/RedBox.
+                (4): an HSR RedBox with regular Ethernet traffic on its interlink.
+                (5): an HSR switching node.
+                (6): an HSR RedBox with HSR tagged traffic on its interlink.
+                (7): an HSR RedBox with PRP traffic for LAN A on its interlink.
+                (8): an HSR RedBox with PRP traffic for LAN B on its interlink.
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 5/16. Values:  nonbridgingnode(1), bridgingunspecified(2), prpnode(3), hsrredboxsan(4), hsrnode(5), hsrredboxhsr(6), hsrredboxprpa(7), hsrredboxprpb(8)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreRedBoxIdentity
+ * lreRedBoxIdentity is subid 15 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.15
+ * Description:
+
+                Applicable to RedBox HSR-PRP A and RedBox HSR-PRP B. One ID
+                is used by
+                one pair of RedBoxes (one configured to A and one configured to B)
+                coupling an HSR ring to a PRP network. The integer value states the value
+                of the path field a RedBox inserts into each frame it receives from its
+                interlink and injects into the HSR ring. When interpreted as binary values,
+                the LSB denotes the configuration of the RedBox (A or B), and the following
+                3 bits denote the identifier of a RedBox pair.
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 9/16. Values:  id1a(2), id1b(3), id2a(4), id2b(5), id3a(6), id3b(7), id4a(8), id4b(9), id5a(10), id5b(11), id6a(12), id6b(13), id7a(14), id7b(15)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreEvaluateSupervision
+ * lreEvaluateSupervision is subid 16 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.16
+ * Description:
+
+                True if the LRE evaluates received supervision frames. False
+                if it
+                drops the supervision frames without evaluating. Note: LREs are required
+                to send supervision frames, but reception is optional. Default value is dependent
+                on implementation.
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  true(1), false(2)
+ *
+ * Its syntax is TruthValue (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreNodesTableClear
+ * lreNodesTableClear is subid 17 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.17
+ * Description:
+specifies that the Node Table is to be cleared
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  noOp(0), clearNodeTable(1)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreProxyNodeTableClear
+ * lreProxyNodeTableClear is subid 18 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.18
+ * Description:
+specifies that the Proxy Node Table is to be cleared
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  noOp(0), clearProxyNodeTable(1)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreDupListResideMaxTime
+ * lreDupListResideMaxTime is subid 19 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.19
+ * Description:
+the longest time an entry may reside in the duplicates list,
+              expressed as the number of seconds multiplied by 65536;
+              the default value is 26214 x 15 us, or 400 ms; too low a value can
+              cause broadcast storms
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 1
+ *   readable   1     iscolumn 1     ranges 0      hashint   1
+ *   settable   1
+ *   defval: 26214
+ *   hint: d
+ *
+ *
+ * Its syntax is SecondFraction (based on perltype INTEGER32)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
+ */
+
+
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable.c b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable.c
new file mode 100644
index 0000000..41d87cb
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable.c
@@ -0,0 +1,241 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+/** \page MFD helper for lreInterfaceConfigTable
+ *
+ * \section intro Introduction
+ * Introductory text.
+ *
+ */
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreInterfaceConfigTable.h"
+
+#include <net-snmp/agent/mib_modules.h>
+
+#include "lreInterfaceConfigTable_interface.h"
+
+const oid lreInterfaceConfigTable_oid[] = { LREINTERFACECONFIGTABLE_OID };
+const int lreInterfaceConfigTable_oid_size = OID_LENGTH(lreInterfaceConfigTable_oid);
+
+    lreInterfaceConfigTable_registration  lreInterfaceConfigTable_user_context;
+
+void initialize_table_lreInterfaceConfigTable(void);
+void shutdown_table_lreInterfaceConfigTable(void);
+
+
+/**
+ * Initializes the lreInterfaceConfigTable module
+ */
+void
+init_lreInterfaceConfigTable(void)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:init_lreInterfaceConfigTable","called\n"));
+
+    /*
+     * TODO:300:o: Perform lreInterfaceConfigTable one-time module initialization.
+     */
+
+    /*
+     * here we initialize all the tables we're planning on supporting
+     */
+    if (should_init("lreInterfaceConfigTable"))
+        initialize_table_lreInterfaceConfigTable();
+
+} /* init_lreInterfaceConfigTable */
+
+/**
+ * Shut-down the lreInterfaceConfigTable module (agent is exiting)
+ */
+void
+shutdown_lreInterfaceConfigTable(void)
+{
+    if (should_init("lreInterfaceConfigTable"))
+        shutdown_table_lreInterfaceConfigTable();
+
+}
+
+/**
+ * Initialize the table lreInterfaceConfigTable
+ *    (Define its contents and how it's structured)
+ */
+void
+initialize_table_lreInterfaceConfigTable(void)
+{
+    lreInterfaceConfigTable_registration * user_context;
+    u_long flags;
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:initialize_table_lreInterfaceConfigTable","called\n"));
+
+    /*
+     * TODO:301:o: Perform lreInterfaceConfigTable one-time table initialization.
+     */
+
+    /*
+     * TODO:302:o: |->Initialize lreInterfaceConfigTable user context
+     * if you'd like to pass in a pointer to some data for this
+     * table, allocate or set it up here.
+     */
+    /*
+     * a netsnmp_data_list is a simple way to store void pointers. A simple
+     * string token is used to add, find or remove pointers.
+     */
+    user_context = netsnmp_create_data_list("lreInterfaceConfigTable", NULL, NULL);
+
+    /*
+     * No support for any flags yet, but in the future you would
+     * set any flags here.
+     */
+    flags = 0;
+
+    /*
+     * call interface initialization code
+     */
+    _lreInterfaceConfigTable_initialize_interface(user_context, flags);
+} /* initialize_table_lreInterfaceConfigTable */
+
+/**
+ * Shutdown the table lreInterfaceConfigTable
+ */
+void
+shutdown_table_lreInterfaceConfigTable(void)
+{
+    /*
+     * call interface shutdown code
+     */
+    _lreInterfaceConfigTable_shutdown_interface(&lreInterfaceConfigTable_user_context);
+}
+
+/**
+ * extra context initialization (eg default values)
+ *
+ * @param rowreq_ctx    : row request context
+ * @param user_init_ctx : void pointer for user (parameter to rowreq_ctx_allocate)
+ *
+ * @retval MFD_SUCCESS  : no errors
+ * @retval MFD_ERROR    : error (context allocate will fail)
+ */
+int
+lreInterfaceConfigTable_rowreq_ctx_init(lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx,
+                           void *user_init_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_rowreq_ctx_init","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:210:o: |-> Perform extra lreInterfaceConfigTable rowreq initialization. (eg DEFVALS)
+     */
+    rowreq_ctx->data.lreDupListResideMaxTime = 26214;
+
+
+    return MFD_SUCCESS;
+} /* lreInterfaceConfigTable_rowreq_ctx_init */
+
+/**
+ * extra context cleanup
+ *
+ */
+void lreInterfaceConfigTable_rowreq_ctx_cleanup(lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_rowreq_ctx_cleanup","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:211:o: |-> Perform extra lreInterfaceConfigTable rowreq cleanup.
+     */
+} /* lreInterfaceConfigTable_rowreq_ctx_cleanup */
+
+/************************************************************
+ * the *_should_save routine is called to determine if a row
+ * should be stored persistently.
+ *
+ * Note that this is not a 'dirty' check (i.e. if a row has changed),
+ * but a check for volatile rows that should not be saved between
+ * restarts.
+ *
+ * return 1 if the row should be stored
+ * return 0 if the row should not be stored
+ */
+int
+lreInterfaceConfigTable_container_should_save(lreInterfaceConfigTable_rowreq_ctx * rowreq_ctx)
+{
+
+    return 1; /* save the row */
+}
+
+/**
+ * pre-request callback
+ *
+ *
+ * @retval MFD_SUCCESS              : success.
+ * @retval MFD_ERROR                : other error
+ */
+int
+lreInterfaceConfigTable_pre_request(lreInterfaceConfigTable_registration * user_context)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_pre_request","called\n"));
+
+    /*
+     * TODO:510:o: Perform lreInterfaceConfigTable pre-request actions.
+     */
+
+    return MFD_SUCCESS;
+} /* lreInterfaceConfigTable_pre_request */
+
+/**
+ * post-request callback
+ *
+ * Note:
+ *   New rows have been inserted into the container, and
+ *   deleted rows have been removed from the container and
+ *   released.
+ *
+ * @param user_context
+ * @param rc : MFD_SUCCESS if all requests succeeded
+ *
+ * @retval MFD_SUCCESS : success.
+ * @retval MFD_ERROR   : other error (ignored)
+ */
+int
+lreInterfaceConfigTable_post_request(lreInterfaceConfigTable_registration * user_context, int rc)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_post_request","called\n"));
+
+    /*
+     * TODO:511:o: Perform lreInterfaceConfigTable post-request actions.
+     */
+
+    /*
+     * check to set if any rows were changed.
+     */
+    if (lreInterfaceConfigTable_dirty_get()) {
+        /*
+         * check if request was successful. If so, this would be
+         * a good place to save data to its persistent store.
+         */
+        if (MFD_SUCCESS == rc) {
+            /*
+             * save changed rows, if you haven't already
+             */
+            snmp_store(netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
+                                             NETSNMP_DS_LIB_APPTYPE));
+        }
+
+        lreInterfaceConfigTable_dirty_set(0); /* clear table dirty flag */
+    }
+
+    return MFD_SUCCESS;
+} /* lreInterfaceConfigTable_post_request */
+
+
+/** @{ */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable.h
new file mode 100644
index 0000000..56680b0
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable.h
@@ -0,0 +1,286 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+#ifndef LREINTERFACECONFIGTABLE_H
+#define LREINTERFACECONFIGTABLE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/** @addtogroup misc misc: Miscellaneous routines
+ *
+ * @{
+ */
+#include <net-snmp/library/asn1.h>
+
+/* other required module components */
+    /* *INDENT-OFF*  */
+config_add_mib(IEC-62439-3-MIB)
+config_require(IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_interface)
+config_require(IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_access)
+config_require(IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_get)
+config_require(IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_set)
+    /* *INDENT-ON*  */
+
+/* OID and column number definitions for lreInterfaceConfigTable */
+#include "lreInterfaceConfigTable_oids.h"
+
+/* enum definions */
+#include "lreInterfaceConfigTable_enums.h"
+
+/* *********************************************************************
+ * function declarations
+ */
+void init_lreInterfaceConfigTable(void);
+void shutdown_lreInterfaceConfigTable(void);
+
+/* *********************************************************************
+ * Table declarations
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceConfigTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceConfigTable is subid 1 of lreConfigurationInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.0.1.0.1, length: 9
+*/
+/* *********************************************************************
+ * When you register your mib, you get to provide a generic
+ * pointer that will be passed back to you for most of the
+ * functions calls.
+ *
+ * TODO:100:r: Review all context structures
+ */
+    /*
+     * TODO:101:o: |-> Review lreInterfaceConfigTable registration context.
+     */
+typedef netsnmp_data_list lreInterfaceConfigTable_registration;
+
+/**********************************************************************/
+/*
+ * TODO:110:r: |-> Review lreInterfaceConfigTable data context structure.
+ * This structure is used to represent the data for lreInterfaceConfigTable.
+ */
+/*
+ * This structure contains storage for all the columns defined in the
+ * lreInterfaceConfigTable.
+ */
+typedef struct lreInterfaceConfigTable_data_s {
+
+        /*
+         * lreRowStatus(2)/RowStatus/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+         */
+   u_long   lreRowStatus;
+
+        /*
+         * lreNodeType(3)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+         */
+   u_long   lreNodeType;
+
+        /*
+         * lreNodeName(4)/DisplayString/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H
+         */
+   char   lreNodeName[255];
+size_t      lreNodeName_len; /* # of char elements, not bytes */
+
+        /*
+         * lreVersionName(5)/OCTETSTR/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/h
+         */
+   char   lreVersionName[32];
+size_t      lreVersionName_len; /* # of char elements, not bytes */
+
+        /*
+         * lreMacAddress(6)/MacAddress/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H
+         */
+   char   lreMacAddress[6];
+size_t      lreMacAddress_len; /* # of char elements, not bytes */
+
+        /*
+         * lrePortAdminStateA(7)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+         */
+   u_long   lrePortAdminStateA;
+
+        /*
+         * lrePortAdminStateB(8)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+         */
+   u_long   lrePortAdminStateB;
+
+        /*
+         * lreLinkStatusA(9)/INTEGER/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h
+         */
+   u_long   lreLinkStatusA;
+
+        /*
+         * lreLinkStatusB(10)/INTEGER/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h
+         */
+   u_long   lreLinkStatusB;
+
+        /*
+         * lreDuplicateDiscard(11)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+         */
+   u_long   lreDuplicateDiscard;
+
+        /*
+         * lreTransparentReception(12)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+         */
+   u_long   lreTransparentReception;
+
+        /*
+         * lreHsrLREMode(13)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+         */
+   u_long   lreHsrLREMode;
+
+        /*
+         * lreSwitchingEndNode(14)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+         */
+   u_long   lreSwitchingEndNode;
+
+        /*
+         * lreRedBoxIdentity(15)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+         */
+   u_long   lreRedBoxIdentity;
+
+        /*
+         * lreEvaluateSupervision(16)/TruthValue/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+         */
+   u_long   lreEvaluateSupervision;
+
+        /*
+         * lreNodesTableClear(17)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+         */
+   u_long   lreNodesTableClear;
+
+        /*
+         * lreProxyNodeTableClear(18)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+         */
+   u_long   lreProxyNodeTableClear;
+
+        /*
+         * lreDupListResideMaxTime(19)/SecondFraction/ASN_INTEGER/long(long)//l/A/W/e/r/D/H
+         */
+   long   lreDupListResideMaxTime;
+
+} lreInterfaceConfigTable_data;
+
+
+/* *********************************************************************
+ * TODO:115:o: |-> Review lreInterfaceConfigTable undo context.
+ * We're just going to use the same data structure for our
+ * undo_context. If you want to do something more efficent,
+ * define your typedef here.
+ */
+typedef lreInterfaceConfigTable_data lreInterfaceConfigTable_undo_data;
+
+/*
+ * TODO:120:r: |-> Review lreInterfaceConfigTable mib index.
+ * This structure is used to represent the index for lreInterfaceConfigTable.
+ */
+typedef struct lreInterfaceConfigTable_mib_index_s {
+
+        /*
+         * lreInterfaceConfigIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+         */
+   u_long   lreInterfaceConfigIndex;
+
+
+} lreInterfaceConfigTable_mib_index;
+
+    /*
+     * TODO:121:r: |   |-> Review lreInterfaceConfigTable max index length.
+     * If you KNOW that your indexes will never exceed a certain
+     * length, update this macro to that length.
+*/
+#define MAX_lreInterfaceConfigTable_IDX_LEN     1
+
+
+/* *********************************************************************
+ * TODO:130:o: |-> Review lreInterfaceConfigTable Row request (rowreq) context.
+ * When your functions are called, you will be passed a
+ * lreInterfaceConfigTable_rowreq_ctx pointer.
+ */
+typedef struct lreInterfaceConfigTable_rowreq_ctx_s {
+
+    /** this must be first for container compare to work */
+    netsnmp_index        oid_idx;
+    oid                  oid_tmp[MAX_lreInterfaceConfigTable_IDX_LEN];
+
+    lreInterfaceConfigTable_mib_index        tbl_idx;
+
+    lreInterfaceConfigTable_data              data;
+    lreInterfaceConfigTable_undo_data       * undo;
+    unsigned int                column_set_flags; /* flags for set columns */
+
+
+    /*
+     * flags per row. Currently, the first (lower) 8 bits are reserved
+     * for the user. See mfd.h for other flags.
+     */
+    u_int                       rowreq_flags;
+
+    /*
+     * TODO:131:o: |   |-> Add useful data to lreInterfaceConfigTable rowreq context.
+     */
+
+    /*
+     * storage for future expansion
+     */
+    netsnmp_data_list             *lreInterfaceConfigTable_data_list;
+
+} lreInterfaceConfigTable_rowreq_ctx;
+
+typedef struct lreInterfaceConfigTable_ref_rowreq_ctx_s {
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx;
+} lreInterfaceConfigTable_ref_rowreq_ctx;
+
+/* *********************************************************************
+ * function prototypes
+ */
+    int lreInterfaceConfigTable_pre_request(lreInterfaceConfigTable_registration * user_context);
+    int lreInterfaceConfigTable_post_request(lreInterfaceConfigTable_registration * user_context,
+        int rc);
+
+    int lreInterfaceConfigTable_rowreq_ctx_init(lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx,
+                                   void *user_init_ctx);
+    void lreInterfaceConfigTable_rowreq_ctx_cleanup(lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx);
+
+    int lreInterfaceConfigTable_check_dependencies(lreInterfaceConfigTable_rowreq_ctx * rowreq_ctx); 
+    int lreInterfaceConfigTable_commit(lreInterfaceConfigTable_rowreq_ctx * rowreq_ctx);
+
+    lreInterfaceConfigTable_rowreq_ctx *
+                  lreInterfaceConfigTable_row_find_by_mib_index(lreInterfaceConfigTable_mib_index *mib_idx);
+
+extern const oid lreInterfaceConfigTable_oid[];
+extern const int lreInterfaceConfigTable_oid_size;
+
+
+#include "lreInterfaceConfigTable_interface.h"
+#include "lreInterfaceConfigTable_data_access.h"
+#include "lreInterfaceConfigTable_data_get.h"
+#include "lreInterfaceConfigTable_data_set.h"
+
+/*
+ * DUMMY markers, ignore
+ *
+ * TODO:099:x: *************************************************************
+ * TODO:199:x: *************************************************************
+ * TODO:299:x: *************************************************************
+ * TODO:399:x: *************************************************************
+ * TODO:499:x: *************************************************************
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACECONFIGTABLE_H */
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_access.c b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_access.c
new file mode 100644
index 0000000..46ba469
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_access.c
@@ -0,0 +1,771 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreInterfaceConfigTable.h"
+
+
+#include "lreInterfaceConfigTable_data_access.h"
+
+/** @ingroup interface
+ * @addtogroup data_access data_access: Routines to access data
+ *
+ * These routines are used to locate the data used to satisfy
+ * requests.
+ *
+ * @{
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceConfigTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceConfigTable is subid 1 of lreConfigurationInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.0.1.0.1, length: 9
+*/
+
+/**
+ * initialization for lreInterfaceConfigTable data access
+ *
+ * This function is called during startup to allow you to
+ * allocate any resources you need for the data table.
+ *
+ * @param lreInterfaceConfigTable_reg
+ *        Pointer to lreInterfaceConfigTable_registration
+ *
+ * @retval MFD_SUCCESS : success.
+ * @retval MFD_ERROR   : unrecoverable error.
+ */
+int
+lreInterfaceConfigTable_init_data(lreInterfaceConfigTable_registration * lreInterfaceConfigTable_reg)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_init_data","called\n"));
+
+    /*
+     * TODO:303:o: Initialize lreInterfaceConfigTable data.
+     */
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+    /*
+     * if you are the sole writer for the file, you could
+     * open it here. However, as stated earlier, we are assuming
+     * the worst case, which in this case means that the file is
+     * written to by someone else, and might not even exist when
+     * we start up. So we can't do anything here.
+     */
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+
+    return MFD_SUCCESS;
+} /* lreInterfaceConfigTable_init_data */
+
+/**
+ * container overview
+ *
+ */
+
+/**
+ * container initialization
+ *
+ * @param container_ptr_ptr A pointer to a container pointer. If you
+ *        create a custom container, use this parameter to return it
+ *        to the MFD helper. If set to NULL, the MFD helper will
+ *        allocate a container for you.
+ * @param  cache A pointer to a cache structure. You can set the timeout
+ *         and other cache flags using this pointer.
+ *
+ *  This function is called at startup to allow you to customize certain
+ *  aspects of the access method. For the most part, it is for advanced
+ *  users. The default code should suffice for most cases. If no custom
+ *  container is allocated, the MFD code will create one for your.
+ *
+ *  This is also the place to set up cache behavior. The default, to
+ *  simply set the cache timeout, will work well with the default
+ *  container. If you are using a custom container, you may want to
+ *  look at the cache helper documentation to see if there are any
+ *  flags you want to set.
+ *
+ * @remark
+ *  This would also be a good place to do any initialization needed
+ *  for you data source. For example, opening a connection to another
+ *  process that will supply the data, opening a database, etc.
+ */
+void
+lreInterfaceConfigTable_container_init(netsnmp_container **container_ptr_ptr,
+                             netsnmp_cache *cache)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_container_init","called\n"));
+
+    if (NULL == container_ptr_ptr) {
+        snmp_log(LOG_ERR,"bad container param to lreInterfaceConfigTable_container_init\n");
+        return;
+    }
+
+    /*
+     * For advanced users, you can use a custom container. If you
+     * do not create one, one will be created for you.
+     */
+    *container_ptr_ptr = NULL;
+
+    if (NULL == cache) {
+        snmp_log(LOG_ERR,"bad cache param to lreInterfaceConfigTable_container_init\n");
+        return;
+    }
+
+    /*
+     * TODO:345:A: Set up lreInterfaceConfigTable cache properties.
+     *
+     * Also for advanced users, you can set parameters for the
+     * cache. Do not change the magic pointer, as it is used
+     * by the MFD helper. To completely disable caching, set
+     * cache->enabled to 0.
+     */
+    cache->timeout = LREINTERFACECONFIGTABLE_CACHE_TIMEOUT; /* seconds */
+} /* lreInterfaceConfigTable_container_init */
+
+/**
+ * container shutdown
+ *
+ * @param container_ptr A pointer to the container.
+ *
+ *  This function is called at shutdown to allow you to customize certain
+ *  aspects of the access method. For the most part, it is for advanced
+ *  users. The default code should suffice for most cases.
+ *
+ *  This function is called before lreInterfaceConfigTable_container_free().
+ *
+ * @remark
+ *  This would also be a good place to do any cleanup needed
+ *  for you data source. For example, closing a connection to another
+ *  process that supplied the data, closing a database, etc.
+ */
+void
+lreInterfaceConfigTable_container_shutdown(netsnmp_container *container_ptr)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_container_shutdown","called\n"));
+
+    if (NULL == container_ptr) {
+        snmp_log(LOG_ERR,"bad params to lreInterfaceConfigTable_container_shutdown\n");
+        return;
+    }
+
+} /* lreInterfaceConfigTable_container_shutdown */
+
+/**
+ * load initial data
+ *
+ * TODO:350:M: Implement lreInterfaceConfigTable data load
+ * This function will also be called by the cache helper to load
+ * the container again (after the container free function has been
+ * called to free the previous contents).
+ *
+ * @param container container to which items should be inserted
+ *
+ * @retval MFD_SUCCESS              : success.
+ * @retval MFD_RESOURCE_UNAVAILABLE : Can't access data source
+ * @retval MFD_ERROR                : other error.
+ *
+ *  This function is called to load the index(es) (and data, optionally)
+ *  for the every row in the data set.
+ *
+ * @remark
+ *  While loading the data, the only important thing is the indexes.
+ *  If access to your data is cheap/fast (e.g. you have a pointer to a
+ *  structure in memory), it would make sense to update the data here.
+ *  If, however, the accessing the data invovles more work (e.g. parsing
+ *  some other existing data, or peforming calculations to derive the data),
+ *  then you can limit yourself to setting the indexes and saving any
+ *  information you will need later. Then use the saved information in
+ *  lreInterfaceConfigTable_row_prep() for populating data.
+ *
+ * @note
+ *  If you need consistency between rows (like you want statistics
+ *  for each row to be from the same time frame), you should set all
+ *  data here.
+ *
+ */
+int
+lreInterfaceConfigTable_container_load(netsnmp_container *container)
+{
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx;
+    size_t                 count = 0;
+
+    /*
+     * temporary storage for index values
+     */
+        /*
+         * lreInterfaceConfigIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+         */
+#if TODO
+   u_long   lreInterfaceConfigIndex;
+#else
+   u_long   lreInterfaceConfigIndex = 0;
+#endif
+
+    /*
+     * this example code is based on a data source that is a
+     * text file to be read and parsed.
+     */
+    FILE *filep;
+    char line[MAX_LINE_SIZE];
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_container_load","called\n"));
+
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+    /*
+     * open our data file.
+     */
+#if TODO
+    filep = fopen("/etc/dummy.conf", "r");
+    if(NULL ==  filep) {
+        return MFD_RESOURCE_UNAVAILABLE;
+    }
+#endif
+
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+    /*
+     * TODO:351:M: |-> Load/update data in the lreInterfaceConfigTable container.
+     * loop over your lreInterfaceConfigTable data, allocate a rowreq context,
+     * set the index(es) [and data, optionally] and insert into
+     * the container.
+     */
+#if TODO
+    while( 1 ) {
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+    /*
+     * get a line (skip blank lines)
+     */
+
+    do {
+        if (!fgets(line, sizeof(line), filep)) {
+            /* we're done */
+            fclose(filep);
+            filep = NULL;
+        }
+    } while (filep && (line[0] == '\n'));
+
+    /*
+     * check for end of data
+     */
+    if(NULL == filep)
+        break;
+#else
+    filep = NULL;
+#endif
+
+    /*
+     * parse line into variables
+     */
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+
+        /*
+         * TODO:352:M: |   |-> set indexes in new lreInterfaceConfigTable rowreq context.
+         * data context will be set from the param (unless NULL,
+         *      in which case a new data context will be allocated)
+         */
+        rowreq_ctx = lreInterfaceConfigTable_allocate_rowreq_ctx(NULL);
+        if (NULL == rowreq_ctx) {
+            snmp_log(LOG_ERR, "memory allocation failed\n");
+            return MFD_RESOURCE_UNAVAILABLE;
+        }
+        if(MFD_SUCCESS != lreInterfaceConfigTable_indexes_set(rowreq_ctx
+                               , lreInterfaceConfigIndex
+               )) {
+            snmp_log(LOG_ERR,"error setting index while loading "
+                     "lreInterfaceConfigTable data.\n");
+            lreInterfaceConfigTable_release_rowreq_ctx(rowreq_ctx);
+#if TODO
+            continue;
+#endif
+        }
+
+        /*
+         * TODO:352:r: |   |-> populate lreInterfaceConfigTable data context.
+         * Populate data context here. (optionally, delay until row prep)
+         */
+    /*
+     * TRANSIENT or semi-TRANSIENT data:
+     * copy data or save any info needed to do it in row_prep.
+     */
+    /*
+     * setup/save data for lreRowStatus
+     * lreRowStatus(2)/RowStatus/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+     */
+    /** no mapping */
+
+#if TODO
+    rowreq_ctx->data.lreRowStatus = lreRowStatus;
+#else
+    rowreq_ctx->data.lreRowStatus = 1;
+#endif
+
+    /*
+     * setup/save data for lreNodeType
+     * lreNodeType(3)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lreNodeType = lreNodeType;
+#else
+    rowreq_ctx->data.lreNodeType = 1;
+#endif
+
+    /*
+     * setup/save data for lreNodeName
+     * lreNodeName(4)/DisplayString/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H
+     */
+    /** no mapping */
+    /*
+     * make sure there is enough space for lreNodeName data
+     */
+#if TODO
+    if ((NULL == rowreq_ctx->data.lreNodeName) ||
+        (rowreq_ctx->data.lreNodeName_len <
+         (lreNodeName_len* sizeof(lreNodeName[0])))) {
+        snmp_log(LOG_ERR,"not enough space for value (lreNodeName)\n");
+        return MFD_ERROR;
+    }
+    rowreq_ctx->data.lreNodeName_len = lreNodeName_len* sizeof(lreNodeName[0]);
+    memcpy( rowreq_ctx->data.lreNodeName, lreNodeName, lreNodeName_len* sizeof(lreNodeName[0]) );
+#else
+    rowreq_ctx->data.lreNodeName[0] = 'h';
+    rowreq_ctx->data.lreNodeName[1] = 's';
+    rowreq_ctx->data.lreNodeName[2] = 'r';
+    rowreq_ctx->data.lreNodeName[3] = '0';
+    rowreq_ctx->data.lreNodeName[4] = '\0';
+    rowreq_ctx->data.lreNodeName_len = 4;
+#endif
+
+    /*
+     * setup/save data for lreVersionName
+     * lreVersionName(5)/OCTETSTR/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/h
+     */
+    /** no mapping */
+    /*
+     * make sure there is enough space for lreVersionName data
+     */
+#if TODO
+    if ((NULL == rowreq_ctx->data.lreVersionName) ||
+        (rowreq_ctx->data.lreVersionName_len <
+         (lreVersionName_len* sizeof(lreVersionName[0])))) {
+        snmp_log(LOG_ERR,"not enough space for value (lreVersionName)\n");
+        return MFD_ERROR;
+    }
+    rowreq_ctx->data.lreVersionName_len = lreVersionName_len* sizeof(lreVersionName[0]);
+    memcpy( rowreq_ctx->data.lreVersionName, lreVersionName, lreVersionName_len* sizeof(lreVersionName[0]) );
+#else
+    rowreq_ctx->data.lreVersionName[0] = 'v';
+    rowreq_ctx->data.lreVersionName[1] = 'e';
+    rowreq_ctx->data.lreVersionName[2] = 'r';
+    rowreq_ctx->data.lreVersionName[3] = '1';
+    rowreq_ctx->data.lreVersionName[4] = '\0';
+    rowreq_ctx->data.lreVersionName_len = 4;
+#endif
+
+    /*
+     * setup/save data for lreMacAddress
+     * lreMacAddress(6)/MacAddress/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H
+     */
+    /** no mapping */
+    /*
+     * make sure there is enough space for lreMacAddress data
+     */
+#if TODO
+    if ((NULL == rowreq_ctx->data.lreMacAddress) ||
+        (rowreq_ctx->data.lreMacAddress_len <
+         (lreMacAddress_len* sizeof(lreMacAddress[0])))) {
+        snmp_log(LOG_ERR,"not enough space for value (lreMacAddress)\n");
+        return MFD_ERROR;
+    }
+    rowreq_ctx->data.lreMacAddress_len = lreMacAddress_len* sizeof(lreMacAddress[0]);
+    memcpy( rowreq_ctx->data.lreMacAddress, lreMacAddress, lreMacAddress_len* sizeof(lreMacAddress[0]) );
+#else
+    rowreq_ctx->data.lreMacAddress[0] = 1;
+    rowreq_ctx->data.lreMacAddress[1] = 2;
+    rowreq_ctx->data.lreMacAddress[2] = 3;
+    rowreq_ctx->data.lreMacAddress[3] = 4;
+    rowreq_ctx->data.lreMacAddress[4] = 5;
+    rowreq_ctx->data.lreMacAddress[5] = 6;
+    rowreq_ctx->data.lreMacAddress_len = 6;
+#endif
+
+    /*
+     * setup/save data for lrePortAdminStateA
+     * lrePortAdminStateA(7)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lrePortAdminStateA = lrePortAdminStateA;
+#else
+    rowreq_ctx->data.lrePortAdminStateA = 0;
+#endif
+
+    /*
+     * setup/save data for lrePortAdminStateB
+     * lrePortAdminStateB(8)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lrePortAdminStateB = lrePortAdminStateB;
+#else
+    rowreq_ctx->data.lrePortAdminStateB = 1;
+#endif
+
+    /*
+     * setup/save data for lreLinkStatusA
+     * lreLinkStatusA(9)/INTEGER/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lreLinkStatusA = lreLinkStatusA;
+#else
+    rowreq_ctx->data.lreLinkStatusA = 0;
+#endif
+
+    /*
+     * setup/save data for lreLinkStatusB
+     * lreLinkStatusB(10)/INTEGER/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lreLinkStatusB = lreLinkStatusB;
+#else
+    rowreq_ctx->data.lreLinkStatusB = 1;
+#endif
+
+    /*
+     * setup/save data for lreDuplicateDiscard
+     * lreDuplicateDiscard(11)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lreDuplicateDiscard = lreDuplicateDiscard;
+#else
+    rowreq_ctx->data.lreDuplicateDiscard = 2;
+#endif
+
+    /*
+     * setup/save data for lreTransparentReception
+     * lreTransparentReception(12)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lreTransparentReception = lreTransparentReception;
+#else
+    rowreq_ctx->data.lreTransparentReception = 1;
+#endif
+
+    /*
+     * setup/save data for lreHsrLREMode
+     * lreHsrLREMode(13)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lreHsrLREMode = lreHsrLREMode;
+#else
+    rowreq_ctx->data.lreHsrLREMode = 1;
+#endif
+    /*
+     * setup/save data for lreSwitchingEndNode
+     * lreSwitchingEndNode(14)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lreSwitchingEndNode = lreSwitchingEndNode;
+#else
+    rowreq_ctx->data.lreSwitchingEndNode = 2;
+#endif
+
+    /*
+     * setup/save data for lreRedBoxIdentity
+     * lreRedBoxIdentity(15)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lreRedBoxIdentity = lreRedBoxIdentity;
+#else
+    rowreq_ctx->data.lreRedBoxIdentity = 1;
+#endif
+
+    /*
+     * setup/save data for lreEvaluateSupervision
+     * lreEvaluateSupervision(16)/TruthValue/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lreEvaluateSupervision = lreEvaluateSupervision;
+#else
+    rowreq_ctx->data.lreEvaluateSupervision = 2;
+#endif
+
+    /*
+     * setup/save data for lreNodesTableClear
+     * lreNodesTableClear(17)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lreNodesTableClear = lreNodesTableClear;
+#else
+    rowreq_ctx->data.lreNodesTableClear = 1;
+#endif
+
+    /*
+     * setup/save data for lreProxyNodeTableClear
+     * lreProxyNodeTableClear(18)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lreProxyNodeTableClear = lreProxyNodeTableClear;
+#endif
+
+    /*
+     * setup/save data for lreDupListResideMaxTime
+     * lreDupListResideMaxTime(19)/SecondFraction/ASN_INTEGER/long(long)//l/A/W/e/r/D/H
+     */
+    /** no mapping */
+#if TODO
+    rowreq_ctx->data.lreDupListResideMaxTime = lreDupListResideMaxTime;
+#else
+    rowreq_ctx->data.lreDupListResideMaxTime = 500;
+#endif
+
+        /*
+         * insert into table container
+         */
+        CONTAINER_INSERT(container, rowreq_ctx);
+        ++count;
+#if TODO
+    }
+#endif
+
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+    if(NULL != filep)
+        fclose(filep);
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+
+    DEBUGMSGT(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_container_load",
+               "inserted %d records\n", count));
+
+    return MFD_SUCCESS;
+} /* lreInterfaceConfigTable_container_load */
+
+/**
+ * container clean up
+ *
+ * @param container container with all current items
+ *
+ *  This optional callback is called prior to all
+ *  item's being removed from the container. If you
+ *  need to do any processing before that, do it here.
+ *
+ * @note
+ *  The MFD helper will take care of releasing all the row contexts.
+ *
+ */
+void
+lreInterfaceConfigTable_container_free(netsnmp_container *container)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_container_free","called\n"));
+
+    /*
+     * TODO:380:M: Free lreInterfaceConfigTable container data.
+     */
+} /* lreInterfaceConfigTable_container_free */
+
+/**
+ * prepare row for processing.
+ *
+ *  When the agent has located the row for a request, this function is
+ *  called to prepare the row for processing. If you fully populated
+ *  the data context during the index setup phase, you may not need to
+ *  do anything.
+ *
+ * @param rowreq_ctx pointer to a context.
+ *
+ * @retval MFD_SUCCESS     : success.
+ * @retval MFD_ERROR       : other error.
+ */
+int
+lreInterfaceConfigTable_row_prep( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_row_prep","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:390:o: Prepare row for request.
+     * If populating row data was delayed, this is the place to
+     * fill in the row for this request.
+     */
+
+    return MFD_SUCCESS;
+} /* lreInterfaceConfigTable_row_prep */
+
+/*
+ * TODO:420:r: Implement lreInterfaceConfigTable index validation.
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreInterfaceConfigIndex
+ * lreInterfaceConfigIndex is subid 1 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is NoAccess.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.1
+ * Description:
+A unique value for each LRE.
+ *
+ * Attributes:
+ *   accessible 0     isscalar 0     enums  0      hasdefval 0
+ *   readable   0     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
+ * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
+ *
+ *
+ *
+ * NOTE: NODE lreInterfaceConfigIndex IS NOT ACCESSIBLE
+ *
+ *
+ */
+/**
+ * check validity of lreInterfaceConfigIndex index portion
+ *
+ * @retval MFD_SUCCESS   : the incoming value is legal
+ * @retval MFD_ERROR     : the incoming value is NOT legal
+ *
+ * @note this is not the place to do any checks for the sanity
+ *       of multiple indexes. Those types of checks should be done in the
+ *       lreInterfaceConfigTable_validate_index() function.
+ *
+ * @note Also keep in mind that if the index refers to a row in this or
+ *       some other table, you can't check for that row here to make
+ *       decisions, since that row might not be created yet, but may
+ *       be created during the processing this request. If you have
+ *       such checks, they should be done in the check_dependencies
+ *       function, because any new/deleted/changed rows should be
+ *       available then.
+ *
+ * The following checks have already been done for you:
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ */
+int
+lreInterfaceConfigIndex_check_index( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx )
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigIndex_check_index","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:426:M: |-> Check lreInterfaceConfigTable index lreInterfaceConfigIndex.
+     * check that index value in the table context is legal.
+     * (rowreq_ctx->tbl_idx.lreInterfaceConfigIndex)
+     */
+    if (rowreq_ctx->tbl_idx.lreInterfaceConfigIndex > 0)
+	    return MFD_ERROR;
+
+    return MFD_SUCCESS; /* lreInterfaceConfigIndex index ok */
+} /* lreInterfaceConfigIndex_check_index */
+
+/**
+ * verify specified index is valid.
+ *
+ * This check is independent of whether or not the values specified for
+ * the columns of the new row are valid. Column values and row consistency
+ * will be checked later. At this point, only the index values should be
+ * checked.
+ *
+ * All of the individual index validation functions have been called, so this
+ * is the place to make sure they are valid as a whole when combined. If
+ * you only have one index, then you probably don't need to do anything else
+ * here.
+ *
+ * @note Keep in mind that if the indexes refer to a row in this or
+ *       some other table, you can't check for that row here to make
+ *       decisions, since that row might not be created yet, but may
+ *       be created during the processing this request. If you have
+ *       such checks, they should be done in the check_dependencies
+ *       function, because any new/deleted/changed rows should be
+ *       available then.
+ *
+ *
+ * @param lreInterfaceConfigTable_reg
+ *        Pointer to the user registration data
+ * @param lreInterfaceConfigTable_rowreq_ctx
+ *        Pointer to the users context.
+ * @retval MFD_SUCCESS            : success
+ * @retval MFD_CANNOT_CREATE_NOW  : index not valid right now
+ * @retval MFD_CANNOT_CREATE_EVER : index never valid
+ */
+int
+lreInterfaceConfigTable_validate_index( lreInterfaceConfigTable_registration * lreInterfaceConfigTable_reg,
+                           lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    int rc = MFD_SUCCESS;
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_validate_index","called\n"));
+
+    /** we should have a non-NULL pointer */
+    netsnmp_assert( NULL != rowreq_ctx );
+
+    /*
+     * TODO:430:M: |-> Validate potential lreInterfaceConfigTable index.
+     */
+    if(1) {
+        snmp_log(LOG_WARNING,"invalid index for a new row in the "
+                 "lreInterfaceConfigTable table.\n");
+        /*
+         * determine failure type.
+         *
+         * If the index could not ever be created, return MFD_NOT_EVER
+         * If the index can not be created under the present circumstances
+         * (even though it could be created under other circumstances),
+         * return MFD_NOT_NOW.
+         */
+        if(0) {
+            return MFD_CANNOT_CREATE_EVER;
+        }
+        else {
+            return MFD_CANNOT_CREATE_NOW;
+        }
+    }
+
+    return rc;
+} /* lreInterfaceConfigTable_validate_index */
+
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_access.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_access.h
new file mode 100644
index 0000000..ffa37e3
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_access.h
@@ -0,0 +1,79 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+#ifndef LREINTERFACECONFIGTABLE_DATA_ACCESS_H
+#define LREINTERFACECONFIGTABLE_DATA_ACCESS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* *********************************************************************
+ * function declarations
+ */
+
+/* *********************************************************************
+ * Table declarations
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceConfigTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceConfigTable is subid 1 of lreConfigurationInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.0.1.0.1, length: 9
+*/
+
+
+    int lreInterfaceConfigTable_init_data(lreInterfaceConfigTable_registration * lreInterfaceConfigTable_reg);
+
+
+    /*
+     * TODO:180:o: Review lreInterfaceConfigTable cache timeout.
+     * The number of seconds before the cache times out
+     */
+#define LREINTERFACECONFIGTABLE_CACHE_TIMEOUT   60
+
+void lreInterfaceConfigTable_container_init(netsnmp_container **container_ptr_ptr,
+                             netsnmp_cache *cache);
+void lreInterfaceConfigTable_container_shutdown(netsnmp_container *container_ptr);
+
+int lreInterfaceConfigTable_container_load(netsnmp_container *container);
+void lreInterfaceConfigTable_container_free(netsnmp_container *container);
+
+int lreInterfaceConfigTable_cache_load(netsnmp_container *container);
+void lreInterfaceConfigTable_cache_free(netsnmp_container *container);
+
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+/* *********************************************************************
+ * Since we have no idea how you really access your data, we'll go with
+ * a worst case example: a flat text file.
+ */
+#define MAX_LINE_SIZE 256
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+    int lreInterfaceConfigTable_row_prep( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx);
+
+int lreInterfaceConfigTable_validate_index( lreInterfaceConfigTable_registration * lreInterfaceConfigTable_reg,
+                               lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx);
+int lreInterfaceConfigIndex_check_index( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx ); /* internal */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACECONFIGTABLE_DATA_ACCESS_H */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_get.c b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_get.c
new file mode 100644
index 0000000..49cffd1
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_get.c
@@ -0,0 +1,1209 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreInterfaceConfigTable.h"
+
+
+/** @defgroup data_get data_get: Routines to get data
+ *
+ * TODO:230:M: Implement lreInterfaceConfigTable get routines.
+ * TODO:240:M: Implement lreInterfaceConfigTable mapping routines (if any).
+ *
+ * These routine are used to get the value for individual objects. The
+ * row context is passed, along with a pointer to the memory where the
+ * value should be copied.
+ *
+ * @{
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceConfigTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceConfigTable is subid 1 of lreConfigurationInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.0.1.0.1, length: 9
+*/
+
+/* ---------------------------------------------------------------------
+ * TODO:200:r: Implement lreInterfaceConfigTable data context functions.
+ */
+
+
+/**
+ * set mib index(es)
+ *
+ * @param tbl_idx mib index structure
+ * @param lreInterfaceConfigIndex_val
+ *
+ * @retval MFD_SUCCESS     : success.
+ * @retval MFD_ERROR       : other error.
+ *
+ * @remark
+ *  This convenience function is useful for setting all the MIB index
+ *  components with a single function call. It is assume that the C values
+ *  have already been mapped from their native/rawformat to the MIB format.
+ */
+int
+lreInterfaceConfigTable_indexes_set_tbl_idx(lreInterfaceConfigTable_mib_index *tbl_idx, u_long lreInterfaceConfigIndex_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_indexes_set_tbl_idx","called\n"));
+
+    /* lreInterfaceConfigIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h */
+    tbl_idx->lreInterfaceConfigIndex = lreInterfaceConfigIndex_val;
+
+
+    return MFD_SUCCESS;
+} /* lreInterfaceConfigTable_indexes_set_tbl_idx */
+
+/**
+ * @internal
+ * set row context indexes
+ *
+ * @param reqreq_ctx the row context that needs updated indexes
+ *
+ * @retval MFD_SUCCESS     : success.
+ * @retval MFD_ERROR       : other error.
+ *
+ * @remark
+ *  This function sets the mib indexs, then updates the oid indexs
+ *  from the mib index.
+ */
+int
+lreInterfaceConfigTable_indexes_set(lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreInterfaceConfigIndex_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_indexes_set","called\n"));
+
+    if(MFD_SUCCESS != lreInterfaceConfigTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
+                                   , lreInterfaceConfigIndex_val
+           ))
+        return MFD_ERROR;
+
+    /*
+     * convert mib index to oid index
+     */
+    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
+    if(0 != lreInterfaceConfigTable_index_to_oid(&rowreq_ctx->oid_idx,
+                                    &rowreq_ctx->tbl_idx)) {
+        return MFD_ERROR;
+    }
+
+    return MFD_SUCCESS;
+} /* lreInterfaceConfigTable_indexes_set */
+
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreRowStatus
+ * lreRowStatus is subid 2 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is Create.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.2
+ * Description:
+indicates the status of the LRE table entry
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 6/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
+ *
+ * Its syntax is RowStatus (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lreRowStatus data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreRowStatus_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreRowStatus_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreRowStatus_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreRowStatus_val_ptr );
+
+    (* lreRowStatus_val_ptr ) = rowreq_ctx->data.lreRowStatus;
+
+    return MFD_SUCCESS;
+} /* lreRowStatus_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreNodeType
+ * lreNodeType is subid 3 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.3
+ * Description:
+
+                specifies the operation mode of the LRE:
+                PRP mode 1 (1)
+                HSR mode (2)
+                Note: PRP mode 0 is considered deprecated and is not supported by this
+                revision of the MIB
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  prpmode1(1), hsr(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lreNodeType data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreNodeType_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreNodeType_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreNodeType_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreNodeType_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodeType_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreNodeType data.
+ * copy (* lreNodeType_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreNodeType_val_ptr ) = rowreq_ctx->data.lreNodeType;
+
+    return MFD_SUCCESS;
+} /* lreNodeType_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreNodeName
+ * lreNodeName is subid 4 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.4
+ * Description:
+specifies this LRE's node name
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 1      hashint   1
+ *   settable   1
+ *   hint: 255a
+ *
+ * Ranges:  0 - 255;
+ *
+ * Its syntax is DisplayString (based on perltype OCTETSTR)
+ * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
+ * This data type requires a length.  (Max 255)
+ */
+/**
+ * Extract the current value of the lreNodeName data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreNodeName_val_ptr_ptr
+ *        Pointer to storage for a char variable
+ * @param lreNodeName_val_ptr_len_ptr
+ *        Pointer to a size_t. On entry, it will contain the size (in bytes)
+ *        pointed to by lreNodeName.
+ *        On exit, this value should contain the data size (in bytes).
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+*
+ * @note If you need more than (*lreNodeName_val_ptr_len_ptr) bytes of memory,
+ *       allocate it using malloc() and update lreNodeName_val_ptr_ptr.
+ *       <b>DO NOT</b> free the previous pointer.
+ *       The MFD helper will release the memory you allocate.
+ *
+ * @remark If you call this function yourself, you are responsible
+ *         for checking if the pointer changed, and freeing any
+ *         previously allocated memory. (Not necessary if you pass
+ *         in a pointer to static memory, obviously.)
+ */
+int
+lreNodeName_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char **lreNodeName_val_ptr_ptr, size_t *lreNodeName_val_ptr_len_ptr )
+{
+   /** we should have a non-NULL pointer and enough storage */
+   netsnmp_assert( (NULL != lreNodeName_val_ptr_ptr) && (NULL != *lreNodeName_val_ptr_ptr));
+   netsnmp_assert( NULL != lreNodeName_val_ptr_len_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodeName_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreNodeName data.
+ * copy (* lreNodeName_val_ptr_ptr ) data and (* lreNodeName_val_ptr_len_ptr ) from rowreq_ctx->data
+ */
+    /*
+     * make sure there is enough space for lreNodeName data
+     */
+    if ((NULL == (* lreNodeName_val_ptr_ptr )) ||
+        ((* lreNodeName_val_ptr_len_ptr ) <
+         (rowreq_ctx->data.lreNodeName_len* sizeof(rowreq_ctx->data.lreNodeName[0])))) {
+        /*
+         * allocate space for lreNodeName data
+         */
+        (* lreNodeName_val_ptr_ptr ) = malloc(rowreq_ctx->data.lreNodeName_len* sizeof(rowreq_ctx->data.lreNodeName[0]));
+        if(NULL == (* lreNodeName_val_ptr_ptr )) {
+            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.lreNodeName)\n");
+            return MFD_ERROR;
+        }
+    }
+    (* lreNodeName_val_ptr_len_ptr ) = rowreq_ctx->data.lreNodeName_len* sizeof(rowreq_ctx->data.lreNodeName[0]);
+    memcpy( (* lreNodeName_val_ptr_ptr ), rowreq_ctx->data.lreNodeName, rowreq_ctx->data.lreNodeName_len* sizeof(rowreq_ctx->data.lreNodeName[0]) );
+
+    return MFD_SUCCESS;
+} /* lreNodeName_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreVersionName
+ * lreVersionName is subid 5 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.5
+ * Description:
+specifies the version of this LRE's software
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 1      hashint   0
+ *   settable   0
+ *
+ * Ranges:  1 - 32;
+ *
+ * Its syntax is OCTETSTR (based on perltype OCTETSTR)
+ * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
+ * This data type requires a length.  (Max 32)
+ */
+/**
+ * Extract the current value of the lreVersionName data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreVersionName_val_ptr_ptr
+ *        Pointer to storage for a char variable
+ * @param lreVersionName_val_ptr_len_ptr
+ *        Pointer to a size_t. On entry, it will contain the size (in bytes)
+ *        pointed to by lreVersionName.
+ *        On exit, this value should contain the data size (in bytes).
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+*
+ * @note If you need more than (*lreVersionName_val_ptr_len_ptr) bytes of memory,
+ *       allocate it using malloc() and update lreVersionName_val_ptr_ptr.
+ *       <b>DO NOT</b> free the previous pointer.
+ *       The MFD helper will release the memory you allocate.
+ *
+ * @remark If you call this function yourself, you are responsible
+ *         for checking if the pointer changed, and freeing any
+ *         previously allocated memory. (Not necessary if you pass
+ *         in a pointer to static memory, obviously.)
+ */
+int
+lreVersionName_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char **lreVersionName_val_ptr_ptr, size_t *lreVersionName_val_ptr_len_ptr )
+{
+   /** we should have a non-NULL pointer and enough storage */
+   netsnmp_assert( (NULL != lreVersionName_val_ptr_ptr) && (NULL != *lreVersionName_val_ptr_ptr));
+   netsnmp_assert( NULL != lreVersionName_val_ptr_len_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreVersionName_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreVersionName data.
+ * copy (* lreVersionName_val_ptr_ptr ) data and (* lreVersionName_val_ptr_len_ptr ) from rowreq_ctx->data
+ */
+    /*
+     * make sure there is enough space for lreVersionName data
+     */
+    if ((NULL == (* lreVersionName_val_ptr_ptr )) ||
+        ((* lreVersionName_val_ptr_len_ptr ) <
+         (rowreq_ctx->data.lreVersionName_len* sizeof(rowreq_ctx->data.lreVersionName[0])))) {
+        /*
+         * allocate space for lreVersionName data
+         */
+        (* lreVersionName_val_ptr_ptr ) = malloc(rowreq_ctx->data.lreVersionName_len* sizeof(rowreq_ctx->data.lreVersionName[0]));
+        if(NULL == (* lreVersionName_val_ptr_ptr )) {
+            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.lreVersionName)\n");
+            return MFD_ERROR;
+        }
+    }
+    (* lreVersionName_val_ptr_len_ptr ) = rowreq_ctx->data.lreVersionName_len* sizeof(rowreq_ctx->data.lreVersionName[0]);
+    memcpy( (* lreVersionName_val_ptr_ptr ), rowreq_ctx->data.lreVersionName, rowreq_ctx->data.lreVersionName_len* sizeof(rowreq_ctx->data.lreVersionName[0]) );
+
+    return MFD_SUCCESS;
+} /* lreVersionName_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreMacAddress
+ * lreMacAddress is subid 6 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.6
+ * Description:
+
+                Specifies the MAC address to be used by this LRE. MAC
+                addresses are
+                identical for all ports of a single LRE
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 1      hashint   1
+ *   settable   1
+ *   hint: 1x:
+ *
+ * Ranges:  6;
+ *
+ * Its syntax is MacAddress (based on perltype OCTETSTR)
+ * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
+ * This data type requires a length.  (Max 6)
+ */
+/**
+ * Extract the current value of the lreMacAddress data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreMacAddress_val_ptr_ptr
+ *        Pointer to storage for a char variable
+ * @param lreMacAddress_val_ptr_len_ptr
+ *        Pointer to a size_t. On entry, it will contain the size (in bytes)
+ *        pointed to by lreMacAddress.
+ *        On exit, this value should contain the data size (in bytes).
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+*
+ * @note If you need more than (*lreMacAddress_val_ptr_len_ptr) bytes of memory,
+ *       allocate it using malloc() and update lreMacAddress_val_ptr_ptr.
+ *       <b>DO NOT</b> free the previous pointer.
+ *       The MFD helper will release the memory you allocate.
+ *
+ * @remark If you call this function yourself, you are responsible
+ *         for checking if the pointer changed, and freeing any
+ *         previously allocated memory. (Not necessary if you pass
+ *         in a pointer to static memory, obviously.)
+ */
+int
+lreMacAddress_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char **lreMacAddress_val_ptr_ptr, size_t *lreMacAddress_val_ptr_len_ptr )
+{
+   /** we should have a non-NULL pointer and enough storage */
+   netsnmp_assert( (NULL != lreMacAddress_val_ptr_ptr) && (NULL != *lreMacAddress_val_ptr_ptr));
+   netsnmp_assert( NULL != lreMacAddress_val_ptr_len_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreMacAddress_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreMacAddress data.
+ * copy (* lreMacAddress_val_ptr_ptr ) data and (* lreMacAddress_val_ptr_len_ptr ) from rowreq_ctx->data
+ */
+    /*
+     * make sure there is enough space for lreMacAddress data
+     */
+    if ((NULL == (* lreMacAddress_val_ptr_ptr )) ||
+        ((* lreMacAddress_val_ptr_len_ptr ) <
+         (rowreq_ctx->data.lreMacAddress_len* sizeof(rowreq_ctx->data.lreMacAddress[0])))) {
+        /*
+         * allocate space for lreMacAddress data
+         */
+        (* lreMacAddress_val_ptr_ptr ) = malloc(rowreq_ctx->data.lreMacAddress_len* sizeof(rowreq_ctx->data.lreMacAddress[0]));
+        if(NULL == (* lreMacAddress_val_ptr_ptr )) {
+            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.lreMacAddress)\n");
+            return MFD_ERROR;
+        }
+    }
+    (* lreMacAddress_val_ptr_len_ptr ) = rowreq_ctx->data.lreMacAddress_len* sizeof(rowreq_ctx->data.lreMacAddress[0]);
+    memcpy( (* lreMacAddress_val_ptr_ptr ), rowreq_ctx->data.lreMacAddress, rowreq_ctx->data.lreMacAddress_len* sizeof(rowreq_ctx->data.lreMacAddress[0]) );
+
+    return MFD_SUCCESS;
+} /* lreMacAddress_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lrePortAdminStateA
+ * lrePortAdminStateA is subid 7 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.7
+ * Description:
+
+                Specifies whether the port A shall be active or not Active
+                through
+                administrative action (Default: active).
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  notActive(1), active(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lrePortAdminStateA data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lrePortAdminStateA_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lrePortAdminStateA_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lrePortAdminStateA_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lrePortAdminStateA_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lrePortAdminStateA_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lrePortAdminStateA data.
+ * copy (* lrePortAdminStateA_val_ptr ) from rowreq_ctx->data
+ */
+    (* lrePortAdminStateA_val_ptr ) = rowreq_ctx->data.lrePortAdminStateA;
+
+    return MFD_SUCCESS;
+} /* lrePortAdminStateA_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lrePortAdminStateB
+ * lrePortAdminStateB is subid 8 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.8
+ * Description:
+
+                Specifies whether the port B shall be active or not Active
+                through
+                administrative action (Default: active).
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  notActive(1), active(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lrePortAdminStateB data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lrePortAdminStateB_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lrePortAdminStateB_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lrePortAdminStateB_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lrePortAdminStateB_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lrePortAdminStateB_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lrePortAdminStateB data.
+ * copy (* lrePortAdminStateB_val_ptr ) from rowreq_ctx->data
+ */
+    (* lrePortAdminStateB_val_ptr ) = rowreq_ctx->data.lrePortAdminStateB;
+
+    return MFD_SUCCESS;
+} /* lrePortAdminStateB_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreLinkStatusA
+ * lreLinkStatusA is subid 9 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.9
+ * Description:
+shows the actual link status of the LRE's port A
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ * Enum range: 2/8. Values:  up(1), down(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lreLinkStatusA data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreLinkStatusA_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreLinkStatusA_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreLinkStatusA_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreLinkStatusA_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreLinkStatusA_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreLinkStatusA data.
+ * copy (* lreLinkStatusA_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreLinkStatusA_val_ptr ) = rowreq_ctx->data.lreLinkStatusA;
+
+    return MFD_SUCCESS;
+} /* lreLinkStatusA_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreLinkStatusB
+ * lreLinkStatusB is subid 10 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.10
+ * Description:
+shows the actual link status of the LRE's port B
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ * Enum range: 2/8. Values:  up(1), down(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lreLinkStatusB data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreLinkStatusB_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreLinkStatusB_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreLinkStatusB_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreLinkStatusB_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreLinkStatusB_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreLinkStatusB data.
+ * copy (* lreLinkStatusB_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreLinkStatusB_val_ptr ) = rowreq_ctx->data.lreLinkStatusB;
+
+    return MFD_SUCCESS;
+} /* lreLinkStatusB_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreDuplicateDiscard
+ * lreDuplicateDiscard is subid 11 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.11
+ * Description:
+
+                specifies whether a duplicate discard algorithm is used at
+                reception
+                (Default: discard).
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  doNotDiscard(1), discard(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lreDuplicateDiscard data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreDuplicateDiscard_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreDuplicateDiscard_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreDuplicateDiscard_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreDuplicateDiscard_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreDuplicateDiscard_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreDuplicateDiscard data.
+ * copy (* lreDuplicateDiscard_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreDuplicateDiscard_val_ptr ) = rowreq_ctx->data.lreDuplicateDiscard;
+
+    return MFD_SUCCESS;
+} /* lreDuplicateDiscard_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreTransparentReception
+ * lreTransparentReception is subid 12 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.12
+ * Description:
+
+                if removeRCT is configured, the RCT is removed when
+                forwarding to the upper
+                layers, only applicable for PRP LRE (Default: removeRCT).
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  removeRCT(1), passRCT(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lreTransparentReception data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreTransparentReception_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreTransparentReception_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreTransparentReception_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreTransparentReception_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreTransparentReception_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreTransparentReception data.
+ * copy (* lreTransparentReception_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreTransparentReception_val_ptr ) = rowreq_ctx->data.lreTransparentReception;
+
+    return MFD_SUCCESS;
+} /* lreTransparentReception_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreHsrLREMode
+ * lreHsrLREMode is subid 13 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.13
+ * Description:
+
+                This enumeration is only applicable if the LRE is an HSR
+                bridging node or RedBox.
+                It shows the mode of the HSR LRE:
+                (1) Default mode: The HSR LRE is in mode h and bridges tagged HSR traffic
+                (2) Optional mode: The HSR LRE is in mode n and bridging between its HSR ports
+                Is disabled.
+                Traffic is HSR tagged.
+                (3) Optional mode: The HSR LRE is in mode t and bridges non-tagged HSR traffic
+                between its HSR ports
+                (4) Optional mode: The HSR LRE is in mode u and behaves like in mode h, except it
+                does not remove unicast messages
+                (5) Optional mode: The HSR LRE is configured in mixed mode. HSR frames are handled
+                according to mode h. Non-HSR frames are handled according to
+                802.1D bridging rules.
+                (6) Optional mode: The HSR LRE is in mode x and behaves like in mode h, except it
+                does not send a frame that is a duplicate of a frame that is received completely
+                and correctly from the opposite direction
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 4/8. Values:  modeh(1), moden(2), modet(3), modeu(4), modem(5), modex(6)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lreHsrLREMode data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreHsrLREMode_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreHsrLREMode_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreHsrLREMode_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreHsrLREMode_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreHsrLREMode_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreHsrLREMode data.
+ * copy (* lreHsrLREMode_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreHsrLREMode_val_ptr ) = rowreq_ctx->data.lreHsrLREMode;
+
+    return MFD_SUCCESS;
+} /* lreHsrLREMode_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreSwitchingEndNode
+ * lreSwitchingEndNode is subid 14 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.14
+ * Description:
+
+                This enumeration shows which feature is enabled in this
+                particular LRE:
+                (1): an unspecified non-bridging node, e.g. SRP.
+                (2): an unspecified bridging node, e.g. RSTP.
+                (3): a PRP node/RedBox.
+                (4): an HSR RedBox with regular Ethernet traffic on its interlink.
+                (5): an HSR switching node.
+                (6): an HSR RedBox with HSR tagged traffic on its interlink.
+                (7): an HSR RedBox with PRP traffic for LAN A on its interlink.
+                (8): an HSR RedBox with PRP traffic for LAN B on its interlink.
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 5/16. Values:  nonbridgingnode(1), bridgingunspecified(2), prpnode(3), hsrredboxsan(4), hsrnode(5), hsrredboxhsr(6), hsrredboxprpa(7), hsrredboxprpb(8)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lreSwitchingEndNode data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreSwitchingEndNode_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreSwitchingEndNode_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreSwitchingEndNode_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreSwitchingEndNode_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreSwitchingEndNode_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreSwitchingEndNode data.
+ * copy (* lreSwitchingEndNode_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreSwitchingEndNode_val_ptr ) = rowreq_ctx->data.lreSwitchingEndNode;
+
+    return MFD_SUCCESS;
+} /* lreSwitchingEndNode_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreRedBoxIdentity
+ * lreRedBoxIdentity is subid 15 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.15
+ * Description:
+
+                Applicable to RedBox HSR-PRP A and RedBox HSR-PRP B. One ID
+                is used by
+                one pair of RedBoxes (one configured to A and one configured to B)
+                coupling an HSR ring to a PRP network. The integer value states the value
+                of the path field a RedBox inserts into each frame it receives from its
+                interlink and injects into the HSR ring. When interpreted as binary values,
+                the LSB denotes the configuration of the RedBox (A or B), and the following
+                3 bits denote the identifier of a RedBox pair.
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 9/16. Values:  id1a(2), id1b(3), id2a(4), id2b(5), id3a(6), id3b(7), id4a(8), id4b(9), id5a(10), id5b(11), id6a(12), id6b(13), id7a(14), id7b(15)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lreRedBoxIdentity data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreRedBoxIdentity_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreRedBoxIdentity_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreRedBoxIdentity_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreRedBoxIdentity_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreRedBoxIdentity_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreRedBoxIdentity data.
+ * copy (* lreRedBoxIdentity_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreRedBoxIdentity_val_ptr ) = rowreq_ctx->data.lreRedBoxIdentity;
+
+    return MFD_SUCCESS;
+} /* lreRedBoxIdentity_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreEvaluateSupervision
+ * lreEvaluateSupervision is subid 16 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.16
+ * Description:
+
+                True if the LRE evaluates received supervision frames. False
+                if it
+                drops the supervision frames without evaluating. Note: LREs are required
+                to send supervision frames, but reception is optional. Default value is dependent
+                on implementation.
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  true(1), false(2)
+ *
+ * Its syntax is TruthValue (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lreEvaluateSupervision data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreEvaluateSupervision_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreEvaluateSupervision_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreEvaluateSupervision_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreEvaluateSupervision_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreEvaluateSupervision_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreEvaluateSupervision data.
+ * copy (* lreEvaluateSupervision_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreEvaluateSupervision_val_ptr ) = rowreq_ctx->data.lreEvaluateSupervision;
+
+    return MFD_SUCCESS;
+} /* lreEvaluateSupervision_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreNodesTableClear
+ * lreNodesTableClear is subid 17 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.17
+ * Description:
+specifies that the Node Table is to be cleared
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  noOp(0), clearNodeTable(1)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lreNodesTableClear data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreNodesTableClear_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreNodesTableClear_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreNodesTableClear_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreNodesTableClear_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodesTableClear_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreNodesTableClear data.
+ * copy (* lreNodesTableClear_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreNodesTableClear_val_ptr ) = rowreq_ctx->data.lreNodesTableClear;
+
+    return MFD_SUCCESS;
+} /* lreNodesTableClear_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreProxyNodeTableClear
+ * lreProxyNodeTableClear is subid 18 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.18
+ * Description:
+specifies that the Proxy Node Table is to be cleared
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  noOp(0), clearProxyNodeTable(1)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lreProxyNodeTableClear data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreProxyNodeTableClear_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreProxyNodeTableClear_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreProxyNodeTableClear_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreProxyNodeTableClear_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreProxyNodeTableClear_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreProxyNodeTableClear data.
+ * copy (* lreProxyNodeTableClear_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreProxyNodeTableClear_val_ptr ) = rowreq_ctx->data.lreProxyNodeTableClear;
+
+    return MFD_SUCCESS;
+} /* lreProxyNodeTableClear_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreDupListResideMaxTime
+ * lreDupListResideMaxTime is subid 19 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.19
+ * Description:
+the longest time an entry may reside in the duplicates list,
+              expressed as the number of seconds multiplied by 65536;
+              the default value is 26214 x 15 us, or 400 ms; too low a value can
+              cause broadcast storms
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 1
+ *   readable   1     iscolumn 1     ranges 0      hashint   1
+ *   settable   1
+ *   defval: 26214
+ *   hint: d
+ *
+ *
+ * Its syntax is SecondFraction (based on perltype INTEGER32)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
+ */
+/**
+ * Extract the current value of the lreDupListResideMaxTime data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreDupListResideMaxTime_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreDupListResideMaxTime_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, long * lreDupListResideMaxTime_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreDupListResideMaxTime_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreDupListResideMaxTime_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreDupListResideMaxTime data.
+ * copy (* lreDupListResideMaxTime_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreDupListResideMaxTime_val_ptr ) = rowreq_ctx->data.lreDupListResideMaxTime;
+
+    return MFD_SUCCESS;
+} /* lreDupListResideMaxTime_get */
+
+
+
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_get.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_get.h
new file mode 100644
index 0000000..3175fc9
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_get.h
@@ -0,0 +1,76 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ *
+ * @file lreInterfaceConfigTable_data_get.h
+ *
+ * @addtogroup get
+ *
+ * Prototypes for get functions
+ *
+ * @{
+ */
+#ifndef LREINTERFACECONFIGTABLE_DATA_GET_H
+#define LREINTERFACECONFIGTABLE_DATA_GET_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* *********************************************************************
+ * GET function declarations
+ */
+
+/* *********************************************************************
+ * GET Table declarations
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceConfigTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceConfigTable is subid 1 of lreConfigurationInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.0.1.0.1, length: 9
+*/
+    /*
+     * indexes
+     */
+
+    int lreRowStatus_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreRowStatus_val_ptr );
+    int lreNodeType_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreNodeType_val_ptr );
+    int lreNodeName_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char **lreNodeName_val_ptr_ptr, size_t *lreNodeName_val_ptr_len_ptr );
+    int lreVersionName_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char **lreVersionName_val_ptr_ptr, size_t *lreVersionName_val_ptr_len_ptr );
+    int lreMacAddress_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char **lreMacAddress_val_ptr_ptr, size_t *lreMacAddress_val_ptr_len_ptr );
+    int lrePortAdminStateA_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lrePortAdminStateA_val_ptr );
+    int lrePortAdminStateB_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lrePortAdminStateB_val_ptr );
+    int lreLinkStatusA_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreLinkStatusA_val_ptr );
+    int lreLinkStatusB_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreLinkStatusB_val_ptr );
+    int lreDuplicateDiscard_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreDuplicateDiscard_val_ptr );
+    int lreTransparentReception_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreTransparentReception_val_ptr );
+    int lreHsrLREMode_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreHsrLREMode_val_ptr );
+    int lreSwitchingEndNode_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreSwitchingEndNode_val_ptr );
+    int lreRedBoxIdentity_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreRedBoxIdentity_val_ptr );
+    int lreEvaluateSupervision_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreEvaluateSupervision_val_ptr );
+    int lreNodesTableClear_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreNodesTableClear_val_ptr );
+    int lreProxyNodeTableClear_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long * lreProxyNodeTableClear_val_ptr );
+    int lreDupListResideMaxTime_get( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, long * lreDupListResideMaxTime_val_ptr );
+
+
+int lreInterfaceConfigTable_indexes_set_tbl_idx(lreInterfaceConfigTable_mib_index *tbl_idx, u_long lreInterfaceConfigIndex_val);
+int lreInterfaceConfigTable_indexes_set(lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreInterfaceConfigIndex_val);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACECONFIGTABLE_DATA_GET_H */
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_set.c b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_set.c
new file mode 100644
index 0000000..38db196
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_set.c
@@ -0,0 +1,3268 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ *
+ */
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreInterfaceConfigTable.h"
+
+
+/** @defgroup data_set data_set: Routines to set data
+ *
+ * These routines are used to set the value for individual objects. The
+ * row context is passed, along with the new value.
+ *
+ * @{
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceConfigTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceConfigTable is subid 1 of lreConfigurationInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.0.1.0.1, length: 9
+*/
+    /*
+     * NOTE: if you update this chart, please update the versions in
+     *       local/mib2c-conf.d/parent-set.m2i
+     *       agent/mibgroup/helpers/baby_steps.c
+     * while you're at it.
+     */
+    /*
+     ***********************************************************************
+     * Baby Steps Flow Chart (2004.06.05)                                  *
+     *                                                                     *
+     * +--------------+    +================+    U = unconditional path    *
+     * |optional state|    ||required state||    S = path for success      *
+     * +--------------+    +================+    E = path for error        *
+     ***********************************************************************
+     *
+     *                        +--------------+
+     *                        |     pre      |
+     *                        |   request    |
+     *                        +--------------+
+     *                               | U
+     * +-------------+        +==============+
+     * |    row    |f|<-------||  object    ||
+     * |  create   |1|      E ||  lookup    ||
+     * +-------------+        +==============+
+     *     E |   | S                 | S
+     *       |   +------------------>|
+     *       |                +==============+
+     *       |              E ||   check    ||
+     *       |<---------------||   values   ||
+     *       |                +==============+
+     *       |                       | S
+     *       |                +==============+
+     *       |       +<-------||   undo     ||
+     *       |       |      E ||   setup    ||
+     *       |       |        +==============+
+     *       |       |               | S
+     *       |       |        +==============+
+     *       |       |        ||    set     ||-------------------------->+
+     *       |       |        ||   value    || E                         |
+     *       |       |        +==============+                           |
+     *       |       |               | S                                 |
+     *       |       |        +--------------+                           |
+     *       |       |        |    check     |-------------------------->|
+     *       |       |        |  consistency | E                         |
+     *       |       |        +--------------+                           |
+     *       |       |               | S                                 |
+     *       |       |        +==============+         +==============+  |
+     *       |       |        ||   commit   ||-------->||     undo   ||  |
+     *       |       |        ||            || E       ||    commit  ||  |
+     *       |       |        +==============+         +==============+  |
+     *       |       |               | S                     U |<--------+
+     *       |       |        +--------------+         +==============+
+     *       |       |        | irreversible |         ||    undo    ||
+     *       |       |        |    commit    |         ||     set    ||
+     *       |       |        +--------------+         +==============+
+     *       |       |               | U                     U |
+     *       |       +-------------->|<------------------------+
+     *       |                +==============+
+     *       |                ||   undo     ||
+     *       |                ||  cleanup   ||
+     *       |                +==============+
+     *       +---------------------->| U
+     *                               |
+     *                          (err && f1)------------------->+
+     *                               |                         |
+     *                        +--------------+         +--------------+
+     *                        |    post      |<--------|      row     |
+     *                        |   request    |       U |    release   |
+     *                        +--------------+         +--------------+
+     *
+     */
+
+/**
+ * Setup up context with information needed to undo a set request.
+ *
+ * This function will be called before the individual node undo setup
+ * functions are called. If you need to do any undo setup that is not
+ * related to a specific column, you can do it here.
+ *
+ * Note that the undo context has been allocated with
+ * lreInterfaceConfigTable_allocate_data(), but may need extra
+ * initialization similar to what you may have done in
+ * lreInterfaceConfigTable_rowreq_ctx_init().
+ * Note that an individual node's undo_setup function will only be called
+ * if that node is being set to a new value.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in the node's undo_setup
+ * function, so it won't be done unless it is necessary.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ */
+int
+lreInterfaceConfigTable_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    int rc = MFD_SUCCESS;
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_undo_setup","called\n"));
+
+    /** we should have a non-NULL pointer */
+    netsnmp_assert( NULL != rowreq_ctx );
+
+    /*
+     * TODO:451:M: |-> Setup lreInterfaceConfigTable undo.
+     * set up lreInterfaceConfigTable undo information, in preparation for a set.
+     * Undo storage is in (* lreDupListResideMaxTime_val_ptr )*
+     */
+
+    return rc;
+} /* lreInterfaceConfigTable_undo_setup */
+
+/**
+ * Undo a set request.
+ *
+ * This function will be called before the individual node undo
+ * functions are called. If you need to do any undo that is not
+ * related to a specific column, you can do it here.
+ *
+ * Note that an individual node's undo function will only be called
+ * if that node is being set to a new value.
+ *
+ * If there is anything  specific to a particular column (e.g. releasing
+ * memory for a string), you should do that setup in the node's undo
+ * function, so it won't be done unless it is necessary.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ */
+int
+lreInterfaceConfigTable_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    int rc = MFD_SUCCESS;
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_undo","called\n"));
+
+    /** we should have a non-NULL pointer */
+    netsnmp_assert( NULL != rowreq_ctx );
+
+    /*
+     * TODO:451:M: |-> lreInterfaceConfigTable undo.
+     * lreInterfaceConfigTable undo information, in response to a failed set.
+     * Undo storage is in (* lreDupListResideMaxTime_val_ptr )*
+     */
+
+    return rc;
+} /* lreInterfaceConfigTable_undo_setup */
+
+/**
+ * Cleanup up context undo information.
+ *
+ * This function will be called after set/commit processing. If you
+ * allocated any resources in undo_setup, this is the place to release
+ * those resources.
+ *
+ * This function is called regardless of the success or failure of the set
+ * request. If you need to perform different steps for cleanup depending
+ * on success or failure, you can add a flag to the rowreq_ctx.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error
+ */
+int
+lreInterfaceConfigTable_undo_cleanup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    int rc = MFD_SUCCESS;
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_undo_cleanup","called\n"));
+
+    /** we should have a non-NULL pointer */
+    netsnmp_assert( NULL != rowreq_ctx );
+
+    /*
+     * TODO:452:M: |-> Cleanup lreInterfaceConfigTable undo.
+     * Undo storage is in (* lreDupListResideMaxTime_val_ptr )*
+     */
+
+    return rc;
+} /* lreInterfaceConfigTable_undo_cleanup */
+
+/**
+ * commit new values.
+ *
+ * At this point, you should have done everything you can to ensure that
+ * this commit will not fail.
+ *
+ * Should you need different behavior depending on which columns were
+ * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
+ * set. The definitions for the COLUMN_*_FLAG bits can be found in
+ * lreInterfaceConfigTable_oids.h.
+ * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
+ *
+ * @param lreInterfaceConfigTable_rowreq_ctx
+ *        Pointer to the users context.
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error
+ */
+int
+lreInterfaceConfigTable_commit( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    int rc = MFD_SUCCESS;
+    int             save_flags;
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_commit","called\n"));
+
+    /** we should have a non-NULL pointer */
+    netsnmp_assert( NULL != rowreq_ctx );
+
+    /*
+     * save flags, then clear until we actually do something
+     */
+    save_flags = rowreq_ctx->column_set_flags;
+    rowreq_ctx->column_set_flags = 0;
+
+    /*
+     * commit lreInterfaceConfigTable data
+     * 1) check the column's flag in save_flags to see if it was set.
+     * 2) clear the flag when you handle that column
+     * 3) set the column's flag in column_set_flags if it needs undo
+     *    processing in case of a failure.
+     */
+    if (save_flags & COLUMN_LREROWSTATUS_FLAG) {
+       save_flags &= ~COLUMN_LREROWSTATUS_FLAG; /* clear lreRowStatus */
+       /*
+        * TODO:482:o: |-> commit column lreRowStatus.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lreRowStatus commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lreRowStatus
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LREROWSTATUS_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LRENODETYPE_FLAG) {
+       save_flags &= ~COLUMN_LRENODETYPE_FLAG; /* clear lreNodeType */
+       /*
+        * TODO:482:o: |-> commit column lreNodeType.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lreNodeType commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lreNodeType
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LRENODETYPE_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LRENODENAME_FLAG) {
+       save_flags &= ~COLUMN_LRENODENAME_FLAG; /* clear lreNodeName */
+       /*
+        * TODO:482:o: |-> commit column lreNodeName.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lreNodeName commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lreNodeName
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LRENODENAME_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LREMACADDRESS_FLAG) {
+       save_flags &= ~COLUMN_LREMACADDRESS_FLAG; /* clear lreMacAddress */
+       /*
+        * TODO:482:o: |-> commit column lreMacAddress.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lreMacAddress commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lreMacAddress
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LREMACADDRESS_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LREPORTADMINSTATEA_FLAG) {
+       save_flags &= ~COLUMN_LREPORTADMINSTATEA_FLAG; /* clear lrePortAdminStateA */
+       /*
+        * TODO:482:o: |-> commit column lrePortAdminStateA.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lrePortAdminStateA commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lrePortAdminStateA
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LREPORTADMINSTATEA_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LREPORTADMINSTATEB_FLAG) {
+       save_flags &= ~COLUMN_LREPORTADMINSTATEB_FLAG; /* clear lrePortAdminStateB */
+       /*
+        * TODO:482:o: |-> commit column lrePortAdminStateB.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lrePortAdminStateB commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lrePortAdminStateB
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LREPORTADMINSTATEB_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LREDUPLICATEDISCARD_FLAG) {
+       save_flags &= ~COLUMN_LREDUPLICATEDISCARD_FLAG; /* clear lreDuplicateDiscard */
+       /*
+        * TODO:482:o: |-> commit column lreDuplicateDiscard.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lreDuplicateDiscard commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lreDuplicateDiscard
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LREDUPLICATEDISCARD_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LRETRANSPARENTRECEPTION_FLAG) {
+       save_flags &= ~COLUMN_LRETRANSPARENTRECEPTION_FLAG; /* clear lreTransparentReception */
+       /*
+        * TODO:482:o: |-> commit column lreTransparentReception.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lreTransparentReception commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lreTransparentReception
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LRETRANSPARENTRECEPTION_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LREHSRLREMODE_FLAG) {
+       save_flags &= ~COLUMN_LREHSRLREMODE_FLAG; /* clear lreHsrLREMode */
+       /*
+        * TODO:482:o: |-> commit column lreHsrLREMode.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lreHsrLREMode commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lreHsrLREMode
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LREHSRLREMODE_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LRESWITCHINGENDNODE_FLAG) {
+       save_flags &= ~COLUMN_LRESWITCHINGENDNODE_FLAG; /* clear lreSwitchingEndNode */
+       /*
+        * TODO:482:o: |-> commit column lreSwitchingEndNode.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lreSwitchingEndNode commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lreSwitchingEndNode
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LRESWITCHINGENDNODE_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LREREDBOXIDENTITY_FLAG) {
+       save_flags &= ~COLUMN_LREREDBOXIDENTITY_FLAG; /* clear lreRedBoxIdentity */
+       /*
+        * TODO:482:o: |-> commit column lreRedBoxIdentity.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lreRedBoxIdentity commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lreRedBoxIdentity
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LREREDBOXIDENTITY_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LREEVALUATESUPERVISION_FLAG) {
+       save_flags &= ~COLUMN_LREEVALUATESUPERVISION_FLAG; /* clear lreEvaluateSupervision */
+       /*
+        * TODO:482:o: |-> commit column lreEvaluateSupervision.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lreEvaluateSupervision commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lreEvaluateSupervision
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LREEVALUATESUPERVISION_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LRENODESTABLECLEAR_FLAG) {
+       save_flags &= ~COLUMN_LRENODESTABLECLEAR_FLAG; /* clear lreNodesTableClear */
+       /*
+        * TODO:482:o: |-> commit column lreNodesTableClear.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lreNodesTableClear commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lreNodesTableClear
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LRENODESTABLECLEAR_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LREPROXYNODETABLECLEAR_FLAG) {
+       save_flags &= ~COLUMN_LREPROXYNODETABLECLEAR_FLAG; /* clear lreProxyNodeTableClear */
+       /*
+        * TODO:482:o: |-> commit column lreProxyNodeTableClear.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lreProxyNodeTableClear commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lreProxyNodeTableClear
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LREPROXYNODETABLECLEAR_FLAG;
+       }
+    }
+
+    if (save_flags & COLUMN_LREDUPLISTRESIDEMAXTIME_FLAG) {
+       save_flags &= ~COLUMN_LREDUPLISTRESIDEMAXTIME_FLAG; /* clear lreDupListResideMaxTime */
+       /*
+        * TODO:482:o: |-> commit column lreDupListResideMaxTime.
+        */
+       rc = -1;
+       if(-1 == rc) {
+           snmp_log(LOG_ERR,"lreInterfaceConfigTable column lreDupListResideMaxTime commit failed\n");
+       }
+       else {
+            /*
+             * set flag, in case we need to undo lreDupListResideMaxTime
+             */
+            rowreq_ctx->column_set_flags |= COLUMN_LREDUPLISTRESIDEMAXTIME_FLAG;
+       }
+    }
+
+    /*
+     * if we successfully commited this row, set the dirty flag.
+     */
+    if (MFD_SUCCESS == rc) {
+        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
+    }
+
+    if (save_flags) {
+       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
+       return MFD_ERROR;
+    }
+
+    return rc;
+} /* lreInterfaceConfigTable_commit */
+
+/**
+ * undo commit new values.
+ *
+ * Should you need different behavior depending on which columns were
+ * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
+ * set. The definitions for the COLUMN_*_FLAG bits can be found in
+ * lreInterfaceConfigTable_oids.h.
+ * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
+ *
+ * @param lreInterfaceConfigTable_rowreq_ctx
+ *        Pointer to the users context.
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error
+ */
+int
+lreInterfaceConfigTable_undo_commit( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    int rc = MFD_SUCCESS;
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_undo_commit","called\n"));
+
+    /** we should have a non-NULL pointer */
+    netsnmp_assert( NULL != rowreq_ctx );
+
+    /*
+     * TODO:485:M: |-> Undo lreInterfaceConfigTable commit.
+     * check the column's flag in rowreq_ctx->column_set_flags to see
+     * if it was set during commit, then undo it.
+     *
+     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
+     */
+
+
+    /*
+     * if we successfully un-commited this row, clear the dirty flag.
+     */
+    if (MFD_SUCCESS == rc) {
+        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
+    }
+
+    return rc;
+} /* lreInterfaceConfigTable_undo_commit */
+
+/*
+ * TODO:440:M: Implement lreInterfaceConfigTable node value checks.
+ * TODO:450:M: Implement lreInterfaceConfigTable undo functions.
+ * TODO:460:M: Implement lreInterfaceConfigTable set functions.
+ * TODO:480:M: Implement lreInterfaceConfigTable commit functions.
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreRowStatus
+ * lreRowStatus is subid 2 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is Create.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.2
+ * Description:
+indicates the status of the LRE table entry
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 6/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
+ *
+ * Its syntax is RowStatus (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreRowStatus_val
+ *        A long containing the new value.
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_INTEGER
+ *    The value is one of  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lreRowStatus_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreRowStatus_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreRowStatus_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:441:o: |-> Check for valid lreRowStatus value.
+     */
+
+    return MFD_SUCCESS; /* lreRowStatus value not illegal */
+} /* lreRowStatus_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lreRowStatus_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreRowStatus_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lreRowStatus undo.
+     */
+    /*
+     * copy lreRowStatus data
+     * set rowreq_ctx->undo->lreRowStatus from rowreq_ctx->data.lreRowStatus
+     */
+    rowreq_ctx->undo->lreRowStatus = rowreq_ctx->data.lreRowStatus;
+
+
+    return MFD_SUCCESS;
+} /* lreRowStatus_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lreRowStatus_val
+ *        A long containing the new value.
+ */
+int
+lreRowStatus_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreRowStatus_val )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreRowStatus_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:461:M: |-> Set lreRowStatus value.
+     * set lreRowStatus value in rowreq_ctx->data
+     */
+    rowreq_ctx->data.lreRowStatus = lreRowStatus_val;
+
+    return MFD_SUCCESS;
+} /* lreRowStatus_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lreRowStatus_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreRowStatus_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lreRowStatus undo.
+     */
+    /*
+     * copy lreRowStatus data
+     * set rowreq_ctx->data.lreRowStatus from rowreq_ctx->undo->lreRowStatus
+     */
+    rowreq_ctx->data.lreRowStatus = rowreq_ctx->undo->lreRowStatus;
+
+
+    return MFD_SUCCESS;
+} /* lreRowStatus_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreNodeType
+ * lreNodeType is subid 3 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.3
+ * Description:
+
+                specifies the operation mode of the LRE:
+                PRP mode 1 (1)
+                HSR mode (2)
+                Note: PRP mode 0 is considered deprecated and is not supported by this
+                revision of the MIB
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  prpmode1(1), hsr(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreNodeType_val
+ *        A long containing the new value.
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_INTEGER
+ *    The value is one of  prpmode1(1), hsr(2)
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lreNodeType_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreNodeType_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodeType_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:441:o: |-> Check for valid lreNodeType value.
+     */
+
+    return MFD_SUCCESS; /* lreNodeType value not illegal */
+} /* lreNodeType_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lreNodeType_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodeType_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lreNodeType undo.
+     */
+    /*
+     * copy lreNodeType data
+     * set rowreq_ctx->undo->lreNodeType from rowreq_ctx->data.lreNodeType
+     */
+    rowreq_ctx->undo->lreNodeType = rowreq_ctx->data.lreNodeType;
+
+
+    return MFD_SUCCESS;
+} /* lreNodeType_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lreNodeType_val
+ *        A long containing the new value.
+ */
+int
+lreNodeType_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreNodeType_val )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodeType_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:461:M: |-> Set lreNodeType value.
+     * set lreNodeType value in rowreq_ctx->data
+     */
+    rowreq_ctx->data.lreNodeType = lreNodeType_val;
+
+    return MFD_SUCCESS;
+} /* lreNodeType_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lreNodeType_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodeType_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lreNodeType undo.
+     */
+    /*
+     * copy lreNodeType data
+     * set rowreq_ctx->data.lreNodeType from rowreq_ctx->undo->lreNodeType
+     */
+    rowreq_ctx->data.lreNodeType = rowreq_ctx->undo->lreNodeType;
+
+
+    return MFD_SUCCESS;
+} /* lreNodeType_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreNodeName
+ * lreNodeName is subid 4 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.4
+ * Description:
+specifies this LRE's node name
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 1      hashint   1
+ *   settable   1
+ *   hint: 255a
+ *
+ * Ranges:  0 - 255;
+ *
+ * Its syntax is DisplayString (based on perltype OCTETSTR)
+ * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
+ * This data type requires a length.  (Max 255)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreNodeName_val_ptr
+ *        A char containing the new value.
+ * @param lreNodeName_val_ptr_len
+ *        The size (in bytes) of the data pointed to by lreNodeName_val_ptr
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_OCTET_STR
+ *    The length is < sizeof(rowreq_ctx->data.lreNodeName).
+ *    The length is in (one of) the range set(s):  0 - 255
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lreNodeName_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char *lreNodeName_val_ptr,  size_t lreNodeName_val_ptr_len)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodeName_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+    netsnmp_assert(NULL != lreNodeName_val_ptr);
+
+    /*
+     * TODO:441:o: |-> Check for valid lreNodeName value.
+     */
+
+    return MFD_SUCCESS; /* lreNodeName value not illegal */
+} /* lreNodeName_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lreNodeName_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodeName_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lreNodeName undo.
+     */
+    /*
+     * copy lreNodeName and lreNodeName_len data
+     * set rowreq_ctx->undo->lreNodeName from rowreq_ctx->data.lreNodeName
+     */
+    memcpy( rowreq_ctx->undo->lreNodeName, rowreq_ctx->data.lreNodeName,
+            (rowreq_ctx->data.lreNodeName_len * sizeof(rowreq_ctx->undo->lreNodeName[0])));
+    rowreq_ctx->undo->lreNodeName_len = rowreq_ctx->data.lreNodeName_len;
+
+
+    return MFD_SUCCESS;
+} /* lreNodeName_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lreNodeName_val_ptr
+ *        A char containing the new value.
+ * @param lreNodeName_val_ptr_len
+ *        The size (in bytes) of the data pointed to by lreNodeName_val_ptr
+ */
+int
+lreNodeName_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char *lreNodeName_val_ptr,  size_t lreNodeName_val_ptr_len )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodeName_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+    netsnmp_assert(NULL != lreNodeName_val_ptr);
+
+    /*
+     * TODO:461:M: |-> Set lreNodeName value.
+     * set lreNodeName value in rowreq_ctx->data
+     */
+    memcpy( rowreq_ctx->data.lreNodeName, lreNodeName_val_ptr, lreNodeName_val_ptr_len );
+    /** convert bytes to number of char */
+    rowreq_ctx->data.lreNodeName_len = lreNodeName_val_ptr_len / sizeof(lreNodeName_val_ptr[0]);
+
+    return MFD_SUCCESS;
+} /* lreNodeName_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lreNodeName_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodeName_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lreNodeName undo.
+     */
+    /*
+     * copy lreNodeName and lreNodeName_len data
+     * set rowreq_ctx->data.lreNodeName from rowreq_ctx->undo->lreNodeName
+     */
+    memcpy( rowreq_ctx->data.lreNodeName, rowreq_ctx->undo->lreNodeName,
+            (rowreq_ctx->undo->lreNodeName_len * sizeof(rowreq_ctx->data.lreNodeName[0])));
+    rowreq_ctx->data.lreNodeName_len = rowreq_ctx->undo->lreNodeName_len;
+
+
+    return MFD_SUCCESS;
+} /* lreNodeName_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreMacAddress
+ * lreMacAddress is subid 6 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.6
+ * Description:
+
+                Specifies the MAC address to be used by this LRE. MAC
+                addresses are
+                identical for all ports of a single LRE
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 1      hashint   1
+ *   settable   1
+ *   hint: 1x:
+ *
+ * Ranges:  6;
+ *
+ * Its syntax is MacAddress (based on perltype OCTETSTR)
+ * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
+ * This data type requires a length.  (Max 6)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreMacAddress_val_ptr
+ *        A char containing the new value.
+ * @param lreMacAddress_val_ptr_len
+ *        The size (in bytes) of the data pointed to by lreMacAddress_val_ptr
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_OCTET_STR
+ *    The length is < sizeof(rowreq_ctx->data.lreMacAddress).
+ *    The length is in (one of) the range set(s):  6
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lreMacAddress_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char *lreMacAddress_val_ptr,  size_t lreMacAddress_val_ptr_len)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreMacAddress_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+    netsnmp_assert(NULL != lreMacAddress_val_ptr);
+
+    /*
+     * TODO:441:o: |-> Check for valid lreMacAddress value.
+     */
+
+    return MFD_SUCCESS; /* lreMacAddress value not illegal */
+} /* lreMacAddress_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lreMacAddress_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreMacAddress_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lreMacAddress undo.
+     */
+    /*
+     * copy lreMacAddress and lreMacAddress_len data
+     * set rowreq_ctx->undo->lreMacAddress from rowreq_ctx->data.lreMacAddress
+     */
+    memcpy( rowreq_ctx->undo->lreMacAddress, rowreq_ctx->data.lreMacAddress,
+            (rowreq_ctx->data.lreMacAddress_len * sizeof(rowreq_ctx->undo->lreMacAddress[0])));
+    rowreq_ctx->undo->lreMacAddress_len = rowreq_ctx->data.lreMacAddress_len;
+
+
+    return MFD_SUCCESS;
+} /* lreMacAddress_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lreMacAddress_val_ptr
+ *        A char containing the new value.
+ * @param lreMacAddress_val_ptr_len
+ *        The size (in bytes) of the data pointed to by lreMacAddress_val_ptr
+ */
+int
+lreMacAddress_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char *lreMacAddress_val_ptr,  size_t lreMacAddress_val_ptr_len )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreMacAddress_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+    netsnmp_assert(NULL != lreMacAddress_val_ptr);
+
+    /*
+     * TODO:461:M: |-> Set lreMacAddress value.
+     * set lreMacAddress value in rowreq_ctx->data
+     */
+    memcpy( rowreq_ctx->data.lreMacAddress, lreMacAddress_val_ptr, lreMacAddress_val_ptr_len );
+    /** convert bytes to number of char */
+    rowreq_ctx->data.lreMacAddress_len = lreMacAddress_val_ptr_len / sizeof(lreMacAddress_val_ptr[0]);
+
+    return MFD_SUCCESS;
+} /* lreMacAddress_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lreMacAddress_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreMacAddress_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lreMacAddress undo.
+     */
+    /*
+     * copy lreMacAddress and lreMacAddress_len data
+     * set rowreq_ctx->data.lreMacAddress from rowreq_ctx->undo->lreMacAddress
+     */
+    memcpy( rowreq_ctx->data.lreMacAddress, rowreq_ctx->undo->lreMacAddress,
+            (rowreq_ctx->undo->lreMacAddress_len * sizeof(rowreq_ctx->data.lreMacAddress[0])));
+    rowreq_ctx->data.lreMacAddress_len = rowreq_ctx->undo->lreMacAddress_len;
+
+
+    return MFD_SUCCESS;
+} /* lreMacAddress_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lrePortAdminStateA
+ * lrePortAdminStateA is subid 7 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.7
+ * Description:
+
+                Specifies whether the port A shall be active or not Active
+                through
+                administrative action (Default: active).
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  notActive(1), active(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lrePortAdminStateA_val
+ *        A long containing the new value.
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_INTEGER
+ *    The value is one of  notActive(1), active(2)
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lrePortAdminStateA_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lrePortAdminStateA_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lrePortAdminStateA_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:441:o: |-> Check for valid lrePortAdminStateA value.
+     */
+
+    return MFD_SUCCESS; /* lrePortAdminStateA value not illegal */
+} /* lrePortAdminStateA_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lrePortAdminStateA_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lrePortAdminStateA_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lrePortAdminStateA undo.
+     */
+    /*
+     * copy lrePortAdminStateA data
+     * set rowreq_ctx->undo->lrePortAdminStateA from rowreq_ctx->data.lrePortAdminStateA
+     */
+    rowreq_ctx->undo->lrePortAdminStateA = rowreq_ctx->data.lrePortAdminStateA;
+
+
+    return MFD_SUCCESS;
+} /* lrePortAdminStateA_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lrePortAdminStateA_val
+ *        A long containing the new value.
+ */
+int
+lrePortAdminStateA_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lrePortAdminStateA_val )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lrePortAdminStateA_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:461:M: |-> Set lrePortAdminStateA value.
+     * set lrePortAdminStateA value in rowreq_ctx->data
+     */
+    rowreq_ctx->data.lrePortAdminStateA = lrePortAdminStateA_val;
+
+    return MFD_SUCCESS;
+} /* lrePortAdminStateA_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lrePortAdminStateA_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lrePortAdminStateA_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lrePortAdminStateA undo.
+     */
+    /*
+     * copy lrePortAdminStateA data
+     * set rowreq_ctx->data.lrePortAdminStateA from rowreq_ctx->undo->lrePortAdminStateA
+     */
+    rowreq_ctx->data.lrePortAdminStateA = rowreq_ctx->undo->lrePortAdminStateA;
+
+
+    return MFD_SUCCESS;
+} /* lrePortAdminStateA_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lrePortAdminStateB
+ * lrePortAdminStateB is subid 8 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.8
+ * Description:
+
+                Specifies whether the port B shall be active or not Active
+                through
+                administrative action (Default: active).
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  notActive(1), active(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lrePortAdminStateB_val
+ *        A long containing the new value.
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_INTEGER
+ *    The value is one of  notActive(1), active(2)
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lrePortAdminStateB_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lrePortAdminStateB_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lrePortAdminStateB_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:441:o: |-> Check for valid lrePortAdminStateB value.
+     */
+
+    return MFD_SUCCESS; /* lrePortAdminStateB value not illegal */
+} /* lrePortAdminStateB_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lrePortAdminStateB_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lrePortAdminStateB_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lrePortAdminStateB undo.
+     */
+    /*
+     * copy lrePortAdminStateB data
+     * set rowreq_ctx->undo->lrePortAdminStateB from rowreq_ctx->data.lrePortAdminStateB
+     */
+    rowreq_ctx->undo->lrePortAdminStateB = rowreq_ctx->data.lrePortAdminStateB;
+
+
+    return MFD_SUCCESS;
+} /* lrePortAdminStateB_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lrePortAdminStateB_val
+ *        A long containing the new value.
+ */
+int
+lrePortAdminStateB_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lrePortAdminStateB_val )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lrePortAdminStateB_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:461:M: |-> Set lrePortAdminStateB value.
+     * set lrePortAdminStateB value in rowreq_ctx->data
+     */
+    rowreq_ctx->data.lrePortAdminStateB = lrePortAdminStateB_val;
+
+    return MFD_SUCCESS;
+} /* lrePortAdminStateB_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lrePortAdminStateB_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lrePortAdminStateB_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lrePortAdminStateB undo.
+     */
+    /*
+     * copy lrePortAdminStateB data
+     * set rowreq_ctx->data.lrePortAdminStateB from rowreq_ctx->undo->lrePortAdminStateB
+     */
+    rowreq_ctx->data.lrePortAdminStateB = rowreq_ctx->undo->lrePortAdminStateB;
+
+
+    return MFD_SUCCESS;
+} /* lrePortAdminStateB_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreDuplicateDiscard
+ * lreDuplicateDiscard is subid 11 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.11
+ * Description:
+
+                specifies whether a duplicate discard algorithm is used at
+                reception
+                (Default: discard).
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  doNotDiscard(1), discard(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreDuplicateDiscard_val
+ *        A long containing the new value.
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_INTEGER
+ *    The value is one of  doNotDiscard(1), discard(2)
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lreDuplicateDiscard_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreDuplicateDiscard_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreDuplicateDiscard_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:441:o: |-> Check for valid lreDuplicateDiscard value.
+     */
+
+    return MFD_SUCCESS; /* lreDuplicateDiscard value not illegal */
+} /* lreDuplicateDiscard_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lreDuplicateDiscard_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreDuplicateDiscard_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lreDuplicateDiscard undo.
+     */
+    /*
+     * copy lreDuplicateDiscard data
+     * set rowreq_ctx->undo->lreDuplicateDiscard from rowreq_ctx->data.lreDuplicateDiscard
+     */
+    rowreq_ctx->undo->lreDuplicateDiscard = rowreq_ctx->data.lreDuplicateDiscard;
+
+
+    return MFD_SUCCESS;
+} /* lreDuplicateDiscard_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lreDuplicateDiscard_val
+ *        A long containing the new value.
+ */
+int
+lreDuplicateDiscard_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreDuplicateDiscard_val )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreDuplicateDiscard_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:461:M: |-> Set lreDuplicateDiscard value.
+     * set lreDuplicateDiscard value in rowreq_ctx->data
+     */
+    rowreq_ctx->data.lreDuplicateDiscard = lreDuplicateDiscard_val;
+
+    return MFD_SUCCESS;
+} /* lreDuplicateDiscard_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lreDuplicateDiscard_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreDuplicateDiscard_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lreDuplicateDiscard undo.
+     */
+    /*
+     * copy lreDuplicateDiscard data
+     * set rowreq_ctx->data.lreDuplicateDiscard from rowreq_ctx->undo->lreDuplicateDiscard
+     */
+    rowreq_ctx->data.lreDuplicateDiscard = rowreq_ctx->undo->lreDuplicateDiscard;
+
+
+    return MFD_SUCCESS;
+} /* lreDuplicateDiscard_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreTransparentReception
+ * lreTransparentReception is subid 12 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.12
+ * Description:
+
+                if removeRCT is configured, the RCT is removed when
+                forwarding to the upper
+                layers, only applicable for PRP LRE (Default: removeRCT).
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  removeRCT(1), passRCT(2)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreTransparentReception_val
+ *        A long containing the new value.
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_INTEGER
+ *    The value is one of  removeRCT(1), passRCT(2)
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lreTransparentReception_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreTransparentReception_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreTransparentReception_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:441:o: |-> Check for valid lreTransparentReception value.
+     */
+
+    return MFD_SUCCESS; /* lreTransparentReception value not illegal */
+} /* lreTransparentReception_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lreTransparentReception_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreTransparentReception_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lreTransparentReception undo.
+     */
+    /*
+     * copy lreTransparentReception data
+     * set rowreq_ctx->undo->lreTransparentReception from rowreq_ctx->data.lreTransparentReception
+     */
+    rowreq_ctx->undo->lreTransparentReception = rowreq_ctx->data.lreTransparentReception;
+
+
+    return MFD_SUCCESS;
+} /* lreTransparentReception_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lreTransparentReception_val
+ *        A long containing the new value.
+ */
+int
+lreTransparentReception_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreTransparentReception_val )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreTransparentReception_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:461:M: |-> Set lreTransparentReception value.
+     * set lreTransparentReception value in rowreq_ctx->data
+     */
+    rowreq_ctx->data.lreTransparentReception = lreTransparentReception_val;
+
+    return MFD_SUCCESS;
+} /* lreTransparentReception_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lreTransparentReception_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreTransparentReception_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lreTransparentReception undo.
+     */
+    /*
+     * copy lreTransparentReception data
+     * set rowreq_ctx->data.lreTransparentReception from rowreq_ctx->undo->lreTransparentReception
+     */
+    rowreq_ctx->data.lreTransparentReception = rowreq_ctx->undo->lreTransparentReception;
+
+
+    return MFD_SUCCESS;
+} /* lreTransparentReception_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreHsrLREMode
+ * lreHsrLREMode is subid 13 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.13
+ * Description:
+
+                This enumeration is only applicable if the LRE is an HSR
+                bridging node or RedBox.
+                It shows the mode of the HSR LRE:
+                (1) Default mode: The HSR LRE is in mode h and bridges tagged HSR traffic
+                (2) Optional mode: The HSR LRE is in mode n and bridging between its HSR ports
+                Is disabled.
+                Traffic is HSR tagged.
+                (3) Optional mode: The HSR LRE is in mode t and bridges non-tagged HSR traffic
+                between its HSR ports
+                (4) Optional mode: The HSR LRE is in mode u and behaves like in mode h, except it
+                does not remove unicast messages
+                (5) Optional mode: The HSR LRE is configured in mixed mode. HSR frames are handled
+                according to mode h. Non-HSR frames are handled according to
+                802.1D bridging rules.
+                (6) Optional mode: The HSR LRE is in mode x and behaves like in mode h, except it
+                does not send a frame that is a duplicate of a frame that is received completely
+                and correctly from the opposite direction
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 4/8. Values:  modeh(1), moden(2), modet(3), modeu(4), modem(5), modex(6)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreHsrLREMode_val
+ *        A long containing the new value.
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_INTEGER
+ *    The value is one of  modeh(1), moden(2), modet(3), modeu(4), modem(5), modex(6)
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lreHsrLREMode_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreHsrLREMode_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreHsrLREMode_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:441:o: |-> Check for valid lreHsrLREMode value.
+     */
+
+    return MFD_SUCCESS; /* lreHsrLREMode value not illegal */
+} /* lreHsrLREMode_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lreHsrLREMode_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreHsrLREMode_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lreHsrLREMode undo.
+     */
+    /*
+     * copy lreHsrLREMode data
+     * set rowreq_ctx->undo->lreHsrLREMode from rowreq_ctx->data.lreHsrLREMode
+     */
+    rowreq_ctx->undo->lreHsrLREMode = rowreq_ctx->data.lreHsrLREMode;
+
+
+    return MFD_SUCCESS;
+} /* lreHsrLREMode_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lreHsrLREMode_val
+ *        A long containing the new value.
+ */
+int
+lreHsrLREMode_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreHsrLREMode_val )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreHsrLREMode_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:461:M: |-> Set lreHsrLREMode value.
+     * set lreHsrLREMode value in rowreq_ctx->data
+     */
+    rowreq_ctx->data.lreHsrLREMode = lreHsrLREMode_val;
+
+    return MFD_SUCCESS;
+} /* lreHsrLREMode_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lreHsrLREMode_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreHsrLREMode_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lreHsrLREMode undo.
+     */
+    /*
+     * copy lreHsrLREMode data
+     * set rowreq_ctx->data.lreHsrLREMode from rowreq_ctx->undo->lreHsrLREMode
+     */
+    rowreq_ctx->data.lreHsrLREMode = rowreq_ctx->undo->lreHsrLREMode;
+
+
+    return MFD_SUCCESS;
+} /* lreHsrLREMode_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreSwitchingEndNode
+ * lreSwitchingEndNode is subid 14 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.14
+ * Description:
+
+                This enumeration shows which feature is enabled in this
+                particular LRE:
+                (1): an unspecified non-bridging node, e.g. SRP.
+                (2): an unspecified bridging node, e.g. RSTP.
+                (3): a PRP node/RedBox.
+                (4): an HSR RedBox with regular Ethernet traffic on its interlink.
+                (5): an HSR switching node.
+                (6): an HSR RedBox with HSR tagged traffic on its interlink.
+                (7): an HSR RedBox with PRP traffic for LAN A on its interlink.
+                (8): an HSR RedBox with PRP traffic for LAN B on its interlink.
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 5/16. Values:  nonbridgingnode(1), bridgingunspecified(2), prpnode(3), hsrredboxsan(4), hsrnode(5), hsrredboxhsr(6), hsrredboxprpa(7), hsrredboxprpb(8)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreSwitchingEndNode_val
+ *        A long containing the new value.
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_INTEGER
+ *    The value is one of  nonbridgingnode(1), bridgingunspecified(2), prpnode(3), hsrredboxsan(4), hsrnode(5), hsrredboxhsr(6), hsrredboxprpa(7), hsrredboxprpb(8)
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lreSwitchingEndNode_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreSwitchingEndNode_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreSwitchingEndNode_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:441:o: |-> Check for valid lreSwitchingEndNode value.
+     */
+
+    return MFD_SUCCESS; /* lreSwitchingEndNode value not illegal */
+} /* lreSwitchingEndNode_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lreSwitchingEndNode_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreSwitchingEndNode_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lreSwitchingEndNode undo.
+     */
+    /*
+     * copy lreSwitchingEndNode data
+     * set rowreq_ctx->undo->lreSwitchingEndNode from rowreq_ctx->data.lreSwitchingEndNode
+     */
+    rowreq_ctx->undo->lreSwitchingEndNode = rowreq_ctx->data.lreSwitchingEndNode;
+
+
+    return MFD_SUCCESS;
+} /* lreSwitchingEndNode_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lreSwitchingEndNode_val
+ *        A long containing the new value.
+ */
+int
+lreSwitchingEndNode_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreSwitchingEndNode_val )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreSwitchingEndNode_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:461:M: |-> Set lreSwitchingEndNode value.
+     * set lreSwitchingEndNode value in rowreq_ctx->data
+     */
+    rowreq_ctx->data.lreSwitchingEndNode = lreSwitchingEndNode_val;
+
+    return MFD_SUCCESS;
+} /* lreSwitchingEndNode_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lreSwitchingEndNode_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreSwitchingEndNode_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lreSwitchingEndNode undo.
+     */
+    /*
+     * copy lreSwitchingEndNode data
+     * set rowreq_ctx->data.lreSwitchingEndNode from rowreq_ctx->undo->lreSwitchingEndNode
+     */
+    rowreq_ctx->data.lreSwitchingEndNode = rowreq_ctx->undo->lreSwitchingEndNode;
+
+
+    return MFD_SUCCESS;
+} /* lreSwitchingEndNode_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreRedBoxIdentity
+ * lreRedBoxIdentity is subid 15 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.15
+ * Description:
+
+                Applicable to RedBox HSR-PRP A and RedBox HSR-PRP B. One ID
+                is used by
+                one pair of RedBoxes (one configured to A and one configured to B)
+                coupling an HSR ring to a PRP network. The integer value states the value
+                of the path field a RedBox inserts into each frame it receives from its
+                interlink and injects into the HSR ring. When interpreted as binary values,
+                the LSB denotes the configuration of the RedBox (A or B), and the following
+                3 bits denote the identifier of a RedBox pair.
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 9/16. Values:  id1a(2), id1b(3), id2a(4), id2b(5), id3a(6), id3b(7), id4a(8), id4b(9), id5a(10), id5b(11), id6a(12), id6b(13), id7a(14), id7b(15)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreRedBoxIdentity_val
+ *        A long containing the new value.
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_INTEGER
+ *    The value is one of  id1a(2), id1b(3), id2a(4), id2b(5), id3a(6), id3b(7), id4a(8), id4b(9), id5a(10), id5b(11), id6a(12), id6b(13), id7a(14), id7b(15)
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lreRedBoxIdentity_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreRedBoxIdentity_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreRedBoxIdentity_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:441:o: |-> Check for valid lreRedBoxIdentity value.
+     */
+
+    return MFD_SUCCESS; /* lreRedBoxIdentity value not illegal */
+} /* lreRedBoxIdentity_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lreRedBoxIdentity_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreRedBoxIdentity_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lreRedBoxIdentity undo.
+     */
+    /*
+     * copy lreRedBoxIdentity data
+     * set rowreq_ctx->undo->lreRedBoxIdentity from rowreq_ctx->data.lreRedBoxIdentity
+     */
+    rowreq_ctx->undo->lreRedBoxIdentity = rowreq_ctx->data.lreRedBoxIdentity;
+
+
+    return MFD_SUCCESS;
+} /* lreRedBoxIdentity_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lreRedBoxIdentity_val
+ *        A long containing the new value.
+ */
+int
+lreRedBoxIdentity_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreRedBoxIdentity_val )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreRedBoxIdentity_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:461:M: |-> Set lreRedBoxIdentity value.
+     * set lreRedBoxIdentity value in rowreq_ctx->data
+     */
+    rowreq_ctx->data.lreRedBoxIdentity = lreRedBoxIdentity_val;
+
+    return MFD_SUCCESS;
+} /* lreRedBoxIdentity_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lreRedBoxIdentity_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreRedBoxIdentity_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lreRedBoxIdentity undo.
+     */
+    /*
+     * copy lreRedBoxIdentity data
+     * set rowreq_ctx->data.lreRedBoxIdentity from rowreq_ctx->undo->lreRedBoxIdentity
+     */
+    rowreq_ctx->data.lreRedBoxIdentity = rowreq_ctx->undo->lreRedBoxIdentity;
+
+
+    return MFD_SUCCESS;
+} /* lreRedBoxIdentity_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreEvaluateSupervision
+ * lreEvaluateSupervision is subid 16 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.16
+ * Description:
+
+                True if the LRE evaluates received supervision frames. False
+                if it
+                drops the supervision frames without evaluating. Note: LREs are required
+                to send supervision frames, but reception is optional. Default value is dependent
+                on implementation.
+
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  true(1), false(2)
+ *
+ * Its syntax is TruthValue (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreEvaluateSupervision_val
+ *        A long containing the new value.
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_INTEGER
+ *    The value is one of  true(1), false(2)
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lreEvaluateSupervision_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreEvaluateSupervision_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreEvaluateSupervision_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:441:o: |-> Check for valid lreEvaluateSupervision value.
+     */
+
+    return MFD_SUCCESS; /* lreEvaluateSupervision value not illegal */
+} /* lreEvaluateSupervision_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lreEvaluateSupervision_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreEvaluateSupervision_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lreEvaluateSupervision undo.
+     */
+    /*
+     * copy lreEvaluateSupervision data
+     * set rowreq_ctx->undo->lreEvaluateSupervision from rowreq_ctx->data.lreEvaluateSupervision
+     */
+    rowreq_ctx->undo->lreEvaluateSupervision = rowreq_ctx->data.lreEvaluateSupervision;
+
+
+    return MFD_SUCCESS;
+} /* lreEvaluateSupervision_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lreEvaluateSupervision_val
+ *        A long containing the new value.
+ */
+int
+lreEvaluateSupervision_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreEvaluateSupervision_val )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreEvaluateSupervision_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:461:M: |-> Set lreEvaluateSupervision value.
+     * set lreEvaluateSupervision value in rowreq_ctx->data
+     */
+    rowreq_ctx->data.lreEvaluateSupervision = lreEvaluateSupervision_val;
+
+    return MFD_SUCCESS;
+} /* lreEvaluateSupervision_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lreEvaluateSupervision_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreEvaluateSupervision_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lreEvaluateSupervision undo.
+     */
+    /*
+     * copy lreEvaluateSupervision data
+     * set rowreq_ctx->data.lreEvaluateSupervision from rowreq_ctx->undo->lreEvaluateSupervision
+     */
+    rowreq_ctx->data.lreEvaluateSupervision = rowreq_ctx->undo->lreEvaluateSupervision;
+
+
+    return MFD_SUCCESS;
+} /* lreEvaluateSupervision_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreNodesTableClear
+ * lreNodesTableClear is subid 17 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.17
+ * Description:
+specifies that the Node Table is to be cleared
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  noOp(0), clearNodeTable(1)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreNodesTableClear_val
+ *        A long containing the new value.
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_INTEGER
+ *    The value is one of  noOp(0), clearNodeTable(1)
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lreNodesTableClear_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreNodesTableClear_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodesTableClear_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:441:o: |-> Check for valid lreNodesTableClear value.
+     */
+
+    return MFD_SUCCESS; /* lreNodesTableClear value not illegal */
+} /* lreNodesTableClear_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lreNodesTableClear_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodesTableClear_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lreNodesTableClear undo.
+     */
+    /*
+     * copy lreNodesTableClear data
+     * set rowreq_ctx->undo->lreNodesTableClear from rowreq_ctx->data.lreNodesTableClear
+     */
+    rowreq_ctx->undo->lreNodesTableClear = rowreq_ctx->data.lreNodesTableClear;
+
+
+    return MFD_SUCCESS;
+} /* lreNodesTableClear_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lreNodesTableClear_val
+ *        A long containing the new value.
+ */
+int
+lreNodesTableClear_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreNodesTableClear_val )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodesTableClear_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:461:M: |-> Set lreNodesTableClear value.
+     * set lreNodesTableClear value in rowreq_ctx->data
+     */
+    rowreq_ctx->data.lreNodesTableClear = lreNodesTableClear_val;
+
+    return MFD_SUCCESS;
+} /* lreNodesTableClear_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lreNodesTableClear_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreNodesTableClear_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lreNodesTableClear undo.
+     */
+    /*
+     * copy lreNodesTableClear data
+     * set rowreq_ctx->data.lreNodesTableClear from rowreq_ctx->undo->lreNodesTableClear
+     */
+    rowreq_ctx->data.lreNodesTableClear = rowreq_ctx->undo->lreNodesTableClear;
+
+
+    return MFD_SUCCESS;
+} /* lreNodesTableClear_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreProxyNodeTableClear
+ * lreProxyNodeTableClear is subid 18 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.18
+ * Description:
+specifies that the Proxy Node Table is to be cleared
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   1
+ *
+ * Enum range: 2/8. Values:  noOp(0), clearProxyNodeTable(1)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreProxyNodeTableClear_val
+ *        A long containing the new value.
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_INTEGER
+ *    The value is one of  noOp(0), clearProxyNodeTable(1)
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lreProxyNodeTableClear_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreProxyNodeTableClear_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreProxyNodeTableClear_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:441:o: |-> Check for valid lreProxyNodeTableClear value.
+     */
+
+    return MFD_SUCCESS; /* lreProxyNodeTableClear value not illegal */
+} /* lreProxyNodeTableClear_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lreProxyNodeTableClear_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreProxyNodeTableClear_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lreProxyNodeTableClear undo.
+     */
+    /*
+     * copy lreProxyNodeTableClear data
+     * set rowreq_ctx->undo->lreProxyNodeTableClear from rowreq_ctx->data.lreProxyNodeTableClear
+     */
+    rowreq_ctx->undo->lreProxyNodeTableClear = rowreq_ctx->data.lreProxyNodeTableClear;
+
+
+    return MFD_SUCCESS;
+} /* lreProxyNodeTableClear_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lreProxyNodeTableClear_val
+ *        A long containing the new value.
+ */
+int
+lreProxyNodeTableClear_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreProxyNodeTableClear_val )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreProxyNodeTableClear_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:461:M: |-> Set lreProxyNodeTableClear value.
+     * set lreProxyNodeTableClear value in rowreq_ctx->data
+     */
+    rowreq_ctx->data.lreProxyNodeTableClear = lreProxyNodeTableClear_val;
+
+    return MFD_SUCCESS;
+} /* lreProxyNodeTableClear_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lreProxyNodeTableClear_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreProxyNodeTableClear_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lreProxyNodeTableClear undo.
+     */
+    /*
+     * copy lreProxyNodeTableClear data
+     * set rowreq_ctx->data.lreProxyNodeTableClear from rowreq_ctx->undo->lreProxyNodeTableClear
+     */
+    rowreq_ctx->data.lreProxyNodeTableClear = rowreq_ctx->undo->lreProxyNodeTableClear;
+
+
+    return MFD_SUCCESS;
+} /* lreProxyNodeTableClear_undo */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceConfigEntry.lreDupListResideMaxTime
+ * lreDupListResideMaxTime is subid 19 of lreInterfaceConfigEntry.
+ * Its status is Current, and its access level is ReadWrite.
+ * OID: .1.0.62439.2.21.0.1.0.1.1.19
+ * Description:
+the longest time an entry may reside in the duplicates list,
+              expressed as the number of seconds multiplied by 65536;
+              the default value is 26214 x 15 us, or 400 ms; too low a value can
+              cause broadcast storms
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 1
+ *   readable   1     iscolumn 1     ranges 0      hashint   1
+ *   settable   1
+ *   defval: 26214
+ *   hint: d
+ *
+ *
+ * Its syntax is SecondFraction (based on perltype INTEGER32)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
+ */
+/**
+ * Check that the proposed new value is potentially valid.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreDupListResideMaxTime_val
+ *        A long containing the new value.
+ *
+ * @retval MFD_SUCCESS        : incoming value is legal
+ * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
+ * @retval MFD_NOT_VALID_EVER : incoming value is never valid
+ *
+ * This is the place to check for requirements that are not
+ * expressed in the mib syntax (for example, a requirement that
+ * is detailed in the description for an object).
+ *
+ * You should check that the requested change between the undo value and the
+ * new value is legal (ie, the transistion from one value to another
+ * is legal).
+ *
+ *@note
+ * This check is only to determine if the new value
+ * is \b potentially valid. This is the first check of many, and
+ * is one of the simplest ones.
+ *
+ *@note
+ * this is not the place to do any checks for values
+ * which depend on some other value in the mib. Those
+ * types of checks should be done in the
+ * lreInterfaceConfigTable_check_dependencies() function.
+ *
+ * The following checks have already been done for you:
+ *    The syntax is ASN_INTEGER
+ *
+ * If there a no other checks you need to do, simply return MFD_SUCCESS.
+ *
+ */
+int
+lreDupListResideMaxTime_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, long lreDupListResideMaxTime_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreDupListResideMaxTime_check_value","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:441:o: |-> Check for valid lreDupListResideMaxTime value.
+     */
+
+    return MFD_SUCCESS; /* lreDupListResideMaxTime value not illegal */
+} /* lreDupListResideMaxTime_check_value */
+
+/**
+ * Save old value information
+ *
+ * @param rowreq_ctx
+ *        Pointer to the table context (lreInterfaceConfigTable_rowreq_ctx)
+ *
+ * @retval MFD_SUCCESS : success
+ * @retval MFD_ERROR   : error. set will fail.
+ *
+ * This function will be called after the table level undo setup function
+ * lreInterfaceConfigTable_undo_setup has been called.
+ *
+ *@note
+ * this function will only be called if a new value is set for this column.
+ *
+ * If there is any setup specific to a particular column (e.g. allocating
+ * memory for a string), you should do that setup in this function, so it
+ * won't be done unless it is necessary.
+ */
+int
+lreDupListResideMaxTime_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreDupListResideMaxTime_undo_setup","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:455:o: |-> Setup lreDupListResideMaxTime undo.
+     */
+    /*
+     * copy lreDupListResideMaxTime data
+     * set rowreq_ctx->undo->lreDupListResideMaxTime from rowreq_ctx->data.lreDupListResideMaxTime
+     */
+    rowreq_ctx->undo->lreDupListResideMaxTime = rowreq_ctx->data.lreDupListResideMaxTime;
+
+
+    return MFD_SUCCESS;
+} /* lreDupListResideMaxTime_undo_setup */
+
+/**
+ * Set the new value.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context. You should know how to
+ *        manipulate the value from this object.
+ * @param lreDupListResideMaxTime_val
+ *        A long containing the new value.
+ */
+int
+lreDupListResideMaxTime_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, long lreDupListResideMaxTime_val )
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreDupListResideMaxTime_set","called\n"));
+
+    /** should never get a NULL pointer */
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:461:M: |-> Set lreDupListResideMaxTime value.
+     * set lreDupListResideMaxTime value in rowreq_ctx->data
+     */
+    rowreq_ctx->data.lreDupListResideMaxTime = lreDupListResideMaxTime_val;
+
+    return MFD_SUCCESS;
+} /* lreDupListResideMaxTime_set */
+
+/**
+ * undo the previous set.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the users context.
+ */
+int
+lreDupListResideMaxTime_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreDupListResideMaxTime_undo","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:456:o: |-> Clean up lreDupListResideMaxTime undo.
+     */
+    /*
+     * copy lreDupListResideMaxTime data
+     * set rowreq_ctx->data.lreDupListResideMaxTime from rowreq_ctx->undo->lreDupListResideMaxTime
+     */
+    rowreq_ctx->data.lreDupListResideMaxTime = rowreq_ctx->undo->lreDupListResideMaxTime;
+
+
+    return MFD_SUCCESS;
+} /* lreDupListResideMaxTime_undo */
+
+/**
+ * check dependencies
+ *
+ * This is useful for for tables which have dependencies between columns
+ * (or rows, or tables). For example, two columns allocating a percentage
+ * of something add up 100%.
+ *
+ * Should you need different behavior depending on which columns were
+ * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
+ * set. The definitions for the COLUMN_*_FLAG bits can be found in
+ * lreInterfaceConfigTable_oids.h.
+ * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
+ *
+ * @retval MFD_SUCCESS all the changes to the row are legal
+ * @retval MFD_ERROR   one or more changes are not legal
+ *
+ * (see README-table-lreInterfaceConfigTable if you don't have dependencies)
+ */
+int
+lreInterfaceConfigTable_check_dependencies(lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    int rc = MFD_SUCCESS;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:lreInterfaceConfigTable_check_dependencies","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:470:o: Check lreInterfaceConfigTable row dependencies.
+     * check that all new value are legal and consistent with each other
+     */
+    /*
+     * check RowStatus dependencies
+     */
+    if (rowreq_ctx->column_set_flags & COLUMN_LREROWSTATUS_FLAG) {
+        /*
+         * check for valid RowStatus transition (old, new)
+         * (Note: move transition check to
+         *  to catch errors earlier)
+         */
+        rc = check_rowstatus_transition( rowreq_ctx->undo->lreRowStatus,
+                                         rowreq_ctx->data.lreRowStatus );
+        if (MFD_SUCCESS != rc)
+            return rc;
+
+        /*
+         * row creation requirements
+         */
+        if (rowreq_ctx->rowreq_flags & MFD_ROW_CREATED) {
+            if (ROWSTATUS_DESTROY ==  rowreq_ctx->data.lreRowStatus) {
+                rowreq_ctx->rowreq_flags |= MFD_ROW_DELETED;
+            }
+            else if (ROWSTATUS_CREATEANDGO ==  rowreq_ctx->data.lreRowStatus) {
+                if ((rowreq_ctx->column_set_flags & LREINTERFACECONFIGTABLE_REQUIRED_COLS)
+                    != LREINTERFACECONFIGTABLE_REQUIRED_COLS) {
+                    DEBUGMSGTL(("lreInterfaceConfigTable",
+                                "required columns missing (0x%0x != 0x%0x)\n",
+                                rowreq_ctx->column_set_flags, LREINTERFACECONFIGTABLE_REQUIRED_COLS));
+                    return MFD_CANNOT_CREATE_NOW;
+                }
+                rowreq_ctx->data.lreRowStatus = ROWSTATUS_ACTIVE;
+            }
+        } /* row creation */
+        else {
+            /*
+             * row change requirements
+             */
+            /*
+             * don't allow a destroy if any other value was changed, since
+             * that might call data access routines with bad info.
+             *
+             * you may or may not require the row be notInService before it
+             * can be destroyed.
+             */
+            if (ROWSTATUS_DESTROY == rowreq_ctx->data.lreRowStatus) {
+                if (rowreq_ctx->column_set_flags & ~COLUMN_LREROWSTATUS_FLAG) {
+                    DEBUGMSGTL(("lreInterfaceConfigTable",
+                                "destroy must be only varbind for row\n"));
+                    return MFD_NOT_VALID_NOW;
+                }
+                rowreq_ctx->rowreq_flags |= MFD_ROW_DELETED;
+
+            } /* row destroy */
+        } /* row change */
+    }
+    else {
+        /*
+         * must have row status to create a row
+         */
+        if (rowreq_ctx->rowreq_flags & MFD_ROW_CREATED) {
+            DEBUGMSGTL(("lreInterfaceConfigTable",
+                        "must use RowStatus to create rows\n"));
+            return MFD_CANNOT_CREATE_NOW;
+        }
+    } /* row status not set */
+
+    if ( MFD_SUCCESS != rc )
+        return rc;
+
+    return rc;
+} /* lreInterfaceConfigTable_check_dependencies */
+
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_set.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_set.h
new file mode 100644
index 0000000..fe2324e
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_data_set.h
@@ -0,0 +1,140 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+#ifndef LREINTERFACECONFIGTABLE_DATA_SET_H
+#define LREINTERFACECONFIGTABLE_DATA_SET_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* *********************************************************************
+ * SET function declarations
+ */
+
+/* *********************************************************************
+ * SET Table declarations
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceConfigTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceConfigTable is subid 1 of lreConfigurationInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.0.1.0.1, length: 9
+*/
+
+
+int lreInterfaceConfigTable_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx);
+int lreInterfaceConfigTable_undo_cleanup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx);
+int lreInterfaceConfigTable_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx);
+int lreInterfaceConfigTable_commit( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx);
+int lreInterfaceConfigTable_undo_commit( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx);
+
+
+int lreRowStatus_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreRowStatus_val);
+int lreRowStatus_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreRowStatus_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreRowStatus_val );
+int lreRowStatus_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreNodeType_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreNodeType_val);
+int lreNodeType_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreNodeType_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreNodeType_val );
+int lreNodeType_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreNodeName_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char *lreNodeName_val_ptr,  size_t lreNodeName_val_ptr_len);
+int lreNodeName_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreNodeName_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char *lreNodeName_val_ptr,  size_t lreNodeName_val_ptr_len );
+int lreNodeName_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreVersionName_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char *lreVersionName_val_ptr,  size_t lreVersionName_val_ptr_len);
+int lreVersionName_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreVersionName_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char *lreVersionName_val_ptr,  size_t lreVersionName_val_ptr_len );
+int lreVersionName_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreMacAddress_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char *lreMacAddress_val_ptr,  size_t lreMacAddress_val_ptr_len);
+int lreMacAddress_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreMacAddress_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, char *lreMacAddress_val_ptr,  size_t lreMacAddress_val_ptr_len );
+int lreMacAddress_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lrePortAdminStateA_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lrePortAdminStateA_val);
+int lrePortAdminStateA_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lrePortAdminStateA_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lrePortAdminStateA_val );
+int lrePortAdminStateA_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lrePortAdminStateB_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lrePortAdminStateB_val);
+int lrePortAdminStateB_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lrePortAdminStateB_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lrePortAdminStateB_val );
+int lrePortAdminStateB_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreLinkStatusA_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreLinkStatusA_val);
+int lreLinkStatusA_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreLinkStatusA_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreLinkStatusA_val );
+int lreLinkStatusA_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreLinkStatusB_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreLinkStatusB_val);
+int lreLinkStatusB_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreLinkStatusB_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreLinkStatusB_val );
+int lreLinkStatusB_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreDuplicateDiscard_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreDuplicateDiscard_val);
+int lreDuplicateDiscard_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreDuplicateDiscard_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreDuplicateDiscard_val );
+int lreDuplicateDiscard_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreTransparentReception_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreTransparentReception_val);
+int lreTransparentReception_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreTransparentReception_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreTransparentReception_val );
+int lreTransparentReception_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreHsrLREMode_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreHsrLREMode_val);
+int lreHsrLREMode_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreHsrLREMode_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreHsrLREMode_val );
+int lreHsrLREMode_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreSwitchingEndNode_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreSwitchingEndNode_val);
+int lreSwitchingEndNode_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreSwitchingEndNode_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreSwitchingEndNode_val );
+int lreSwitchingEndNode_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreRedBoxIdentity_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreRedBoxIdentity_val);
+int lreRedBoxIdentity_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreRedBoxIdentity_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreRedBoxIdentity_val );
+int lreRedBoxIdentity_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreEvaluateSupervision_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreEvaluateSupervision_val);
+int lreEvaluateSupervision_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreEvaluateSupervision_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreEvaluateSupervision_val );
+int lreEvaluateSupervision_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreNodesTableClear_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreNodesTableClear_val);
+int lreNodesTableClear_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreNodesTableClear_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreNodesTableClear_val );
+int lreNodesTableClear_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreProxyNodeTableClear_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreProxyNodeTableClear_val);
+int lreProxyNodeTableClear_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreProxyNodeTableClear_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, u_long lreProxyNodeTableClear_val );
+int lreProxyNodeTableClear_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+int lreDupListResideMaxTime_check_value( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, long lreDupListResideMaxTime_val);
+int lreDupListResideMaxTime_undo_setup( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+int lreDupListResideMaxTime_set( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, long lreDupListResideMaxTime_val );
+int lreDupListResideMaxTime_undo( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx );
+
+
+int lreInterfaceConfigTable_check_dependencies(lreInterfaceConfigTable_rowreq_ctx *ctx);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACECONFIGTABLE_DATA_SET_H */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_enums.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_enums.h
new file mode 100644
index 0000000..5b86a12
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_enums.h
@@ -0,0 +1,290 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  $
+ *
+ * $Id:$
+ */
+#ifndef LREINTERFACECONFIGTABLE_ENUMS_H
+#define LREINTERFACECONFIGTABLE_ENUMS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+ /*
+ * NOTES on enums
+ * ==============
+ *
+ * Value Mapping
+ * -------------
+ * If the values for your data type don't exactly match the
+ * possible values defined by the mib, you should map them
+ * below. For example, a boolean flag (1/0) is usually represented
+ * as a TruthValue in a MIB, which maps to the values (1/2).
+ *
+ */
+/*************************************************************************
+ *************************************************************************
+ *
+ * enum definitions for table lreInterfaceConfigTable
+ *
+ *************************************************************************
+ *************************************************************************/
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lreRowStatus (RowStatus / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef ROWSTATUS_ENUMS
+#define ROWSTATUS_ENUMS
+
+#define ROWSTATUS_ACTIVE  1
+#define ROWSTATUS_NOTINSERVICE  2
+#define ROWSTATUS_NOTREADY  3
+#define ROWSTATUS_CREATEANDGO  4
+#define ROWSTATUS_CREATEANDWAIT  5
+#define ROWSTATUS_DESTROY  6
+
+#endif /* ROWSTATUS_ENUMS */
+
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lreNodeType (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef LRENODETYPE_ENUMS
+#define LRENODETYPE_ENUMS
+
+#define LRENODETYPE_PRPMODE1  1
+#define LRENODETYPE_HSR  2
+
+#endif /* LRENODETYPE_ENUMS */
+
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lrePortAdminStateA (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef LREPORTADMINSTATEA_ENUMS
+#define LREPORTADMINSTATEA_ENUMS
+
+#define LREPORTADMINSTATEA_NOTACTIVE  1
+#define LREPORTADMINSTATEA_ACTIVE  2
+
+#endif /* LREPORTADMINSTATEA_ENUMS */
+
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lrePortAdminStateB (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef LREPORTADMINSTATEB_ENUMS
+#define LREPORTADMINSTATEB_ENUMS
+
+#define LREPORTADMINSTATEB_NOTACTIVE  1
+#define LREPORTADMINSTATEB_ACTIVE  2
+
+#endif /* LREPORTADMINSTATEB_ENUMS */
+
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lreLinkStatusA (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef LRELINKSTATUSA_ENUMS
+#define LRELINKSTATUSA_ENUMS
+
+#define LRELINKSTATUSA_UP  1
+#define LRELINKSTATUSA_DOWN  2
+
+#endif /* LRELINKSTATUSA_ENUMS */
+
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lreLinkStatusB (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef LRELINKSTATUSB_ENUMS
+#define LRELINKSTATUSB_ENUMS
+
+#define LRELINKSTATUSB_UP  1
+#define LRELINKSTATUSB_DOWN  2
+
+#endif /* LRELINKSTATUSB_ENUMS */
+
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lreDuplicateDiscard (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef LREDUPLICATEDISCARD_ENUMS
+#define LREDUPLICATEDISCARD_ENUMS
+
+#define LREDUPLICATEDISCARD_DONOTDISCARD  1
+#define LREDUPLICATEDISCARD_DISCARD  2
+
+#endif /* LREDUPLICATEDISCARD_ENUMS */
+
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lreTransparentReception (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef LRETRANSPARENTRECEPTION_ENUMS
+#define LRETRANSPARENTRECEPTION_ENUMS
+
+#define LRETRANSPARENTRECEPTION_REMOVERCT  1
+#define LRETRANSPARENTRECEPTION_PASSRCT  2
+
+#endif /* LRETRANSPARENTRECEPTION_ENUMS */
+
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lreHsrLREMode (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef LREHSRLREMODE_ENUMS
+#define LREHSRLREMODE_ENUMS
+
+#define LREHSRLREMODE_MODEH  1
+#define LREHSRLREMODE_MODEN  2
+#define LREHSRLREMODE_MODET  3
+#define LREHSRLREMODE_MODEU  4
+#define LREHSRLREMODE_MODEM  5
+#define LREHSRLREMODE_MODEX  6
+
+#endif /* LREHSRLREMODE_ENUMS */
+
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lreSwitchingEndNode (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef LRESWITCHINGENDNODE_ENUMS
+#define LRESWITCHINGENDNODE_ENUMS
+
+#define LRESWITCHINGENDNODE_NONBRIDGINGNODE  1
+#define LRESWITCHINGENDNODE_BRIDGINGUNSPECIFIED  2
+#define LRESWITCHINGENDNODE_PRPNODE  3
+#define LRESWITCHINGENDNODE_HSRREDBOXSAN  4
+#define LRESWITCHINGENDNODE_HSRNODE  5
+#define LRESWITCHINGENDNODE_HSRREDBOXHSR  6
+#define LRESWITCHINGENDNODE_HSRREDBOXPRPA  7
+#define LRESWITCHINGENDNODE_HSRREDBOXPRPB  8
+
+#endif /* LRESWITCHINGENDNODE_ENUMS */
+
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lreRedBoxIdentity (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef LREREDBOXIDENTITY_ENUMS
+#define LREREDBOXIDENTITY_ENUMS
+
+#define LREREDBOXIDENTITY_ID1A  2
+#define LREREDBOXIDENTITY_ID1B  3
+#define LREREDBOXIDENTITY_ID2A  4
+#define LREREDBOXIDENTITY_ID2B  5
+#define LREREDBOXIDENTITY_ID3A  6
+#define LREREDBOXIDENTITY_ID3B  7
+#define LREREDBOXIDENTITY_ID4A  8
+#define LREREDBOXIDENTITY_ID4B  9
+#define LREREDBOXIDENTITY_ID5A  10
+#define LREREDBOXIDENTITY_ID5B  11
+#define LREREDBOXIDENTITY_ID6A  12
+#define LREREDBOXIDENTITY_ID6B  13
+#define LREREDBOXIDENTITY_ID7A  14
+#define LREREDBOXIDENTITY_ID7B  15
+
+#endif /* LREREDBOXIDENTITY_ENUMS */
+
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lreEvaluateSupervision (TruthValue / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef TRUTHVALUE_ENUMS
+#define TRUTHVALUE_ENUMS
+
+#define TRUTHVALUE_TRUE  1
+#define TRUTHVALUE_FALSE  2
+
+#endif /* TRUTHVALUE_ENUMS */
+
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lreNodesTableClear (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef LRENODESTABLECLEAR_ENUMS
+#define LRENODESTABLECLEAR_ENUMS
+
+#define LRENODESTABLECLEAR_NOOP  0
+#define LRENODESTABLECLEAR_CLEARNODETABLE  1
+
+#endif /* LRENODESTABLECLEAR_ENUMS */
+
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lreProxyNodeTableClear (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef LREPROXYNODETABLECLEAR_ENUMS
+#define LREPROXYNODETABLECLEAR_ENUMS
+
+#define LREPROXYNODETABLECLEAR_NOOP  0
+#define LREPROXYNODETABLECLEAR_CLEARPROXYNODETABLE  1
+
+#endif /* LREPROXYNODETABLECLEAR_ENUMS */
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACECONFIGTABLE_ENUMS_H */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_interface.c b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_interface.c
new file mode 100644
index 0000000..bf42819
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_interface.c
@@ -0,0 +1,2913 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+/*
+ * *********************************************************************
+ * *********************************************************************
+ * *********************************************************************
+ * ***                                                               ***
+ * ***  NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE  ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***       THIS FILE DOES NOT CONTAIN ANY USER EDITABLE CODE.      ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***       THE GENERATED CODE IS INTERNAL IMPLEMENTATION, AND      ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***    IS SUBJECT TO CHANGE WITHOUT WARNING IN FUTURE RELEASES.   ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * *********************************************************************
+ * *********************************************************************
+ * *********************************************************************
+ */
+
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreInterfaceConfigTable.h"
+
+
+#include <net-snmp/agent/table_container.h>
+#include <net-snmp/library/container.h>
+
+#include "lreInterfaceConfigTable_interface.h"
+
+netsnmp_feature_require(baby_steps)
+netsnmp_feature_require(row_merge)
+netsnmp_feature_require(check_all_requests_error)
+
+#include <ctype.h>
+
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceConfigTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceConfigTable is subid 1 of lreConfigurationInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.0.1.0.1, length: 9
+*/
+typedef struct lreInterfaceConfigTable_interface_ctx_s {
+
+   netsnmp_container              *container;
+   netsnmp_cache                  *cache;
+
+   lreInterfaceConfigTable_registration *      user_ctx;
+
+   netsnmp_table_registration_info  tbl_info;
+
+   netsnmp_baby_steps_access_methods access_multiplexer;
+
+    u_int                             table_dirty;
+
+} lreInterfaceConfigTable_interface_ctx;
+
+static lreInterfaceConfigTable_interface_ctx lreInterfaceConfigTable_if_ctx;
+
+static void _lreInterfaceConfigTable_container_init(
+    lreInterfaceConfigTable_interface_ctx *if_ctx);
+static void _lreInterfaceConfigTable_container_shutdown(
+    lreInterfaceConfigTable_interface_ctx *if_ctx);
+
+
+netsnmp_container *
+lreInterfaceConfigTable_container_get( void )
+{
+    return lreInterfaceConfigTable_if_ctx.container;
+}
+
+lreInterfaceConfigTable_registration *
+lreInterfaceConfigTable_registration_get( void )
+{
+    return lreInterfaceConfigTable_if_ctx.user_ctx;
+}
+
+lreInterfaceConfigTable_registration *
+lreInterfaceConfigTable_registration_set( lreInterfaceConfigTable_registration * newreg )
+{
+    lreInterfaceConfigTable_registration * old = lreInterfaceConfigTable_if_ctx.user_ctx;
+    lreInterfaceConfigTable_if_ctx.user_ctx = newreg;
+    return old;
+}
+
+int
+lreInterfaceConfigTable_container_size( void )
+{
+    return CONTAINER_SIZE(lreInterfaceConfigTable_if_ctx.container);
+}
+
+u_int
+lreInterfaceConfigTable_dirty_get( void )
+{
+    return lreInterfaceConfigTable_if_ctx.table_dirty;
+}
+
+void
+lreInterfaceConfigTable_dirty_set( u_int status )
+{
+    DEBUGMSGTL(("lreInterfaceConfigTable:lreInterfaceConfigTable_dirty_set",
+                "called. was %d, now %d\n",
+                lreInterfaceConfigTable_if_ctx.table_dirty, status));
+    lreInterfaceConfigTable_if_ctx.table_dirty = status;
+}
+
+/*
+ * mfd multiplexer modes
+ */
+static Netsnmp_Node_Handler _mfd_lreInterfaceConfigTable_pre_request;
+static Netsnmp_Node_Handler _mfd_lreInterfaceConfigTable_post_request;
+static Netsnmp_Node_Handler _mfd_lreInterfaceConfigTable_object_lookup;
+static Netsnmp_Node_Handler _mfd_lreInterfaceConfigTable_get_values;
+static Netsnmp_Node_Handler _mfd_lreInterfaceConfigTable_check_objects;
+static Netsnmp_Node_Handler _mfd_lreInterfaceConfigTable_undo_setup;
+static Netsnmp_Node_Handler _mfd_lreInterfaceConfigTable_set_values;
+static Netsnmp_Node_Handler _mfd_lreInterfaceConfigTable_undo_cleanup;
+static Netsnmp_Node_Handler _mfd_lreInterfaceConfigTable_undo_values;
+static Netsnmp_Node_Handler _mfd_lreInterfaceConfigTable_commit;
+static Netsnmp_Node_Handler _mfd_lreInterfaceConfigTable_undo_commit;
+static Netsnmp_Node_Handler _mfd_lreInterfaceConfigTable_irreversible_commit;
+static Netsnmp_Node_Handler _mfd_lreInterfaceConfigTable_check_dependencies;
+
+lreInterfaceConfigTable_data *lreInterfaceConfigTable_allocate_data(void);
+
+/**
+ * @internal
+ * Initialize the table lreInterfaceConfigTable
+ *    (Define its contents and how it's structured)
+ */
+void
+_lreInterfaceConfigTable_initialize_interface(lreInterfaceConfigTable_registration * reg_ptr,  u_long flags)
+{
+    netsnmp_baby_steps_access_methods *access_multiplexer =
+        &lreInterfaceConfigTable_if_ctx.access_multiplexer;
+    netsnmp_table_registration_info *tbl_info = &lreInterfaceConfigTable_if_ctx.tbl_info;
+    netsnmp_handler_registration *reginfo;
+    netsnmp_mib_handler *handler;
+    int    mfd_modes = 0;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_lreInterfaceConfigTable_initialize_interface","called\n"));
+
+
+    /*************************************************
+     *
+     * save interface context for lreInterfaceConfigTable
+     */
+    /*
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(tbl_info,
+                                  ASN_UNSIGNED, /** index: lreInterfaceConfigIndex */
+                             0);
+
+    /*  Define the minimum and maximum accessible columns.  This
+        optimizes retrieval. */
+    tbl_info->min_column = LREINTERFACECONFIGTABLE_MIN_COL;
+    tbl_info->max_column = LREINTERFACECONFIGTABLE_MAX_COL;
+
+    /*
+     * save users context
+     */
+    lreInterfaceConfigTable_if_ctx.user_ctx = reg_ptr;
+
+    /*
+     * call data access initialization code
+     */
+    lreInterfaceConfigTable_init_data(reg_ptr);
+
+    /*
+     * set up the container
+     */
+    _lreInterfaceConfigTable_container_init(&lreInterfaceConfigTable_if_ctx);
+    if (NULL == lreInterfaceConfigTable_if_ctx.container) {
+        snmp_log(LOG_ERR,"could not initialize container for lreInterfaceConfigTable\n");
+        return;
+    }
+
+    /*
+     * access_multiplexer: REQUIRED wrapper for get request handling
+     */
+    access_multiplexer->object_lookup = _mfd_lreInterfaceConfigTable_object_lookup;
+    access_multiplexer->get_values = _mfd_lreInterfaceConfigTable_get_values;
+
+    /*
+     * no wrappers yet
+     */
+    access_multiplexer->pre_request = _mfd_lreInterfaceConfigTable_pre_request;
+    access_multiplexer->post_request = _mfd_lreInterfaceConfigTable_post_request;
+
+#ifndef NETSNMP_DISABLE_SET_SUPPORT
+
+    /*
+     * REQUIRED wrappers for set request handling
+     */
+    access_multiplexer->object_syntax_checks = _mfd_lreInterfaceConfigTable_check_objects;
+    access_multiplexer->undo_setup = _mfd_lreInterfaceConfigTable_undo_setup;
+    access_multiplexer->undo_cleanup = _mfd_lreInterfaceConfigTable_undo_cleanup;
+    access_multiplexer->set_values = _mfd_lreInterfaceConfigTable_set_values;
+    access_multiplexer->undo_sets = _mfd_lreInterfaceConfigTable_undo_values;
+
+    /*
+     * no wrappers yet
+     */
+    access_multiplexer->commit = _mfd_lreInterfaceConfigTable_commit;
+    access_multiplexer->undo_commit = _mfd_lreInterfaceConfigTable_undo_commit;
+    access_multiplexer->irreversible_commit = _mfd_lreInterfaceConfigTable_irreversible_commit;
+
+    /*
+     * REQUIRED for tables with dependencies
+     */
+    access_multiplexer->consistency_checks = _mfd_lreInterfaceConfigTable_check_dependencies;
+#endif
+
+    /*************************************************
+     *
+     * Create a registration, save our reg data, register table.
+     */
+    DEBUGMSGTL(("lreInterfaceConfigTable:init_lreInterfaceConfigTable",
+                "Registering lreInterfaceConfigTable as a mibs-for-dummies table.\n"));
+    handler = netsnmp_baby_steps_access_multiplexer_get(access_multiplexer);
+    reginfo = netsnmp_handler_registration_create("lreInterfaceConfigTable", handler,
+                                                  lreInterfaceConfigTable_oid,
+                                                  lreInterfaceConfigTable_oid_size,
+                                                  HANDLER_CAN_BABY_STEP |
+#if !(defined(NETSNMP_NO_WRITE_SUPPORT) || defined(NETSNMP_DISABLE_SET_SUPPORT))
+                                                  HANDLER_CAN_RONLY
+#else
+                                                  HANDLER_CAN_RWRITE
+#endif /* NETSNMP_NO_WRITE_SUPPORT || NETSNMP_DISABLE_SET_SUPPORT */
+                                                  );
+    if(NULL == reginfo) {
+        snmp_log(LOG_ERR,"error registering table lreInterfaceConfigTable\n");
+        return;
+    }
+    reginfo->my_reg_void = &lreInterfaceConfigTable_if_ctx;
+
+    /*************************************************
+     *
+     * set up baby steps handler, create it and inject it
+     */
+    if( access_multiplexer->object_lookup )
+        mfd_modes |= BABY_STEP_OBJECT_LOOKUP;
+    if( access_multiplexer->pre_request )
+        mfd_modes |= BABY_STEP_PRE_REQUEST;
+    if( access_multiplexer->post_request )
+        mfd_modes |= BABY_STEP_POST_REQUEST;
+
+#if !(defined(NETSNMP_NO_WRITE_SUPPORT) || defined(NETSNMP_DISABLE_SET_SUPPORT))
+    if( access_multiplexer->set_values )
+        mfd_modes |= BABY_STEP_SET_VALUES;
+    if( access_multiplexer->irreversible_commit )
+        mfd_modes |= BABY_STEP_IRREVERSIBLE_COMMIT;
+    if( access_multiplexer->object_syntax_checks )
+        mfd_modes |= BABY_STEP_CHECK_OBJECT;
+
+    if( access_multiplexer->undo_setup )
+        mfd_modes |= BABY_STEP_UNDO_SETUP;
+    if( access_multiplexer->undo_cleanup )
+        mfd_modes |= BABY_STEP_UNDO_CLEANUP;
+    if( access_multiplexer->undo_sets )
+        mfd_modes |= BABY_STEP_UNDO_SETS;
+
+    if( access_multiplexer->row_creation )
+        mfd_modes |= BABY_STEP_ROW_CREATE;
+    if( access_multiplexer->consistency_checks )
+        mfd_modes |= BABY_STEP_CHECK_CONSISTENCY;
+    if( access_multiplexer->commit )
+        mfd_modes |= BABY_STEP_COMMIT;
+    if( access_multiplexer->undo_commit )
+        mfd_modes |= BABY_STEP_UNDO_COMMIT;
+#endif /* NETSNMP_NO_WRITE_SUPPORT || NETSNMP_DISABLE_SET_SUPPORT */
+
+    handler = netsnmp_baby_steps_handler_get(mfd_modes);
+    netsnmp_inject_handler(reginfo, handler);
+
+    /*************************************************
+     *
+     * inject row_merge helper with prefix rootoid_len + 2 (entry.col)
+     */
+    handler = netsnmp_get_row_merge_handler(reginfo->rootoid_len + 2);
+    netsnmp_inject_handler(reginfo, handler);
+
+    /*************************************************
+     *
+     * inject container_table helper
+     */
+    handler =
+        netsnmp_container_table_handler_get(tbl_info,
+                                            lreInterfaceConfigTable_if_ctx.container,
+                                            TABLE_CONTAINER_KEY_NETSNMP_INDEX);
+    netsnmp_inject_handler( reginfo, handler );
+
+    /*************************************************
+     *
+     * inject cache helper
+     */
+    if(NULL != lreInterfaceConfigTable_if_ctx.cache) {
+        handler = netsnmp_cache_handler_get(lreInterfaceConfigTable_if_ctx.cache);
+        netsnmp_inject_handler( reginfo, handler );
+    }
+
+    /*
+     * register table
+     */
+    netsnmp_register_table(reginfo, tbl_info);
+
+    /*
+     * register config/persistence callbacks
+     */
+    lreInterfaceConfigTable_container_init_persistence(lreInterfaceConfigTable_if_ctx.container);
+
+} /* _lreInterfaceConfigTable_initialize_interface */
+
+/**
+ * @internal
+ * Shutdown the table lreInterfaceConfigTable
+ */
+void
+_lreInterfaceConfigTable_shutdown_interface(lreInterfaceConfigTable_registration * reg_ptr)
+{
+    /*
+     * shutdown the container
+     */
+    _lreInterfaceConfigTable_container_shutdown(&lreInterfaceConfigTable_if_ctx);
+}
+
+void
+lreInterfaceConfigTable_valid_columns_set(netsnmp_column_info *vc)
+{
+    lreInterfaceConfigTable_if_ctx.tbl_info.valid_columns = vc;
+} /* lreInterfaceConfigTable_valid_columns_set */
+
+/**
+ * @internal
+ * convert the index component stored in the context to an oid
+ */
+int
+lreInterfaceConfigTable_index_to_oid(netsnmp_index *oid_idx,
+                         lreInterfaceConfigTable_mib_index *mib_idx)
+{
+    int err = SNMP_ERR_NOERROR;
+
+    /*
+     * temp storage for parsing indexes
+     */
+    /*
+     * lreInterfaceConfigIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+     */
+    netsnmp_variable_list var_lreInterfaceConfigIndex;
+
+    /*
+     * set up varbinds
+     */
+    memset( &var_lreInterfaceConfigIndex, 0x00, sizeof(var_lreInterfaceConfigIndex) );
+    var_lreInterfaceConfigIndex.type = ASN_UNSIGNED;
+
+    /*
+     * chain temp index varbinds together
+     */
+    var_lreInterfaceConfigIndex.next_variable =  NULL;
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_index_to_oid","called\n"));
+
+        /* lreInterfaceConfigIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h */
+    snmp_set_var_value(&var_lreInterfaceConfigIndex, &mib_idx->lreInterfaceConfigIndex, sizeof(mib_idx->lreInterfaceConfigIndex));
+
+
+    err = build_oid_noalloc(oid_idx->oids, oid_idx->len, &oid_idx->len,
+                           NULL, 0, &var_lreInterfaceConfigIndex);
+    if(err)
+        snmp_log(LOG_ERR,"error %d converting index to oid\n", err);
+
+    /*
+     * parsing may have allocated memory. free it.
+     */
+    snmp_reset_var_buffers( &var_lreInterfaceConfigIndex );
+
+    return err;
+} /* lreInterfaceConfigTable_index_to_oid */
+
+/**
+ * extract lreInterfaceConfigTable indexes from a netsnmp_index
+ *
+ * @retval SNMP_ERR_NOERROR  : no error
+ * @retval SNMP_ERR_GENERR   : error
+ */
+int
+lreInterfaceConfigTable_index_from_oid(netsnmp_index *oid_idx,
+                         lreInterfaceConfigTable_mib_index *mib_idx)
+{
+    int err = SNMP_ERR_NOERROR;
+
+    /*
+     * temp storage for parsing indexes
+     */
+    /*
+     * lreInterfaceConfigIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+     */
+    netsnmp_variable_list var_lreInterfaceConfigIndex;
+
+    /*
+     * set up varbinds
+     */
+    memset( &var_lreInterfaceConfigIndex, 0x00, sizeof(var_lreInterfaceConfigIndex) );
+    var_lreInterfaceConfigIndex.type = ASN_UNSIGNED;
+
+    /*
+     * chain temp index varbinds together
+     */
+    var_lreInterfaceConfigIndex.next_variable =  NULL;
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_index_from_oid","called\n"));
+
+    /*
+     * parse the oid into the individual index components
+     */
+    err = parse_oid_indexes( oid_idx->oids, oid_idx->len,
+                             &var_lreInterfaceConfigIndex );
+    if (err == SNMP_ERR_NOERROR) {
+        /*
+         * copy out values
+         */
+    mib_idx->lreInterfaceConfigIndex = *((u_long *)var_lreInterfaceConfigIndex.val.string);
+
+
+    }
+
+    /*
+     * parsing may have allocated memory. free it.
+     */
+    snmp_reset_var_buffers( &var_lreInterfaceConfigIndex );
+
+    return err;
+} /* lreInterfaceConfigTable_index_from_oid */
+
+
+/*
+ * lreInterfaceConfigTable_allocate_data
+ *
+ * Purpose: create new lreInterfaceConfigTable_data.
+ */
+lreInterfaceConfigTable_data *
+lreInterfaceConfigTable_allocate_data(void)
+{
+    lreInterfaceConfigTable_data *rtn = SNMP_MALLOC_TYPEDEF(lreInterfaceConfigTable_data);
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_allocate_data","called\n"));
+
+    if(NULL == rtn) {
+        snmp_log(LOG_ERR, "unable to malloc memory for new "
+                 "lreInterfaceConfigTable_data.\n");
+    }
+
+    return rtn;
+} /* lreInterfaceConfigTable_allocate_data */
+
+/*
+ * lreInterfaceConfigTable_release_data
+ *
+ * Purpose: release lreInterfaceConfigTable data.
+ */
+void
+lreInterfaceConfigTable_release_data(lreInterfaceConfigTable_data *data)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:lreInterfaceConfigTable_release_data","called\n"));
+
+    free(data);
+} /* lreInterfaceConfigTable_release_data */
+
+/* *********************************************************************
+ * @internal
+ * allocate resources for a lreInterfaceConfigTable_rowreq_ctx
+ */
+lreInterfaceConfigTable_rowreq_ctx *
+lreInterfaceConfigTable_allocate_rowreq_ctx(void *user_init_ctx)
+{
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx =
+                  SNMP_MALLOC_TYPEDEF(lreInterfaceConfigTable_rowreq_ctx);
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:lreInterfaceConfigTable_allocate_rowreq_ctx","called\n"));
+
+    if(NULL == rowreq_ctx) {
+        snmp_log(LOG_ERR,"Couldn't allocate memory for a "
+                 "lreInterfaceConfigTable_rowreq_ctx.\n");
+        return NULL;
+    }
+
+    rowreq_ctx->oid_idx.oids = rowreq_ctx->oid_tmp;
+
+    rowreq_ctx->lreInterfaceConfigTable_data_list = NULL;
+
+    /*
+     * if we allocated data, call init routine
+     */
+    if (!(rowreq_ctx->rowreq_flags & MFD_ROW_DATA_FROM_USER)) {
+        if(SNMPERR_SUCCESS !=
+            lreInterfaceConfigTable_rowreq_ctx_init(rowreq_ctx, user_init_ctx)) {
+           lreInterfaceConfigTable_release_rowreq_ctx(rowreq_ctx);
+           rowreq_ctx = NULL;
+        }
+    }
+
+    return rowreq_ctx;
+} /* lreInterfaceConfigTable_allocate_rowreq_ctx */
+
+/*
+ * @internal
+ * release resources for a lreInterfaceConfigTable_rowreq_ctx
+ */
+void
+lreInterfaceConfigTable_release_rowreq_ctx(lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:lreInterfaceConfigTable_release_rowreq_ctx","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    lreInterfaceConfigTable_rowreq_ctx_cleanup(rowreq_ctx);
+
+    if(rowreq_ctx->undo)
+        lreInterfaceConfigTable_release_data(rowreq_ctx->undo);
+
+    /*
+     * free index oid pointer
+     */
+    if(rowreq_ctx->oid_idx.oids != rowreq_ctx->oid_tmp)
+        free(rowreq_ctx->oid_idx.oids);
+
+    SNMP_FREE(rowreq_ctx);
+} /* lreInterfaceConfigTable_release_rowreq_ctx */
+
+/**
+ * @internal
+ * wrapper
+ */
+static int
+_mfd_lreInterfaceConfigTable_pre_request(netsnmp_mib_handler *handler,
+                            netsnmp_handler_registration *reginfo,
+                            netsnmp_agent_request_info *agtreq_info,
+                            netsnmp_request_info *requests)
+{
+    int rc;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_pre_request",
+                "called\n"));
+
+    if (1 != netsnmp_row_merge_status_first(reginfo, agtreq_info)) {
+        DEBUGMSGTL(("internal:lreInterfaceConfigTable",
+                    "skipping additional pre_request\n"));
+        return SNMP_ERR_NOERROR;
+    }
+
+    rc = lreInterfaceConfigTable_pre_request(lreInterfaceConfigTable_if_ctx.user_ctx);
+    if (MFD_SUCCESS != rc) {
+        /*
+         * nothing we can do about it but log it
+         */
+        DEBUGMSGTL(("lreInterfaceConfigTable","error %d from "
+                    "lreInterfaceConfigTable_pre_request\n", rc));
+        netsnmp_request_set_error_all(requests, SNMP_VALIDATE_ERR(rc));
+    }
+
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceConfigTable_pre_request */
+
+/**
+ * @internal
+ * wrapper
+ */
+static int
+_mfd_lreInterfaceConfigTable_post_request(netsnmp_mib_handler *handler,
+                             netsnmp_handler_registration *reginfo,
+                             netsnmp_agent_request_info *agtreq_info,
+                             netsnmp_request_info *requests)
+{
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx = (lreInterfaceConfigTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+    int rc, packet_rc;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_post_request",
+                "called\n"));
+
+    /*
+     * release row context, if deleted
+     */
+    if (rowreq_ctx && (rowreq_ctx->rowreq_flags & MFD_ROW_DELETED))
+        lreInterfaceConfigTable_release_rowreq_ctx(rowreq_ctx);
+
+    /*
+     * wait for last call before calling user
+     */
+    if (1 != netsnmp_row_merge_status_last(reginfo, agtreq_info)) {
+        DEBUGMSGTL(("internal:lreInterfaceConfigTable",
+                    "waiting for last post_request\n"));
+        return SNMP_ERR_NOERROR;
+    }
+
+    packet_rc = netsnmp_check_all_requests_error(agtreq_info->asp, 0);
+    if ((MFD_SUCCESS != packet_rc) && lreInterfaceConfigTable_dirty_get()) {
+        /*
+         * we shouldn't get here. the undo steps should also clear
+         * the dirty flags.
+         */
+        snmp_log(LOG_WARNING, "lreInterfaceConfigTable dirty flag set in post_request "
+                 "but status != SUCCESS.\n");
+    }
+
+    rc = lreInterfaceConfigTable_post_request(lreInterfaceConfigTable_if_ctx.user_ctx,packet_rc);
+    if (MFD_SUCCESS != rc) {
+        /*
+         * nothing we can do about it but log it
+         */
+        DEBUGMSGTL(("lreInterfaceConfigTable","error %d from "
+                    "lreInterfaceConfigTable_post_request\n", rc));
+    }
+
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceConfigTable_post_request */
+
+NETSNMP_STATIC_INLINE int
+_lreInterfaceConfigTable_check_indexes(lreInterfaceConfigTable_rowreq_ctx * rowreq_ctx)
+{
+    int                          rc = SNMPERR_SUCCESS;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_lreInterfaceConfigTable_check_indexes","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+
+    /* (INDEX) lreInterfaceConfigIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h */
+       if (MFD_SUCCESS != rc)
+          return rc;
+        rc = lreInterfaceConfigIndex_check_index( rowreq_ctx );
+       if(MFD_SUCCESS != rc)
+           return SNMP_ERR_NOCREATION;
+
+    /*
+     * if individual parts look ok, check them as a whole
+     */
+    return lreInterfaceConfigTable_validate_index( lreInterfaceConfigTable_if_ctx.user_ctx, rowreq_ctx );
+} /* _lreInterfaceConfigTable_check_indexes */
+/**
+ * @internal
+ * wrapper
+ */
+static lreInterfaceConfigTable_rowreq_ctx *
+_mfd_lreInterfaceConfigTable_rowreq_from_index(netsnmp_index *oid_idx, int * rc_ptr)
+{
+    lreInterfaceConfigTable_rowreq_ctx * rowreq_ctx;
+    lreInterfaceConfigTable_mib_index mib_idx;
+    int rc;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_rowreq_from_index",
+                "called\n"));
+
+    if (NULL == rc_ptr)
+        rc_ptr = &rc;
+    *rc_ptr = MFD_SUCCESS;
+
+    memset(&mib_idx, 0x0, sizeof(mib_idx));
+
+    /*
+     * try to parse oid
+     */
+    *rc_ptr = lreInterfaceConfigTable_index_from_oid(oid_idx, &mib_idx);
+    if(MFD_SUCCESS != *rc_ptr) {
+        DEBUGMSGT(("lreInterfaceConfigTable", "error parsing index\n"));
+        return NULL;
+    }
+
+    /*
+     * allocate new context
+     */
+    rowreq_ctx = lreInterfaceConfigTable_allocate_rowreq_ctx(NULL);
+    if (NULL == rowreq_ctx) {
+        *rc_ptr = MFD_ERROR;
+        return NULL; /* msg already logged */
+    }
+
+    memcpy(&rowreq_ctx->tbl_idx, &mib_idx, sizeof(mib_idx));
+
+    /*
+     * check indexes
+     */
+    *rc_ptr = _lreInterfaceConfigTable_check_indexes(rowreq_ctx);
+    if(MFD_SUCCESS != *rc_ptr) {
+        netsnmp_assert((*rc_ptr == SNMP_ERR_NOCREATION) ||
+                       (*rc_ptr == SNMP_ERR_INCONSISTENTNAME));
+        lreInterfaceConfigTable_release_rowreq_ctx(rowreq_ctx);
+        return NULL;
+    }
+
+    /*
+     * copy indexes
+     */
+    rowreq_ctx->oid_idx.len = oid_idx->len;
+    memcpy(rowreq_ctx->oid_idx.oids, oid_idx->oids, oid_idx->len * sizeof(oid));
+
+    return rowreq_ctx;
+} /* _mfd_lreInterfaceConfigTable_rowreq_from_index */
+
+
+/**
+ * @internal
+ * wrapper
+ */
+static int
+_mfd_lreInterfaceConfigTable_object_lookup(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    int                    rc = SNMP_ERR_NOERROR;
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx = (lreInterfaceConfigTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_object_lookup","called\n"));
+
+    /*
+     * get our context from mfd
+     * lreInterfaceConfigTable_interface_ctx *if_ctx =
+     *             (lreInterfaceConfigTable_interface_ctx *)reginfo->my_reg_void;
+     */
+
+    if(NULL == rowreq_ctx) {
+        netsnmp_table_request_info *tblreq_info;
+        netsnmp_index oid_idx;
+
+        tblreq_info = netsnmp_extract_table_info(requests);
+        if(NULL == tblreq_info) {
+            snmp_log(LOG_ERR, "request had no table info\n");
+            return MFD_ERROR;
+        }
+
+        /*
+         * try create rowreq
+         */
+        oid_idx.oids = tblreq_info->index_oid;
+        oid_idx.len = tblreq_info->index_oid_len;
+
+        rowreq_ctx = _mfd_lreInterfaceConfigTable_rowreq_from_index(&oid_idx, &rc);
+        if(MFD_SUCCESS == rc) {
+            netsnmp_assert(NULL != rowreq_ctx);
+            rowreq_ctx->rowreq_flags |= MFD_ROW_CREATED;
+            /*
+             * add rowreq_ctx to request data lists
+             */
+            netsnmp_container_table_row_insert(requests, (netsnmp_index*)rowreq_ctx);
+        }
+    }
+
+    if (MFD_SUCCESS != rc)
+        netsnmp_request_set_error_all(requests, rc);
+    else
+        lreInterfaceConfigTable_row_prep(rowreq_ctx);
+
+    return SNMP_VALIDATE_ERR(rc);
+} /* _mfd_lreInterfaceConfigTable_object_lookup */
+
+/***********************************************************************
+ *
+ * GET processing
+ *
+ ***********************************************************************/
+/*
+ * @internal
+ * Retrieve the value for a particular column
+ */
+NETSNMP_STATIC_INLINE int
+_lreInterfaceConfigTable_get_column( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx,
+                       netsnmp_variable_list *var, int column )
+{
+    int rc = SNMPERR_SUCCESS;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_get_column",
+                "called for %d\n", column));
+
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    switch(column) {
+
+    /* lreRowStatus(2)/RowStatus/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREROWSTATUS:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lreRowStatus_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreNodeType(3)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRENODETYPE:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lreNodeType_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreNodeName(4)/DisplayString/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H */
+    case COLUMN_LRENODENAME:
+    var->type = ASN_OCTET_STR;
+rc = lreNodeName_get(rowreq_ctx, (char **)&var->val.string, &var->val_len );
+        break;
+
+    /* lreVersionName(5)/OCTETSTR/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/h */
+    case COLUMN_LREVERSIONNAME:
+    var->type = ASN_OCTET_STR;
+rc = lreVersionName_get(rowreq_ctx, (char **)&var->val.string, &var->val_len );
+        break;
+
+    /* lreMacAddress(6)/MacAddress/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H */
+    case COLUMN_LREMACADDRESS:
+    var->type = ASN_OCTET_STR;
+rc = lreMacAddress_get(rowreq_ctx, (char **)&var->val.string, &var->val_len );
+        break;
+
+    /* lrePortAdminStateA(7)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPORTADMINSTATEA:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lrePortAdminStateA_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lrePortAdminStateB(8)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPORTADMINSTATEB:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lrePortAdminStateB_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreLinkStatusA(9)/INTEGER/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h */
+    case COLUMN_LRELINKSTATUSA:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lreLinkStatusA_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreLinkStatusB(10)/INTEGER/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h */
+    case COLUMN_LRELINKSTATUSB:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lreLinkStatusB_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreDuplicateDiscard(11)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREDUPLICATEDISCARD:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lreDuplicateDiscard_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreTransparentReception(12)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRETRANSPARENTRECEPTION:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lreTransparentReception_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreHsrLREMode(13)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREHSRLREMODE:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lreHsrLREMode_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreSwitchingEndNode(14)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRESWITCHINGENDNODE:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lreSwitchingEndNode_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreRedBoxIdentity(15)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREREDBOXIDENTITY:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lreRedBoxIdentity_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreEvaluateSupervision(16)/TruthValue/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREEVALUATESUPERVISION:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lreEvaluateSupervision_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreNodesTableClear(17)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRENODESTABLECLEAR:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lreNodesTableClear_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreProxyNodeTableClear(18)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPROXYNODETABLECLEAR:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lreProxyNodeTableClear_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreDupListResideMaxTime(19)/SecondFraction/ASN_INTEGER/long(long)//l/A/W/e/r/D/H */
+    case COLUMN_LREDUPLISTRESIDEMAXTIME:
+    var->val_len = sizeof(long);
+    var->type = ASN_INTEGER;
+rc = lreDupListResideMaxTime_get(rowreq_ctx, (long *)var->val.string );
+        break;
+
+     default:
+        if (LREINTERFACECONFIGTABLE_MIN_COL <= column && column <= LREINTERFACECONFIGTABLE_MAX_COL) {
+            DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_get_column",
+                "assume column %d is reserved\n", column));
+            rc = MFD_SKIP;
+        } else {
+            snmp_log(LOG_ERR,
+                "unknown column %d in _lreInterfaceConfigTable_get_column\n", column);
+        }
+        break;
+    }
+
+    return rc;
+} /* _lreInterfaceConfigTable_get_column */
+
+int
+_mfd_lreInterfaceConfigTable_get_values(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx = (lreInterfaceConfigTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+    netsnmp_table_request_info * tri;
+    u_char                     * old_string;
+    void                      (*dataFreeHook)(void *);
+    int                        rc;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_get_values","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    for(;requests; requests = requests->next) {
+        /*
+         * save old pointer, so we can free it if replaced
+         */
+        old_string = requests->requestvb->val.string;
+        dataFreeHook = requests->requestvb->dataFreeHook;
+        if(NULL == requests->requestvb->val.string) {
+            requests->requestvb->val.string = requests->requestvb->buf;
+            requests->requestvb->val_len = sizeof(requests->requestvb->buf);
+        }
+        else if(requests->requestvb->buf == requests->requestvb->val.string) {
+            if(requests->requestvb->val_len != sizeof(requests->requestvb->buf))
+                requests->requestvb->val_len = sizeof(requests->requestvb->buf);
+        }
+
+        /*
+         * get column data
+         */
+        tri = netsnmp_extract_table_info(requests);
+        if(NULL == tri)
+            continue;
+
+        rc = _lreInterfaceConfigTable_get_column(rowreq_ctx, requests->requestvb, tri->colnum);
+        if(rc) {
+            if(MFD_SKIP == rc) {
+                requests->requestvb->type = SNMP_NOSUCHINSTANCE;
+                rc = SNMP_ERR_NOERROR;
+            }
+        }
+        else if (NULL == requests->requestvb->val.string) {
+            snmp_log(LOG_ERR,"NULL varbind data pointer!\n");
+            rc = SNMP_ERR_GENERR;
+        }
+        if(rc)
+            netsnmp_request_set_error(requests, SNMP_VALIDATE_ERR(rc));
+
+        /*
+         * if the buffer wasn't used previously for the old data (i.e. it
+         * was allcoated memory)  and the get routine replaced the pointer,
+         * we need to free the previous pointer.
+         */
+        if(old_string && (old_string != requests->requestvb->buf) &&
+           (requests->requestvb->val.string != old_string)) {
+            if(dataFreeHook)
+                (*dataFreeHook)(old_string);
+            else
+                free(old_string);
+        }
+    } /* for results */
+
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceConfigTable_get_values */
+
+/***********************************************************************
+ *
+ * SET processing
+ *
+ ***********************************************************************/
+
+/*----------------------------------------------------------------------
+ *
+ * SET: Syntax checks
+ *
+ *---------------------------------------------------------------------*/
+/*
+ * @internal
+ * Check the syntax for a particular column
+ */
+NETSNMP_STATIC_INLINE int
+_lreInterfaceConfigTable_check_column( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx,
+                         netsnmp_variable_list *var, int column )
+{
+    int rc = SNMPERR_SUCCESS;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column",
+                "called for %d\n", column));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    switch(column) {
+    /* (INDEX) lreInterfaceConfigIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h */
+    case COLUMN_LREINTERFACECONFIGINDEX:
+        rc = SNMP_ERR_NOTWRITABLE; /* can not change index of active row */
+        break;
+
+    /* lreRowStatus(2)/RowStatus/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREROWSTATUS:
+rc = netsnmp_check_vb_rowstatus_value(var);
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lreRowStatus",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lreRowStatus_check_value( rowreq_ctx, *((u_long *)var->val.string) );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lreRowStatus_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lreNodeType(3)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRENODETYPE:
+    rc = netsnmp_check_vb_type_and_size( var, ASN_INTEGER,
+        sizeof( rowreq_ctx->data.lreNodeType ) );
+    /* check that the value is one of defined enums */
+    if( (SNMPERR_SUCCESS == rc)
+ && ( *var->val.integer != LRENODETYPE_PRPMODE1 )
+ && ( *var->val.integer != LRENODETYPE_HSR )
+        ) {
+        rc = SNMP_ERR_WRONGVALUE;
+        }
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lreNodeType",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lreNodeType_check_value( rowreq_ctx, *((u_long *)var->val.string) );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lreNodeType_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lreNodeName(4)/DisplayString/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H */
+    case COLUMN_LRENODENAME:
+    rc = netsnmp_check_vb_type_and_max_size( var, ASN_OCTET_STR,
+        sizeof( rowreq_ctx->data.lreNodeName ) );
+    /* check defined range(s). */
+    if( (SNMPERR_SUCCESS == rc)
+       && ((var->val_len < 0) || (var->val_len > 255))
+     ) {
+        rc = SNMP_ERR_WRONGLENGTH;
+    }
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lreNodeName",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lreNodeName_check_value( rowreq_ctx, (char *)var->val.string, var->val_len );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lreNodeName_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lreVersionName(5)/OCTETSTR/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/h */
+    case COLUMN_LREVERSIONNAME:
+        rc = SNMP_ERR_NOTWRITABLE;
+        break;
+
+    /* lreMacAddress(6)/MacAddress/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H */
+    case COLUMN_LREMACADDRESS:
+    rc = netsnmp_check_vb_type_and_max_size( var, ASN_OCTET_STR,
+        sizeof( rowreq_ctx->data.lreMacAddress ) );
+    /* check defined range(s). */
+    if( (SNMPERR_SUCCESS == rc)
+       && (var->val_len != 6)
+     ) {
+        rc = SNMP_ERR_WRONGLENGTH;
+    }
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lreMacAddress",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lreMacAddress_check_value( rowreq_ctx, (char *)var->val.string, var->val_len );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lreMacAddress_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lrePortAdminStateA(7)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPORTADMINSTATEA:
+    rc = netsnmp_check_vb_type_and_size( var, ASN_INTEGER,
+        sizeof( rowreq_ctx->data.lrePortAdminStateA ) );
+    /* check that the value is one of defined enums */
+    if( (SNMPERR_SUCCESS == rc)
+ && ( *var->val.integer != LREPORTADMINSTATEA_NOTACTIVE )
+ && ( *var->val.integer != LREPORTADMINSTATEA_ACTIVE )
+        ) {
+        rc = SNMP_ERR_WRONGVALUE;
+        }
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lrePortAdminStateA",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lrePortAdminStateA_check_value( rowreq_ctx, *((u_long *)var->val.string) );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lrePortAdminStateA_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lrePortAdminStateB(8)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPORTADMINSTATEB:
+    rc = netsnmp_check_vb_type_and_size( var, ASN_INTEGER,
+        sizeof( rowreq_ctx->data.lrePortAdminStateB ) );
+    /* check that the value is one of defined enums */
+    if( (SNMPERR_SUCCESS == rc)
+ && ( *var->val.integer != LREPORTADMINSTATEB_NOTACTIVE )
+ && ( *var->val.integer != LREPORTADMINSTATEB_ACTIVE )
+        ) {
+        rc = SNMP_ERR_WRONGVALUE;
+        }
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lrePortAdminStateB",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lrePortAdminStateB_check_value( rowreq_ctx, *((u_long *)var->val.string) );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lrePortAdminStateB_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lreLinkStatusA(9)/INTEGER/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h */
+    case COLUMN_LRELINKSTATUSA:
+        rc = SNMP_ERR_NOTWRITABLE;
+        break;
+
+    /* lreLinkStatusB(10)/INTEGER/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h */
+    case COLUMN_LRELINKSTATUSB:
+        rc = SNMP_ERR_NOTWRITABLE;
+        break;
+
+    /* lreDuplicateDiscard(11)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREDUPLICATEDISCARD:
+    rc = netsnmp_check_vb_type_and_size( var, ASN_INTEGER,
+        sizeof( rowreq_ctx->data.lreDuplicateDiscard ) );
+    /* check that the value is one of defined enums */
+    if( (SNMPERR_SUCCESS == rc)
+ && ( *var->val.integer != LREDUPLICATEDISCARD_DONOTDISCARD )
+ && ( *var->val.integer != LREDUPLICATEDISCARD_DISCARD )
+        ) {
+        rc = SNMP_ERR_WRONGVALUE;
+        }
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lreDuplicateDiscard",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lreDuplicateDiscard_check_value( rowreq_ctx, *((u_long *)var->val.string) );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lreDuplicateDiscard_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lreTransparentReception(12)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRETRANSPARENTRECEPTION:
+    rc = netsnmp_check_vb_type_and_size( var, ASN_INTEGER,
+        sizeof( rowreq_ctx->data.lreTransparentReception ) );
+    /* check that the value is one of defined enums */
+    if( (SNMPERR_SUCCESS == rc)
+ && ( *var->val.integer != LRETRANSPARENTRECEPTION_REMOVERCT )
+ && ( *var->val.integer != LRETRANSPARENTRECEPTION_PASSRCT )
+        ) {
+        rc = SNMP_ERR_WRONGVALUE;
+        }
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lreTransparentReception",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lreTransparentReception_check_value( rowreq_ctx, *((u_long *)var->val.string) );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lreTransparentReception_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lreHsrLREMode(13)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREHSRLREMODE:
+    rc = netsnmp_check_vb_type_and_size( var, ASN_INTEGER,
+        sizeof( rowreq_ctx->data.lreHsrLREMode ) );
+    /* check that the value is one of defined enums */
+    if( (SNMPERR_SUCCESS == rc)
+ && ( *var->val.integer != LREHSRLREMODE_MODEH )
+ && ( *var->val.integer != LREHSRLREMODE_MODEN )
+ && ( *var->val.integer != LREHSRLREMODE_MODET )
+ && ( *var->val.integer != LREHSRLREMODE_MODEU )
+ && ( *var->val.integer != LREHSRLREMODE_MODEM )
+ && ( *var->val.integer != LREHSRLREMODE_MODEX )
+        ) {
+        rc = SNMP_ERR_WRONGVALUE;
+        }
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lreHsrLREMode",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lreHsrLREMode_check_value( rowreq_ctx, *((u_long *)var->val.string) );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lreHsrLREMode_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lreSwitchingEndNode(14)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRESWITCHINGENDNODE:
+    rc = netsnmp_check_vb_type_and_size( var, ASN_INTEGER,
+        sizeof( rowreq_ctx->data.lreSwitchingEndNode ) );
+    /* check that the value is one of defined enums */
+    if( (SNMPERR_SUCCESS == rc)
+ && ( *var->val.integer != LRESWITCHINGENDNODE_NONBRIDGINGNODE )
+ && ( *var->val.integer != LRESWITCHINGENDNODE_BRIDGINGUNSPECIFIED )
+ && ( *var->val.integer != LRESWITCHINGENDNODE_PRPNODE )
+ && ( *var->val.integer != LRESWITCHINGENDNODE_HSRREDBOXSAN )
+ && ( *var->val.integer != LRESWITCHINGENDNODE_HSRNODE )
+ && ( *var->val.integer != LRESWITCHINGENDNODE_HSRREDBOXHSR )
+ && ( *var->val.integer != LRESWITCHINGENDNODE_HSRREDBOXPRPA )
+ && ( *var->val.integer != LRESWITCHINGENDNODE_HSRREDBOXPRPB )
+        ) {
+        rc = SNMP_ERR_WRONGVALUE;
+        }
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lreSwitchingEndNode",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lreSwitchingEndNode_check_value( rowreq_ctx, *((u_long *)var->val.string) );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lreSwitchingEndNode_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lreRedBoxIdentity(15)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREREDBOXIDENTITY:
+    rc = netsnmp_check_vb_type_and_size( var, ASN_INTEGER,
+        sizeof( rowreq_ctx->data.lreRedBoxIdentity ) );
+    /* check that the value is one of defined enums */
+    if( (SNMPERR_SUCCESS == rc)
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID1A )
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID1B )
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID2A )
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID2B )
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID3A )
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID3B )
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID4A )
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID4B )
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID5A )
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID5B )
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID6A )
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID6B )
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID7A )
+ && ( *var->val.integer != LREREDBOXIDENTITY_ID7B )
+        ) {
+        rc = SNMP_ERR_WRONGVALUE;
+        }
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lreRedBoxIdentity",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lreRedBoxIdentity_check_value( rowreq_ctx, *((u_long *)var->val.string) );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lreRedBoxIdentity_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lreEvaluateSupervision(16)/TruthValue/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREEVALUATESUPERVISION:
+    rc = netsnmp_check_vb_type_and_size( var, ASN_INTEGER,
+        sizeof( rowreq_ctx->data.lreEvaluateSupervision ) );
+    /* check that the value is one of defined enums */
+    if( (SNMPERR_SUCCESS == rc)
+ && ( *var->val.integer != TRUTHVALUE_TRUE )
+ && ( *var->val.integer != TRUTHVALUE_FALSE )
+        ) {
+        rc = SNMP_ERR_WRONGVALUE;
+        }
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lreEvaluateSupervision",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lreEvaluateSupervision_check_value( rowreq_ctx, *((u_long *)var->val.string) );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lreEvaluateSupervision_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lreNodesTableClear(17)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRENODESTABLECLEAR:
+    rc = netsnmp_check_vb_type_and_size( var, ASN_INTEGER,
+        sizeof( rowreq_ctx->data.lreNodesTableClear ) );
+    /* check that the value is one of defined enums */
+    if( (SNMPERR_SUCCESS == rc)
+ && ( *var->val.integer != LRENODESTABLECLEAR_NOOP )
+ && ( *var->val.integer != LRENODESTABLECLEAR_CLEARNODETABLE )
+        ) {
+        rc = SNMP_ERR_WRONGVALUE;
+        }
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lreNodesTableClear",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lreNodesTableClear_check_value( rowreq_ctx, *((u_long *)var->val.string) );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lreNodesTableClear_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lreProxyNodeTableClear(18)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPROXYNODETABLECLEAR:
+    rc = netsnmp_check_vb_type_and_size( var, ASN_INTEGER,
+        sizeof( rowreq_ctx->data.lreProxyNodeTableClear ) );
+    /* check that the value is one of defined enums */
+    if( (SNMPERR_SUCCESS == rc)
+ && ( *var->val.integer != LREPROXYNODETABLECLEAR_NOOP )
+ && ( *var->val.integer != LREPROXYNODETABLECLEAR_CLEARPROXYNODETABLE )
+        ) {
+        rc = SNMP_ERR_WRONGVALUE;
+        }
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lreProxyNodeTableClear",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lreProxyNodeTableClear_check_value( rowreq_ctx, *((u_long *)var->val.string) );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lreProxyNodeTableClear_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+    /* lreDupListResideMaxTime(19)/SecondFraction/ASN_INTEGER/long(long)//l/A/W/e/r/D/H */
+    case COLUMN_LREDUPLISTRESIDEMAXTIME:
+    rc = netsnmp_check_vb_type_and_size( var, ASN_INTEGER,
+        sizeof( rowreq_ctx->data.lreDupListResideMaxTime ) );
+    if(SNMPERR_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:_lreInterfaceConfigTable_check_column:lreDupListResideMaxTime",
+                    "varbind validation failed (eg bad type or size)\n"));
+    }
+    else {
+        rc = lreDupListResideMaxTime_check_value( rowreq_ctx, *((long *)var->val.string) );
+        if((MFD_SUCCESS != rc) && (MFD_NOT_VALID_EVER != rc) &&
+           (MFD_NOT_VALID_NOW != rc)) {
+            snmp_log(LOG_ERR, "bad rc %d from lreDupListResideMaxTime_check_value\n", rc);
+            rc = SNMP_ERR_GENERR;
+        }
+    }
+        break;
+
+        default: /** We shouldn't get here */
+            rc = SNMP_ERR_GENERR;
+            snmp_log(LOG_ERR, "unknown column %d in _lreInterfaceConfigTable_check_column\n", column);
+    }
+
+    return rc;
+} /* _lreInterfaceConfigTable_check_column */
+
+int
+_mfd_lreInterfaceConfigTable_check_objects(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx = (lreInterfaceConfigTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+    netsnmp_table_request_info * tri;
+    int                          rc;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_check_objects","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    for(;requests; requests = requests->next) {
+
+        /*
+         * get column number from table request info, and check that column
+         */
+        tri = netsnmp_extract_table_info(requests);
+        if(NULL == tri)
+            continue;
+
+        rc = _lreInterfaceConfigTable_check_column(rowreq_ctx, requests->requestvb, tri->colnum);
+        if(rc) {
+            netsnmp_request_set_error(requests, SNMP_VALIDATE_ERR(rc));
+            break;
+        }
+
+    } /* for results */
+
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceConfigTable_check_objects */
+
+
+/*----------------------------------------------------------------------
+ *
+ * SET: check dependencies
+ *
+ *---------------------------------------------------------------------*/
+/*
+ * @internal
+ * Check dependencies wrapper
+ */
+static int
+_mfd_lreInterfaceConfigTable_check_dependencies(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    int                    rc;
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx = (lreInterfaceConfigTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_check_dependencies","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    rc = lreInterfaceConfigTable_check_dependencies(rowreq_ctx);
+    if(rc){
+        DEBUGMSGTL(("lreInterfaceConfigTable:mfd","error %d from "
+                    "lreInterfaceConfigTable_check_dependencies\n", rc));
+        netsnmp_request_set_error_all(requests, SNMP_VALIDATE_ERR(rc));
+    }
+
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceConfigTable_check_dependencies */
+
+/*----------------------------------------------------------------------
+ *
+ * SET: Undo setup
+ *
+ *---------------------------------------------------------------------*/
+/*
+ * @internal
+ * Set the value for a particular column
+ */
+NETSNMP_STATIC_INLINE int
+_lreInterfaceConfigTable_undo_setup_column( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, int column )
+{
+    int rc = SNMPERR_SUCCESS;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_lreInterfaceConfigTable_undo_setup_column",
+                "called for %d\n", column));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    switch(column) {
+
+    /* lreRowStatus(2)/RowStatus/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREROWSTATUS:
+        rowreq_ctx->column_set_flags |= COLUMN_LREROWSTATUS_FLAG;
+        rc = lreRowStatus_undo_setup(rowreq_ctx );
+        break;
+
+    /* lreNodeType(3)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRENODETYPE:
+        rowreq_ctx->column_set_flags |= COLUMN_LRENODETYPE_FLAG;
+        rc = lreNodeType_undo_setup(rowreq_ctx );
+        break;
+
+    /* lreNodeName(4)/DisplayString/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H */
+    case COLUMN_LRENODENAME:
+        rowreq_ctx->column_set_flags |= COLUMN_LRENODENAME_FLAG;
+        rc = lreNodeName_undo_setup(rowreq_ctx );
+        break;
+
+    /* lreMacAddress(6)/MacAddress/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H */
+    case COLUMN_LREMACADDRESS:
+        rowreq_ctx->column_set_flags |= COLUMN_LREMACADDRESS_FLAG;
+        rc = lreMacAddress_undo_setup(rowreq_ctx );
+        break;
+
+    /* lrePortAdminStateA(7)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPORTADMINSTATEA:
+        rowreq_ctx->column_set_flags |= COLUMN_LREPORTADMINSTATEA_FLAG;
+        rc = lrePortAdminStateA_undo_setup(rowreq_ctx );
+        break;
+
+    /* lrePortAdminStateB(8)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPORTADMINSTATEB:
+        rowreq_ctx->column_set_flags |= COLUMN_LREPORTADMINSTATEB_FLAG;
+        rc = lrePortAdminStateB_undo_setup(rowreq_ctx );
+        break;
+
+    /* lreDuplicateDiscard(11)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREDUPLICATEDISCARD:
+        rowreq_ctx->column_set_flags |= COLUMN_LREDUPLICATEDISCARD_FLAG;
+        rc = lreDuplicateDiscard_undo_setup(rowreq_ctx );
+        break;
+
+    /* lreTransparentReception(12)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRETRANSPARENTRECEPTION:
+        rowreq_ctx->column_set_flags |= COLUMN_LRETRANSPARENTRECEPTION_FLAG;
+        rc = lreTransparentReception_undo_setup(rowreq_ctx );
+        break;
+
+    /* lreHsrLREMode(13)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREHSRLREMODE:
+        rowreq_ctx->column_set_flags |= COLUMN_LREHSRLREMODE_FLAG;
+        rc = lreHsrLREMode_undo_setup(rowreq_ctx );
+        break;
+
+    /* lreSwitchingEndNode(14)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRESWITCHINGENDNODE:
+        rowreq_ctx->column_set_flags |= COLUMN_LRESWITCHINGENDNODE_FLAG;
+        rc = lreSwitchingEndNode_undo_setup(rowreq_ctx );
+        break;
+
+    /* lreRedBoxIdentity(15)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREREDBOXIDENTITY:
+        rowreq_ctx->column_set_flags |= COLUMN_LREREDBOXIDENTITY_FLAG;
+        rc = lreRedBoxIdentity_undo_setup(rowreq_ctx );
+        break;
+
+    /* lreEvaluateSupervision(16)/TruthValue/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREEVALUATESUPERVISION:
+        rowreq_ctx->column_set_flags |= COLUMN_LREEVALUATESUPERVISION_FLAG;
+        rc = lreEvaluateSupervision_undo_setup(rowreq_ctx );
+        break;
+
+    /* lreNodesTableClear(17)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRENODESTABLECLEAR:
+        rowreq_ctx->column_set_flags |= COLUMN_LRENODESTABLECLEAR_FLAG;
+        rc = lreNodesTableClear_undo_setup(rowreq_ctx );
+        break;
+
+    /* lreProxyNodeTableClear(18)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPROXYNODETABLECLEAR:
+        rowreq_ctx->column_set_flags |= COLUMN_LREPROXYNODETABLECLEAR_FLAG;
+        rc = lreProxyNodeTableClear_undo_setup(rowreq_ctx );
+        break;
+
+    /* lreDupListResideMaxTime(19)/SecondFraction/ASN_INTEGER/long(long)//l/A/W/e/r/D/H */
+    case COLUMN_LREDUPLISTRESIDEMAXTIME:
+        rowreq_ctx->column_set_flags |= COLUMN_LREDUPLISTRESIDEMAXTIME_FLAG;
+        rc = lreDupListResideMaxTime_undo_setup(rowreq_ctx );
+        break;
+
+     default:
+         snmp_log(LOG_ERR,"unknown column %d in _lreInterfaceConfigTable_undo_setup_column\n", column);
+         break;
+    }
+
+    return rc;
+} /* _lreInterfaceConfigTable_undo_setup_column */
+
+
+/**
+ * @internal
+ * undo setup
+ */
+int
+_mfd_lreInterfaceConfigTable_undo_setup(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    int                    rc;
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx = (lreInterfaceConfigTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_undo_setup","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * allocate undo context
+     */
+    rowreq_ctx->undo = lreInterfaceConfigTable_allocate_data();
+    if(NULL == rowreq_ctx->undo) {
+        /** msg already logged */
+        netsnmp_request_set_error_all(requests, SNMP_ERR_RESOURCEUNAVAILABLE);
+        return SNMP_ERR_NOERROR;
+    }
+
+    /*
+     * row undo setup
+     */
+    rowreq_ctx->column_set_flags = 0;
+    rc = lreInterfaceConfigTable_undo_setup(rowreq_ctx);
+    if (MFD_SUCCESS != rc)  {
+        DEBUGMSGTL(("lreInterfaceConfigTable:mfd","error %d from "
+                    "lreInterfaceConfigTable_undo_setup\n", rc));
+        netsnmp_request_set_error_all(requests, SNMP_VALIDATE_ERR(rc));
+    }
+    else {
+        /*
+         * column undo setup
+         */
+        netsnmp_table_request_info * tri;
+        for(;requests; requests = requests->next) {
+            /*
+             * set column data
+             */
+            tri = netsnmp_extract_table_info(requests);
+            if(NULL == tri)
+                continue;
+
+            rc = _lreInterfaceConfigTable_undo_setup_column(rowreq_ctx, tri->colnum);
+            if(MFD_SUCCESS != rc)  {
+                DEBUGMSGTL(("lreInterfaceConfigTable:mfd","error %d from "
+                            "lreInterfaceConfigTable_undo_setup_column\n", rc));
+                netsnmp_set_request_error(agtreq_info, requests, SNMP_VALIDATE_ERR(rc));
+            }
+        } /* for results */
+    }
+
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceConfigTable_undo_setup */
+
+/**
+ * @internal
+ * undo setup
+ */
+int
+_mfd_lreInterfaceConfigTable_undo_cleanup(netsnmp_mib_handler *handler,
+                             netsnmp_handler_registration *reginfo,
+                             netsnmp_agent_request_info *agtreq_info,
+                             netsnmp_request_info *requests)
+{
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx = (lreInterfaceConfigTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+    int rc;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_undo_cleanup","called\n"));
+
+    /*
+     * failed row create in early stages has no rowreq_ctx
+     */
+    if (NULL == rowreq_ctx)
+        return MFD_SUCCESS;
+
+    /*
+     * call user cleanup
+     */
+    rc = lreInterfaceConfigTable_undo_cleanup(rowreq_ctx);
+    if (MFD_SUCCESS != rc) {
+        /*
+         * nothing we can do about it but log it
+         */
+        DEBUGMSGTL(("lreInterfaceConfigTable:mfd","error %d from "
+                    "lreInterfaceConfigTable_undo_cleanup\n", rc));
+    }
+
+    /*
+     * release undo context, if needed
+     */
+    if(rowreq_ctx->undo) {
+         lreInterfaceConfigTable_release_data(rowreq_ctx->undo);
+         rowreq_ctx->undo = NULL;
+    }
+
+
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceConfigTable_undo_cleanup */
+
+/*----------------------------------------------------------------------
+ *
+ * SET: Set values
+ *
+ *---------------------------------------------------------------------*/
+/*
+ * @internal
+ * Set the value for a particular column
+ */
+NETSNMP_STATIC_INLINE int
+_lreInterfaceConfigTable_set_column( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx,
+                       netsnmp_variable_list *var, int column )
+{
+    int rc = SNMPERR_SUCCESS;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_lreInterfaceConfigTable_set_column",
+                "called for %d\n", column));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    switch(column) {
+
+    /* lreRowStatus(2)/RowStatus/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREROWSTATUS:
+        rowreq_ctx->column_set_flags |= COLUMN_LREROWSTATUS_FLAG;
+        rc = lreRowStatus_set(rowreq_ctx, *((u_long *)var->val.string) );
+        break;
+
+    /* lreNodeType(3)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRENODETYPE:
+        rowreq_ctx->column_set_flags |= COLUMN_LRENODETYPE_FLAG;
+        rc = lreNodeType_set(rowreq_ctx, *((u_long *)var->val.string) );
+        break;
+
+    /* lreNodeName(4)/DisplayString/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H */
+    case COLUMN_LRENODENAME:
+        rowreq_ctx->column_set_flags |= COLUMN_LRENODENAME_FLAG;
+        rc = lreNodeName_set(rowreq_ctx, (char *)var->val.string, var->val_len );
+        break;
+
+    /* lreMacAddress(6)/MacAddress/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H */
+    case COLUMN_LREMACADDRESS:
+        rowreq_ctx->column_set_flags |= COLUMN_LREMACADDRESS_FLAG;
+        rc = lreMacAddress_set(rowreq_ctx, (char *)var->val.string, var->val_len );
+        break;
+
+    /* lrePortAdminStateA(7)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPORTADMINSTATEA:
+        rowreq_ctx->column_set_flags |= COLUMN_LREPORTADMINSTATEA_FLAG;
+        rc = lrePortAdminStateA_set(rowreq_ctx, *((u_long *)var->val.string) );
+        break;
+
+    /* lrePortAdminStateB(8)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPORTADMINSTATEB:
+        rowreq_ctx->column_set_flags |= COLUMN_LREPORTADMINSTATEB_FLAG;
+        rc = lrePortAdminStateB_set(rowreq_ctx, *((u_long *)var->val.string) );
+        break;
+
+    /* lreDuplicateDiscard(11)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREDUPLICATEDISCARD:
+        rowreq_ctx->column_set_flags |= COLUMN_LREDUPLICATEDISCARD_FLAG;
+        rc = lreDuplicateDiscard_set(rowreq_ctx, *((u_long *)var->val.string) );
+        break;
+
+    /* lreTransparentReception(12)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRETRANSPARENTRECEPTION:
+        rowreq_ctx->column_set_flags |= COLUMN_LRETRANSPARENTRECEPTION_FLAG;
+        rc = lreTransparentReception_set(rowreq_ctx, *((u_long *)var->val.string) );
+        break;
+
+    /* lreHsrLREMode(13)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREHSRLREMODE:
+        rowreq_ctx->column_set_flags |= COLUMN_LREHSRLREMODE_FLAG;
+        rc = lreHsrLREMode_set(rowreq_ctx, *((u_long *)var->val.string) );
+        break;
+
+    /* lreSwitchingEndNode(14)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRESWITCHINGENDNODE:
+        rowreq_ctx->column_set_flags |= COLUMN_LRESWITCHINGENDNODE_FLAG;
+        rc = lreSwitchingEndNode_set(rowreq_ctx, *((u_long *)var->val.string) );
+        break;
+
+    /* lreRedBoxIdentity(15)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREREDBOXIDENTITY:
+        rowreq_ctx->column_set_flags |= COLUMN_LREREDBOXIDENTITY_FLAG;
+        rc = lreRedBoxIdentity_set(rowreq_ctx, *((u_long *)var->val.string) );
+        break;
+
+    /* lreEvaluateSupervision(16)/TruthValue/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREEVALUATESUPERVISION:
+        rowreq_ctx->column_set_flags |= COLUMN_LREEVALUATESUPERVISION_FLAG;
+        rc = lreEvaluateSupervision_set(rowreq_ctx, *((u_long *)var->val.string) );
+        break;
+
+    /* lreNodesTableClear(17)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRENODESTABLECLEAR:
+        rowreq_ctx->column_set_flags |= COLUMN_LRENODESTABLECLEAR_FLAG;
+        rc = lreNodesTableClear_set(rowreq_ctx, *((u_long *)var->val.string) );
+        break;
+
+    /* lreProxyNodeTableClear(18)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPROXYNODETABLECLEAR:
+        rowreq_ctx->column_set_flags |= COLUMN_LREPROXYNODETABLECLEAR_FLAG;
+        rc = lreProxyNodeTableClear_set(rowreq_ctx, *((u_long *)var->val.string) );
+        break;
+
+    /* lreDupListResideMaxTime(19)/SecondFraction/ASN_INTEGER/long(long)//l/A/W/e/r/D/H */
+    case COLUMN_LREDUPLISTRESIDEMAXTIME:
+        rowreq_ctx->column_set_flags |= COLUMN_LREDUPLISTRESIDEMAXTIME_FLAG;
+        rc = lreDupListResideMaxTime_set(rowreq_ctx, *((long *)var->val.string) );
+        break;
+
+     default:
+         snmp_log(LOG_ERR,"unknown column %d in _lreInterfaceConfigTable_set_column\n", column);
+         rc = SNMP_ERR_GENERR;
+         break;
+    }
+
+    return rc;
+} /* _lreInterfaceConfigTable_set_column */
+
+int
+_mfd_lreInterfaceConfigTable_set_values(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx = (lreInterfaceConfigTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+    netsnmp_table_request_info * tri;
+    int                          rc = SNMP_ERR_NOERROR;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_set_values","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    rowreq_ctx->column_set_flags = 0;
+    for(;requests; requests = requests->next) {
+        /*
+         * set column data
+         */
+        tri = netsnmp_extract_table_info(requests);
+        if(NULL == tri)
+            continue;
+
+        rc = _lreInterfaceConfigTable_set_column(rowreq_ctx,
+                                    requests->requestvb, tri->colnum);
+        if(MFD_SUCCESS != rc)  {
+            DEBUGMSGTL(("lreInterfaceConfigTable:mfd","error %d from "
+                        "lreInterfaceConfigTable_set_column\n", rc));
+            netsnmp_set_request_error(agtreq_info, requests, SNMP_VALIDATE_ERR(rc));
+        }
+    } /* for results */
+
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceConfigTable_set_values */
+
+/*----------------------------------------------------------------------
+ *
+ * SET: commit
+ *
+ *---------------------------------------------------------------------*/
+/**
+ * @internal
+ * commit the values
+ */
+int
+_mfd_lreInterfaceConfigTable_commit(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    int                    rc;
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx = (lreInterfaceConfigTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_commit","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    rc = lreInterfaceConfigTable_commit(rowreq_ctx);
+    if (MFD_SUCCESS != rc) {
+        DEBUGMSGTL(("lreInterfaceConfigTable:mfd","error %d from "
+                    "lreInterfaceConfigTable_commit\n", rc));
+        netsnmp_request_set_error_all(requests, SNMP_VALIDATE_ERR(rc));
+    }
+
+    if (rowreq_ctx->rowreq_flags & MFD_ROW_DIRTY) {
+        /*
+         * if we successfully commited this row, set the dirty flag. Use the
+         * current value + 1 (i.e. dirty = # rows changed).
+         * this is checked in post_request...
+         */
+        lreInterfaceConfigTable_dirty_set( lreInterfaceConfigTable_dirty_get() + 1 ); /* set table dirty flag */
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+_mfd_lreInterfaceConfigTable_undo_commit(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    int                    rc;
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx = (lreInterfaceConfigTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_undo_commit","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    if (rowreq_ctx->rowreq_flags & MFD_ROW_DIRTY) {
+        u_int  d = lreInterfaceConfigTable_dirty_get();
+
+        netsnmp_assert(d != 0);
+        if(d)
+            lreInterfaceConfigTable_dirty_set( d - 1 );
+    }
+
+    rc = lreInterfaceConfigTable_undo_commit(rowreq_ctx);
+    if (MFD_SUCCESS != rc) {
+        /*
+         * nothing we can do about it but log it
+         */
+        DEBUGMSGTL(("lreInterfaceConfigTable:mfd","error %d from "
+                    "lreInterfaceConfigTable_undo_commit\n", rc));
+    }
+
+    if (rowreq_ctx->rowreq_flags & MFD_ROW_DIRTY) {
+        snmp_log(LOG_WARNING, "lreInterfaceConfigTable row dirty flag still set after undo_commit\n");
+        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
+    }
+
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceConfigTable_commit */
+
+/*----------------------------------------------------------------------
+ *
+ * SET: Undo
+ *
+ *---------------------------------------------------------------------*/
+/**
+ * @internal
+ * undo the value for a particular column
+ */
+NETSNMP_STATIC_INLINE int
+_lreInterfaceConfigTable_undo_column( lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx,
+                       netsnmp_variable_list *var, int column )
+{
+    int rc = SNMPERR_SUCCESS;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_lreInterfaceConfigTable_undo_column",
+                "called for %d\n", column));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    switch(column) {
+
+    /* lreRowStatus(2)/RowStatus/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREROWSTATUS:
+        rc = lreRowStatus_undo(rowreq_ctx);
+        break;
+
+    /* lreNodeType(3)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRENODETYPE:
+        rc = lreNodeType_undo(rowreq_ctx);
+        break;
+
+    /* lreNodeName(4)/DisplayString/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H */
+    case COLUMN_LRENODENAME:
+        rc = lreNodeName_undo(rowreq_ctx);
+        break;
+
+    /* lreMacAddress(6)/MacAddress/ASN_OCTET_STR/char(char)//L/A/W/e/R/d/H */
+    case COLUMN_LREMACADDRESS:
+        rc = lreMacAddress_undo(rowreq_ctx);
+        break;
+
+    /* lrePortAdminStateA(7)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPORTADMINSTATEA:
+        rc = lrePortAdminStateA_undo(rowreq_ctx);
+        break;
+
+    /* lrePortAdminStateB(8)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPORTADMINSTATEB:
+        rc = lrePortAdminStateB_undo(rowreq_ctx);
+        break;
+
+    /* lreDuplicateDiscard(11)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREDUPLICATEDISCARD:
+        rc = lreDuplicateDiscard_undo(rowreq_ctx);
+        break;
+
+    /* lreTransparentReception(12)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRETRANSPARENTRECEPTION:
+        rc = lreTransparentReception_undo(rowreq_ctx);
+        break;
+
+    /* lreHsrLREMode(13)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREHSRLREMODE:
+        rc = lreHsrLREMode_undo(rowreq_ctx);
+        break;
+
+    /* lreSwitchingEndNode(14)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRESWITCHINGENDNODE:
+        rc = lreSwitchingEndNode_undo(rowreq_ctx);
+        break;
+
+    /* lreRedBoxIdentity(15)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREREDBOXIDENTITY:
+        rc = lreRedBoxIdentity_undo(rowreq_ctx);
+        break;
+
+    /* lreEvaluateSupervision(16)/TruthValue/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREEVALUATESUPERVISION:
+        rc = lreEvaluateSupervision_undo(rowreq_ctx);
+        break;
+
+    /* lreNodesTableClear(17)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LRENODESTABLECLEAR:
+        rc = lreNodesTableClear_undo(rowreq_ctx);
+        break;
+
+    /* lreProxyNodeTableClear(18)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h */
+    case COLUMN_LREPROXYNODETABLECLEAR:
+        rc = lreProxyNodeTableClear_undo(rowreq_ctx);
+        break;
+
+    /* lreDupListResideMaxTime(19)/SecondFraction/ASN_INTEGER/long(long)//l/A/W/e/r/D/H */
+    case COLUMN_LREDUPLISTRESIDEMAXTIME:
+        rc = lreDupListResideMaxTime_undo(rowreq_ctx);
+        break;
+
+     default:
+         snmp_log(LOG_ERR,"unknown column %d in _lreInterfaceConfigTable_undo_column\n", column);
+         break;
+    }
+
+    return rc;
+} /* _lreInterfaceConfigTable_undo_column */
+
+int
+_mfd_lreInterfaceConfigTable_undo_values(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    int                    rc;
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx = (lreInterfaceConfigTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+    netsnmp_table_request_info * tri;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_undo_values","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    rc = lreInterfaceConfigTable_undo(rowreq_ctx);
+    if (MFD_SUCCESS != rc) {
+        /*
+         * nothing we can do about it but log it
+         */
+        DEBUGMSGTL(("lreInterfaceConfigTable:mfd","error %d from "
+                    "lreInterfaceConfigTable_undo\n", rc));
+    }
+
+    for(;requests; requests = requests->next) {
+        /*
+         * set column data
+         */
+        tri = netsnmp_extract_table_info(requests);
+        if(NULL == tri)
+            continue;
+
+        rc = _lreInterfaceConfigTable_undo_column(rowreq_ctx, requests->requestvb,
+                                     tri->colnum);
+        if (MFD_SUCCESS != rc) {
+            /*
+             * nothing we can do about it but log it
+             */
+            DEBUGMSGTL(("lreInterfaceConfigTable:mfd","error %d from "
+                        "lreInterfaceConfigTable_undo_column\n", rc));
+        }
+    } /* for results */
+
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceConfigTable_undo_values */
+
+/*----------------------------------------------------------------------
+ *
+ * SET: irreversible commit
+ *
+ *---------------------------------------------------------------------*/
+/**
+ * @internal
+ * commit irreversible actions
+ */
+int
+_mfd_lreInterfaceConfigTable_irreversible_commit(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx = (lreInterfaceConfigTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_mfd_lreInterfaceConfigTable_irreversible:commit","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * check for and handle row creation/deletion
+     * and update column exist flags...
+     */
+    if (rowreq_ctx->rowreq_flags & MFD_ROW_DELETED) {
+        if (! (rowreq_ctx->rowreq_flags & MFD_ROW_CREATED))
+            CONTAINER_REMOVE(lreInterfaceConfigTable_if_ctx.container, rowreq_ctx);
+    }
+    else {
+        if (rowreq_ctx->column_set_flags) {
+           rowreq_ctx->column_set_flags = 0;
+        }
+        if (rowreq_ctx->rowreq_flags & MFD_ROW_CREATED) {
+            rowreq_ctx->rowreq_flags &= ~MFD_ROW_CREATED;
+            CONTAINER_INSERT(lreInterfaceConfigTable_if_ctx.container, rowreq_ctx);
+        }
+    }
+
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceConfigTable_irreversible_commit */
+
+/***********************************************************************
+ *
+ * DATA ACCESS
+ *
+ ***********************************************************************/
+static void _container_free(netsnmp_container *container);
+
+/**
+ * @internal
+ */
+static int
+_cache_load(netsnmp_cache *cache, void *vmagic)
+{
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_cache_load","called\n"));
+
+    if((NULL == cache) || (NULL == cache->magic)) {
+        snmp_log(LOG_ERR, "invalid cache for lreInterfaceConfigTable_cache_load\n");
+        return -1;
+    }
+
+    /** should only be called for an invalid or expired cache */
+    netsnmp_assert((0 == cache->valid) || (1 == cache->expired));
+
+    /*
+     * call user code
+     */
+    return lreInterfaceConfigTable_container_load((netsnmp_container*)cache->magic);
+} /* _cache_load */
+
+/**
+ * @internal
+ */
+static void
+_cache_free(netsnmp_cache *cache, void *magic)
+{
+    netsnmp_container *container;
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_cache_free","called\n"));
+
+    if((NULL == cache) || (NULL == cache->magic)) {
+        snmp_log(LOG_ERR, "invalid cache in lreInterfaceConfigTable_cache_free\n");
+        return;
+    }
+
+    container = (netsnmp_container*)cache->magic;
+
+    _container_free(container);
+} /* _cache_free */
+
+/**
+ * @internal
+ */
+static void
+_container_item_free(lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx, void *context)
+{
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_container_item_free","called\n"));
+
+    if(NULL == rowreq_ctx)
+        return;
+
+    lreInterfaceConfigTable_release_rowreq_ctx(rowreq_ctx);
+} /* _container_item_free */
+
+/**
+ * @internal
+ */
+static void
+_container_free(netsnmp_container *container)
+{
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_container_free","called\n"));
+
+    if (NULL == container) {
+        snmp_log(LOG_ERR, "invalid container in lreInterfaceConfigTable_container_free\n");
+        return;
+    }
+
+    /*
+     * call user code
+     */
+    lreInterfaceConfigTable_container_free(container);
+
+    /*
+     * free all items. inefficient, but easy.
+     */
+    CONTAINER_CLEAR(container,
+                    (netsnmp_container_obj_func *)_container_item_free,
+                    NULL);
+} /* _container_free */
+
+/**
+ * @internal
+ * initialize the container with functions or wrappers
+ */
+void
+_lreInterfaceConfigTable_container_init(lreInterfaceConfigTable_interface_ctx *if_ctx)
+{
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_lreInterfaceConfigTable_container_init","called\n"));
+
+    /*
+     * cache init
+     */
+    if_ctx->cache = netsnmp_cache_create(30, /* timeout in seconds */
+                                         _cache_load, _cache_free,
+                                         lreInterfaceConfigTable_oid,
+                                         lreInterfaceConfigTable_oid_size);
+
+    if(NULL == if_ctx->cache) {
+        snmp_log(LOG_ERR, "error creating cache for lreInterfaceConfigTable\n");
+        return;
+    }
+
+    if_ctx->cache->flags = NETSNMP_CACHE_DONT_INVALIDATE_ON_SET;
+
+    lreInterfaceConfigTable_container_init(&if_ctx->container, if_ctx->cache);
+    if(NULL == if_ctx->container)
+        if_ctx->container = netsnmp_container_find("lreInterfaceConfigTable:table_container");
+    if(NULL == if_ctx->container) {
+        snmp_log(LOG_ERR,"error creating container in "
+                 "lreInterfaceConfigTable_container_init\n");
+        return;
+    }
+
+    if (NULL != if_ctx->cache)
+        if_ctx->cache->magic = (void*)if_ctx->container;
+} /* _lreInterfaceConfigTable_container_init */
+
+/**
+ * @internal
+ * shutdown the container with functions or wrappers
+ */
+void
+_lreInterfaceConfigTable_container_shutdown(lreInterfaceConfigTable_interface_ctx *if_ctx)
+{
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_lreInterfaceConfigTable_container_shutdown","called\n"));
+
+    lreInterfaceConfigTable_container_shutdown(if_ctx->container);
+
+    _container_free(if_ctx->container);
+
+} /* _lreInterfaceConfigTable_container_shutdown */
+
+/***********************************************************************
+ *
+ * PERSISTENCE
+ *
+ ***********************************************************************/
+
+static int _lreInterfaceConfigTable_container_save_rows(int majorID, int minorID, void *serverarg, void *clientarg);
+static void _lreInterfaceConfigTable_container_row_restore(const char *token, char *buf);
+static int _lreInterfaceConfigTable_container_row_save(
+            lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx,
+            void *type);
+static char * _lreInterfaceConfigTable_container_col_restore(
+            lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx,
+            u_int col, char* buf);
+static char * _lreInterfaceConfigTable_container_col_save(
+            lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx,
+            u_int col, char* buf);
+
+static char row_token[] = "lreInterfaceConfigTable";
+
+/************************************************************
+ * *_init_persistence should be called from the main table
+ * init routine.
+ *
+ * If your table depends on rows in another table,
+ * you should register your callback after the other table,
+ * which should ensure the rows on which you depend are saved
+ * (and re-created) before the dependent rows.
+ */
+void
+lreInterfaceConfigTable_container_init_persistence( netsnmp_container * container )
+{
+    int rc;
+
+    register_config_handler(NULL, row_token,
+                            _lreInterfaceConfigTable_container_row_restore, NULL, NULL);
+    rc = snmp_register_callback( SNMP_CALLBACK_LIBRARY,
+                                     SNMP_CALLBACK_STORE_DATA,
+                                     _lreInterfaceConfigTable_container_save_rows,
+                                     container);
+
+    if( rc != SNMP_ERR_NOERROR )
+        snmp_log(LOG_ERR, "error registering for STORE_DATA callback "
+                 "in _lreInterfaceConfigTable_container_init_persistence\n");
+}
+
+static int
+_lreInterfaceConfigTable_container_save_rows(int majorID, int minorID, void *serverarg, void *clientarg)
+{
+    char sep[] =
+        "##############################################################";
+    char buf[] =
+        "#\n"
+        "# lreInterfaceConfigTable persistent data\n"
+        "#";
+    char *type = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
+                                       NETSNMP_DS_LIB_APPTYPE);
+
+    read_config_store((char*)type, sep);
+    read_config_store((char*)type, buf);
+
+    /*
+     * save all rows
+     */
+    CONTAINER_FOR_EACH((netsnmp_container*)clientarg,
+                       (netsnmp_container_obj_func*)_lreInterfaceConfigTable_container_row_save,
+                       type);
+
+    read_config_store((char*)type, sep);
+    read_config_store((char*)type, "\n");
+
+    /*
+     * never fails
+     */
+    return SNMPERR_SUCCESS;
+}
+
+
+
+/************************************************************
+ * _lreInterfaceConfigTable_container_row_save
+ */
+static int
+_lreInterfaceConfigTable_container_row_save(
+            lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx,
+            void *type)
+{
+    /*
+     * Allocate space for a line with all data for a row. An
+     * attempt is made to come up with a default maximum size, but
+     * there is no guarantee it will be enough. It probably will be,
+     * unless you are dealing with large values or you have external
+     * indexes.
+     *
+     * 1) allocate space for each column. Comment out columns you don't
+     * intend to save. You may also need to add room for any non-
+     * column data you want to store. Remeber, data will be stored in
+     * ASCII form, so you need to allow for that. Here are some
+     * general guidelines:
+     *
+     *   Object ID   :  12 * len [ASCII len of max int + 1 for .]
+     *   Octet String: (2 * len) + 2 [2 ASCII chars per byte + "0x"]
+     *   Integers    :  12 [ASCII len for smallest negative number]
+     *
+     * 2) You also need to allocate space for the row index. This will
+     * be stored as an OID, which means that Octet Strings need to
+     * be treated a little differently. Specifically, you will need
+     * (4 * len) + 4 [3 ASCII chars per byte + 1 for ., + 4 for len].
+     *
+     * 3) Also, remember to add space for the identifier and separator
+     * characters (for example, each column is prefixed by the
+     * column number and a semicolon. To allow for the maximum
+     * column values, 12 bytes [11 for oid + 1 for ':'] per
+     * column are added).
+     */
+        /** xxx: add storage for external index(s)! */
+#define MAX_ROW_SIZE (sizeof(row_token) + 1 +  \
+        ( 12 ) + /* ASN_INTEGER lreRowStatus */ \
+        ( 12 ) + /* ASN_INTEGER lreNodeType */ \
+        ( ( 2 * sizeof(rowreq_ctx->data.lreNodeName) ) + 3 ) + /* ASN_OCTET_STR */ \
+        ( ( 2 * sizeof(rowreq_ctx->data.lreMacAddress) ) + 3 ) + /* ASN_OCTET_STR */ \
+        ( 12 ) + /* ASN_INTEGER lrePortAdminStateA */ \
+        ( 12 ) + /* ASN_INTEGER lrePortAdminStateB */ \
+        ( 12 ) + /* ASN_INTEGER lreDuplicateDiscard */ \
+        ( 12 ) + /* ASN_INTEGER lreTransparentReception */ \
+        ( 12 ) + /* ASN_INTEGER lreHsrLREMode */ \
+        ( 12 ) + /* ASN_INTEGER lreSwitchingEndNode */ \
+        ( 12 ) + /* ASN_INTEGER lreRedBoxIdentity */ \
+        ( 12 ) + /* ASN_INTEGER lreEvaluateSupervision */ \
+        ( 12 ) + /* ASN_INTEGER lreNodesTableClear */ \
+        ( 12 ) + /* ASN_INTEGER lreProxyNodeTableClear */ \
+        ( 12 ) + /* ASN_INTEGER lreDupListResideMaxTime */ \
+        ( LREINTERFACECONFIGTABLE_MAX_COL * 12 ) + /* column num prefix + : */ \
+    2 /* LINE_TERM_CHAR + \n */ )
+
+    char buf[MAX_ROW_SIZE], *pos = buf, *max = &buf[MAX_ROW_SIZE-1];
+    char *tmp;
+    int i;
+
+    if (lreInterfaceConfigTable_container_should_save(rowreq_ctx) == 0) {
+        return SNMP_ERR_NOERROR;
+    }
+
+    /*
+     * build the line
+     */
+    pos += sprintf(pos, "%s ", row_token);
+    pos = read_config_save_objid(pos, rowreq_ctx->oid_idx.oids,
+                                 rowreq_ctx->oid_idx.len);
+    if(NULL == pos) {
+        snmp_log(LOG_ERR,"error saving lreInterfaceConfigTable row "
+                 "to persistent file\n");
+        return SNMP_ERR_GENERR;
+    }
+    *pos++ = ' ';
+    if(pos > max) {
+        snmp_log(LOG_ERR,"error saving lreInterfaceConfigTable row "
+                 "to persistent file (too long)\n");
+        return SNMP_ERR_GENERR;
+    }
+
+    /*
+     * add each column
+     */
+    for(i = LREINTERFACECONFIGTABLE_MIN_COL; i <= LREINTERFACECONFIGTABLE_MAX_COL; ++i ) {
+
+        if ((0x1 << (i-1)) & ~LREINTERFACECONFIGTABLE_SETTABLE_COLS)
+           continue;
+
+        tmp = pos;
+        pos = _lreInterfaceConfigTable_container_col_save(rowreq_ctx, i, pos);
+        if(NULL == pos)
+            pos = tmp;
+        else
+            *pos++ = ' ';
+        if(pos > max) {
+            snmp_log(LOG_ERR,"error saving lreInterfaceConfigTable row "
+                     "to persistent file (too long)\n");
+            return SNMP_ERR_GENERR;
+        }
+    }
+
+    /*
+     * if you have non-column data, add it here
+     */
+
+
+    /*
+     * store the line
+     */
+    pos += sprintf(pos, "%c", LINE_TERM_CHAR);
+    if(pos > max) {
+        snmp_log(LOG_ERR,"error saving lreInterfaceConfigTable row "
+                 "to persistent file (too long)\n");
+        return SNMP_ERR_GENERR;
+    }
+    read_config_store((char*)type, buf);
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_lreInterfaceConfigTable_container_row_save",
+                "saving line '%s'\n", buf));
+
+    return SNMP_ERR_NOERROR;
+}
+
+static void
+_lreInterfaceConfigTable_container_row_restore(const char *token, char *buf)
+{
+    lreInterfaceConfigTable_rowreq_ctx * rowreq_ctx;
+    netsnmp_index index;
+    oid tmp_oid[ MAX_lreInterfaceConfigTable_IDX_LEN];
+    u_int col = 0, found = 0;
+
+
+    if (strncmp(token, row_token, sizeof(row_token)) != 0) {
+        snmp_log(LOG_ERR, "unknown token in _lreInterfaceConfigTable_container_row_restore\n");
+        return;
+    }
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_lreInterfaceConfigTable_container_row_restore",
+                "parsing line '%s'\n", buf));
+
+    /*
+     * pull out index and create default row
+     */
+    index.oids = tmp_oid;
+    index.len = OID_LENGTH(tmp_oid);
+    buf = read_config_read_objid(buf, &index.oids,
+                                 &index.len);
+    if (NULL == buf) {
+        snmp_log(LOG_ERR, "error reading row index in "
+                 "_lreInterfaceConfigTable_container_row_restore\n");
+        return;
+    }
+    rowreq_ctx = _mfd_lreInterfaceConfigTable_rowreq_from_index( &index, NULL );
+    if (NULL == rowreq_ctx) {
+        snmp_log(LOG_ERR, "error creating row index in "
+                 "_lreInterfaceConfigTable_container_row_restore\n");
+        return;
+    }
+
+    /*
+     * loop through and get each column
+     */
+    buf = skip_white(buf);
+    while ( (NULL != buf) && isdigit(*buf) ) {
+        /*
+         * extract column, skip ':'
+         */
+        col = (u_int)strtol(buf, &buf, 10);
+        if (NULL == buf)
+            break;
+        if (*buf != ':') {
+            buf = NULL;
+            break;
+        }
+        ++buf; /* skip : */
+
+        /*
+         * parse value
+         */
+        DEBUGMSGTL(("_lreInterfaceConfigTable_container_row_restore",
+                    "parsing column %d\n", col));
+        buf = _lreInterfaceConfigTable_container_col_restore( rowreq_ctx, col, buf );
+        ++found;
+    }
+    if (0 == found) {
+        snmp_log(LOG_ERR, "error parsing lreInterfaceConfigTable row; no columns found\n");
+        lreInterfaceConfigTable_release_rowreq_ctx( rowreq_ctx );
+        return;
+    }
+
+    /*
+     * if you added any non-column data, this is where
+     * you should handle it.
+     */
+
+    /*
+     * if the pointer is NULL and we didn't reach the
+     * end of the line, something went wrong. Log message,
+     * delete the row and bail.
+     */
+    if ((buf == NULL) || (*buf != LINE_TERM_CHAR)) {
+        snmp_log(LOG_ERR, "error parsing lreInterfaceConfigTable row around column %d\n",
+                 col);
+        lreInterfaceConfigTable_release_rowreq_ctx( rowreq_ctx );
+        return;
+    }
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_lreInterfaceConfigTable_container_row_restore",
+                "inserting row\n"));
+
+    /*
+     * copy oid index and insert row
+     */
+    rowreq_ctx->oid_idx.len = index.len;
+    memcpy(rowreq_ctx->oid_idx.oids, index.oids, index.len * sizeof(oid));
+
+    CONTAINER_INSERT(lreInterfaceConfigTable_if_ctx.container, rowreq_ctx);
+}
+
+/************************************************************
+ * _lreInterfaceConfigTable_container_col_save
+ */
+static char *
+_lreInterfaceConfigTable_container_col_save(
+            lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx,
+            u_int col, char* buf)
+{
+    if( ( NULL == rowreq_ctx ) || ( NULL == buf )) {
+        snmp_log(LOG_ERR, "bad parameter in "
+                 "_lreInterfaceConfigTable_container_col_save\n");
+        return NULL;
+    }
+
+    DEBUGMSGTL(("internal:lreInterfaceConfigTable:_lreInterfaceConfigTable_container_col_save",
+                "processing column %d\n", col));
+
+    /*
+     * prefix with column number, so we don't ever depend on
+     * order saved.
+     */
+    buf += sprintf(buf, "%u:", col);
+
+    /*
+     * save data for the column
+     */
+    switch(col) {
+
+        case COLUMN_LREROWSTATUS: /** RowStatus = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lreRowStatus);
+        break;
+
+        case COLUMN_LRENODETYPE: /** INTEGER = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lreNodeType);
+        break;
+
+        case COLUMN_LRENODENAME: /** DisplayString = ASN_OCTET_STR */
+            buf = read_config_save_octet_string(buf, (u_char *)rowreq_ctx->data.lreNodeName,
+                                                rowreq_ctx->data.lreNodeName_len );
+        break;
+
+        case COLUMN_LREVERSIONNAME: /** OCTETSTR = ASN_OCTET_STR */
+            buf = read_config_save_octet_string(buf, (u_char *)rowreq_ctx->data.lreVersionName,
+                                                rowreq_ctx->data.lreVersionName_len );
+        break;
+
+        case COLUMN_LREMACADDRESS: /** MacAddress = ASN_OCTET_STR */
+            buf = read_config_save_octet_string(buf, (u_char *)rowreq_ctx->data.lreMacAddress,
+                                                rowreq_ctx->data.lreMacAddress_len );
+        break;
+
+        case COLUMN_LREPORTADMINSTATEA: /** INTEGER = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lrePortAdminStateA);
+        break;
+
+        case COLUMN_LREPORTADMINSTATEB: /** INTEGER = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lrePortAdminStateB);
+        break;
+
+        case COLUMN_LRELINKSTATUSA: /** INTEGER = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lreLinkStatusA);
+        break;
+
+        case COLUMN_LRELINKSTATUSB: /** INTEGER = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lreLinkStatusB);
+        break;
+
+        case COLUMN_LREDUPLICATEDISCARD: /** INTEGER = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lreDuplicateDiscard);
+        break;
+
+        case COLUMN_LRETRANSPARENTRECEPTION: /** INTEGER = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lreTransparentReception);
+        break;
+
+        case COLUMN_LREHSRLREMODE: /** INTEGER = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lreHsrLREMode);
+        break;
+
+        case COLUMN_LRESWITCHINGENDNODE: /** INTEGER = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lreSwitchingEndNode);
+        break;
+
+        case COLUMN_LREREDBOXIDENTITY: /** INTEGER = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lreRedBoxIdentity);
+        break;
+
+        case COLUMN_LREEVALUATESUPERVISION: /** TruthValue = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lreEvaluateSupervision);
+        break;
+
+        case COLUMN_LRENODESTABLECLEAR: /** INTEGER = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lreNodesTableClear);
+        break;
+
+        case COLUMN_LREPROXYNODETABLECLEAR: /** INTEGER = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lreProxyNodeTableClear);
+        break;
+
+        case COLUMN_LREDUPLISTRESIDEMAXTIME: /** SecondFraction = ASN_INTEGER */
+            buf += sprintf(buf,"%ld",rowreq_ctx->data.lreDupListResideMaxTime);
+        break;
+
+    default: /** We shouldn't get here */
+        snmp_log(LOG_ERR, "unknown column %d in "
+                 "_lreInterfaceConfigTable_container_col_save\n", col);
+        return NULL;
+    }
+
+    return buf;
+}
+
+/************************************************************
+ * _lreInterfaceConfigTable_container_col_restore
+ */
+static char *
+_lreInterfaceConfigTable_container_col_restore(
+            lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx,
+            u_int col, char* buf)
+{
+    size_t len;
+    if( ( NULL == rowreq_ctx ) || ( NULL == buf )) {
+        snmp_log(LOG_ERR, "bad parameter in "
+                 "_lreInterfaceConfigTable_container_col_restore\n");
+        return NULL;
+    }
+
+    DEBUGMSGTL(("verbose:lreInterfaceConfigTable:_lreInterfaceConfigTable_container_col_restore",
+                "processing column %d\n", col));
+
+    /*
+     * restore data for the column
+     */
+    switch(col) {
+
+        case COLUMN_LREROWSTATUS: /** RowStatus = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lreRowStatus);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lreRowStatus,
+                                          &len);
+        break;
+
+        case COLUMN_LRENODETYPE: /** INTEGER = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lreNodeType);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lreNodeType,
+                                          &len);
+        break;
+
+        case COLUMN_LRENODENAME: /** DisplayString = ASN_OCTET_STR */
+            rowreq_ctx->data.lreNodeName_len = sizeof(rowreq_ctx->data.lreNodeName);
+            buf = read_config_read_memory(ASN_OCTET_STR,buf,
+                                          (char*)&rowreq_ctx->data.lreNodeName,
+                                          (size_t*)&rowreq_ctx->data.lreNodeName_len );
+        break;
+
+        case COLUMN_LREVERSIONNAME: /** OCTETSTR = ASN_OCTET_STR */
+            rowreq_ctx->data.lreVersionName_len = sizeof(rowreq_ctx->data.lreVersionName);
+            buf = read_config_read_memory(ASN_OCTET_STR,buf,
+                                          (char*)&rowreq_ctx->data.lreVersionName,
+                                          (size_t*)&rowreq_ctx->data.lreVersionName_len );
+        break;
+
+        case COLUMN_LREMACADDRESS: /** MacAddress = ASN_OCTET_STR */
+            rowreq_ctx->data.lreMacAddress_len = sizeof(rowreq_ctx->data.lreMacAddress);
+            buf = read_config_read_memory(ASN_OCTET_STR,buf,
+                                          (char*)&rowreq_ctx->data.lreMacAddress,
+                                          (size_t*)&rowreq_ctx->data.lreMacAddress_len );
+        break;
+
+        case COLUMN_LREPORTADMINSTATEA: /** INTEGER = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lrePortAdminStateA);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lrePortAdminStateA,
+                                          &len);
+        break;
+
+        case COLUMN_LREPORTADMINSTATEB: /** INTEGER = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lrePortAdminStateB);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lrePortAdminStateB,
+                                          &len);
+        break;
+
+        case COLUMN_LRELINKSTATUSA: /** INTEGER = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lreLinkStatusA);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lreLinkStatusA,
+                                          &len);
+        break;
+
+        case COLUMN_LRELINKSTATUSB: /** INTEGER = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lreLinkStatusB);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lreLinkStatusB,
+                                          &len);
+        break;
+
+        case COLUMN_LREDUPLICATEDISCARD: /** INTEGER = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lreDuplicateDiscard);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lreDuplicateDiscard,
+                                          &len);
+        break;
+
+        case COLUMN_LRETRANSPARENTRECEPTION: /** INTEGER = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lreTransparentReception);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lreTransparentReception,
+                                          &len);
+        break;
+
+        case COLUMN_LREHSRLREMODE: /** INTEGER = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lreHsrLREMode);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lreHsrLREMode,
+                                          &len);
+        break;
+
+        case COLUMN_LRESWITCHINGENDNODE: /** INTEGER = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lreSwitchingEndNode);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lreSwitchingEndNode,
+                                          &len);
+        break;
+
+        case COLUMN_LREREDBOXIDENTITY: /** INTEGER = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lreRedBoxIdentity);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lreRedBoxIdentity,
+                                          &len);
+        break;
+
+        case COLUMN_LREEVALUATESUPERVISION: /** TruthValue = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lreEvaluateSupervision);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lreEvaluateSupervision,
+                                          &len);
+        break;
+
+        case COLUMN_LRENODESTABLECLEAR: /** INTEGER = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lreNodesTableClear);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lreNodesTableClear,
+                                          &len);
+        break;
+
+        case COLUMN_LREPROXYNODETABLECLEAR: /** INTEGER = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lreProxyNodeTableClear);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lreProxyNodeTableClear,
+                                          &len);
+        break;
+
+        case COLUMN_LREDUPLISTRESIDEMAXTIME: /** SecondFraction = ASN_INTEGER */
+            len = sizeof(rowreq_ctx->data.lreDupListResideMaxTime);
+            buf = read_config_read_memory(ASN_INTEGER, buf,
+                                          (char*)&rowreq_ctx->data.lreDupListResideMaxTime,
+                                          &len);
+        break;
+
+    default: /** We shouldn't get here */
+        snmp_log(LOG_ERR, "unknown column %d in "
+                 "_lreInterfaceConfigTable_container_col_restore\n", col);
+        return NULL;
+    }
+
+    return buf;
+}
+
+
+lreInterfaceConfigTable_rowreq_ctx *
+lreInterfaceConfigTable_row_find_by_mib_index(lreInterfaceConfigTable_mib_index *mib_idx)
+{
+    lreInterfaceConfigTable_rowreq_ctx   *rowreq_ctx;
+    oid                      oid_tmp[MAX_OID_LEN];
+    netsnmp_index            oid_idx;
+    int                      rc;
+
+    /*
+     * set up storage for OID
+     */
+    oid_idx.oids = oid_tmp;
+    oid_idx.len = sizeof(oid_tmp)/sizeof(oid);
+
+    /*
+     * convert
+     */
+    rc = lreInterfaceConfigTable_index_to_oid(&oid_idx, mib_idx);
+    if (MFD_SUCCESS != rc)
+        return NULL;
+
+    rowreq_ctx = (lreInterfaceConfigTable_rowreq_ctx*)CONTAINER_FIND(lreInterfaceConfigTable_if_ctx.container, &oid_idx);
+
+    return rowreq_ctx;
+}
+
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_interface.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_interface.h
new file mode 100644
index 0000000..59ce641
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_interface.h
@@ -0,0 +1,99 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+/** @ingroup interface: Routines to interface to Net-SNMP
+ *
+ * \warning This code should not be modified, called directly,
+ *          or used to interpret functionality. It is subject to
+ *          change at any time.
+ *
+ * @{
+ */
+/*
+ * *********************************************************************
+ * *********************************************************************
+ * *********************************************************************
+ * ***                                                               ***
+ * ***  NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE  ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***       THIS FILE DOES NOT CONTAIN ANY USER EDITABLE CODE.      ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***       THE GENERATED CODE IS INTERNAL IMPLEMENTATION, AND      ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***    IS SUBJECT TO CHANGE WITHOUT WARNING IN FUTURE RELEASES.   ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * *********************************************************************
+ * *********************************************************************
+ * *********************************************************************
+ */
+#ifndef LREINTERFACECONFIGTABLE_INTERFACE_H
+#define LREINTERFACECONFIGTABLE_INTERFACE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include "lreInterfaceConfigTable.h"
+
+
+/* ********************************************************************
+ * Table declarations
+ */
+
+/* PUBLIC interface initialization routine */
+void _lreInterfaceConfigTable_initialize_interface(lreInterfaceConfigTable_registration * user_ctx,
+                                    u_long flags);
+void _lreInterfaceConfigTable_shutdown_interface(lreInterfaceConfigTable_registration * user_ctx);
+
+lreInterfaceConfigTable_registration *
+lreInterfaceConfigTable_registration_get( void );
+
+lreInterfaceConfigTable_registration *
+lreInterfaceConfigTable_registration_set( lreInterfaceConfigTable_registration * newreg );
+
+netsnmp_container *lreInterfaceConfigTable_container_get( void );
+int lreInterfaceConfigTable_container_size( void );
+
+u_int lreInterfaceConfigTable_dirty_get( void );
+void lreInterfaceConfigTable_dirty_set( u_int status );
+
+    lreInterfaceConfigTable_rowreq_ctx * lreInterfaceConfigTable_allocate_rowreq_ctx(void *);
+void lreInterfaceConfigTable_release_rowreq_ctx(lreInterfaceConfigTable_rowreq_ctx *rowreq_ctx);
+
+int lreInterfaceConfigTable_index_to_oid(netsnmp_index *oid_idx,
+                            lreInterfaceConfigTable_mib_index *mib_idx);
+int lreInterfaceConfigTable_index_from_oid(netsnmp_index *oid_idx,
+                              lreInterfaceConfigTable_mib_index *mib_idx);
+
+/* *********************************************************************
+ * Persistent declarations
+ */
+/*
+ * persistence
+ */
+#define LINE_TERM_CHAR '$'
+
+void lreInterfaceConfigTable_container_init_persistence( netsnmp_container * container );
+int lreInterfaceConfigTable_container_should_save(lreInterfaceConfigTable_rowreq_ctx * rowreq_ctx);
+
+
+/*
+ * access to certain internals. use with caution!
+ */
+void lreInterfaceConfigTable_valid_columns_set(netsnmp_column_info *vc);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACECONFIGTABLE_INTERFACE_H */
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_oids.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_oids.h
new file mode 100644
index 0000000..8593cd4
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable_oids.h
@@ -0,0 +1,94 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  $
+ *
+ * $Id:$
+ */
+#ifndef LREINTERFACECONFIGTABLE_OIDS_H
+#define LREINTERFACECONFIGTABLE_OIDS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* column number definitions for table lreInterfaceConfigTable */
+#define LREINTERFACECONFIGTABLE_OID              1,0,62439,2,21,0,1,0,1
+
+
+#define COLUMN_LREINTERFACECONFIGINDEX         1
+
+#define COLUMN_LREROWSTATUS         2
+#define COLUMN_LREROWSTATUS_FLAG    (0x1 << 0)
+
+#define COLUMN_LRENODETYPE         3
+#define COLUMN_LRENODETYPE_FLAG    (0x1 << 1)
+
+#define COLUMN_LRENODENAME         4
+#define COLUMN_LRENODENAME_FLAG    (0x1 << 2)
+
+#define COLUMN_LREVERSIONNAME         5
+
+#define COLUMN_LREMACADDRESS         6
+#define COLUMN_LREMACADDRESS_FLAG    (0x1 << 3)
+
+#define COLUMN_LREPORTADMINSTATEA         7
+#define COLUMN_LREPORTADMINSTATEA_FLAG    (0x1 << 4)
+
+#define COLUMN_LREPORTADMINSTATEB         8
+#define COLUMN_LREPORTADMINSTATEB_FLAG    (0x1 << 5)
+
+#define COLUMN_LRELINKSTATUSA         9
+
+#define COLUMN_LRELINKSTATUSB         10
+
+#define COLUMN_LREDUPLICATEDISCARD         11
+#define COLUMN_LREDUPLICATEDISCARD_FLAG    (0x1 << 6)
+
+#define COLUMN_LRETRANSPARENTRECEPTION         12
+#define COLUMN_LRETRANSPARENTRECEPTION_FLAG    (0x1 << 7)
+
+#define COLUMN_LREHSRLREMODE         13
+#define COLUMN_LREHSRLREMODE_FLAG    (0x1 << 8)
+
+#define COLUMN_LRESWITCHINGENDNODE         14
+#define COLUMN_LRESWITCHINGENDNODE_FLAG    (0x1 << 9)
+
+#define COLUMN_LREREDBOXIDENTITY         15
+#define COLUMN_LREREDBOXIDENTITY_FLAG    (0x1 << 10)
+
+#define COLUMN_LREEVALUATESUPERVISION         16
+#define COLUMN_LREEVALUATESUPERVISION_FLAG    (0x1 << 11)
+
+#define COLUMN_LRENODESTABLECLEAR         17
+#define COLUMN_LRENODESTABLECLEAR_FLAG    (0x1 << 12)
+
+#define COLUMN_LREPROXYNODETABLECLEAR         18
+#define COLUMN_LREPROXYNODETABLECLEAR_FLAG    (0x1 << 13)
+
+#define COLUMN_LREDUPLISTRESIDEMAXTIME         19
+#define COLUMN_LREDUPLISTRESIDEMAXTIME_FLAG    (0x1 << 14)
+
+
+#define LREINTERFACECONFIGTABLE_MIN_COL   COLUMN_LREROWSTATUS
+#define LREINTERFACECONFIGTABLE_MAX_COL   COLUMN_LREDUPLISTRESIDEMAXTIME
+
+
+    /*
+     * TODO:405:r: Review LREINTERFACECONFIGTABLE_SETTABLE_COLS macro.
+     * OR together all the writable cols.
+     */
+#define LREINTERFACECONFIGTABLE_SETTABLE_COLS (COLUMN_LREROWSTATUS_FLAG | COLUMN_LRENODETYPE_FLAG | COLUMN_LRENODENAME_FLAG | COLUMN_LREMACADDRESS_FLAG | COLUMN_LREPORTADMINSTATEA_FLAG | COLUMN_LREPORTADMINSTATEB_FLAG | COLUMN_LREDUPLICATEDISCARD_FLAG | COLUMN_LRETRANSPARENTRECEPTION_FLAG | COLUMN_LREHSRLREMODE_FLAG | COLUMN_LRESWITCHINGENDNODE_FLAG | COLUMN_LREREDBOXIDENTITY_FLAG | COLUMN_LREEVALUATESUPERVISION_FLAG | COLUMN_LRENODESTABLECLEAR_FLAG | COLUMN_LREPROXYNODETABLECLEAR_FLAG | COLUMN_LREDUPLISTRESIDEMAXTIME_FLAG)
+    /*
+     * TODO:405:r: Review LREINTERFACECONFIGTABLE_REQUIRED_COLS macro.
+     * OR together all the required rows for row creation.
+     * default is writable cols w/out defaults.
+     */
+#define LREINTERFACECONFIGTABLE_REQUIRED_COLS (COLUMN_LREROWSTATUS_FLAG | COLUMN_LRENODETYPE_FLAG | COLUMN_LRENODENAME_FLAG | COLUMN_LREMACADDRESS_FLAG | COLUMN_LREPORTADMINSTATEA_FLAG | COLUMN_LREPORTADMINSTATEB_FLAG | COLUMN_LREDUPLICATEDISCARD_FLAG | COLUMN_LRETRANSPARENTRECEPTION_FLAG | COLUMN_LREHSRLREMODE_FLAG | COLUMN_LRESWITCHINGENDNODE_FLAG | COLUMN_LREREDBOXIDENTITY_FLAG | COLUMN_LREEVALUATESUPERVISION_FLAG | COLUMN_LRENODESTABLECLEAR_FLAG | COLUMN_LREPROXYNODETABLECLEAR_FLAG)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACECONFIGTABLE_OIDS_H */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreManufacturerName.c b/agent/mibgroup/IEC-62439-3-MIB/lreManufacturerName.c
new file mode 100644
index 0000000..229efae
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreManufacturerName.c
@@ -0,0 +1,62 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "lreManufacturerName.h"
+
+/* can be overridden by snmpd.conf override attribute for a specific
+ * LRE to match the manufacture name
+ */
+#define default_lreManufacturerName "Linux"
+
+/** Initializes the lreManufacturerName module */
+void
+init_lreManufacturerName(void)
+{
+    const oid lreManufacturerName_oid[] = { 1,0,62439,2,21,0,0,1 };
+
+  DEBUGMSGTL(("lreManufacturerName", "Initializing\n"));
+
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("lreManufacturerName", handle_lreManufacturerName,
+                               lreManufacturerName_oid, OID_LENGTH(lreManufacturerName_oid),
+                               HANDLER_CAN_RONLY
+        ));
+}
+
+int
+handle_lreManufacturerName(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    char name[64];
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+	    strncpy(&name[0], default_lreManufacturerName, sizeof(name)-1);
+	    name[sizeof(name)-1] = '\0';
+            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
+                                     &name[0] /* XXX: a pointer to the scalar's data */,
+                                     sizeof(name) /* XXX: the length of the data in bytes */);
+            break;
+
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lreManufacturerName\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreManufacturerName.h b/agent/mibgroup/IEC-62439-3-MIB/lreManufacturerName.h
new file mode 100644
index 0000000..c9fcd2c
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreManufacturerName.h
@@ -0,0 +1,12 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        $
+ */
+#ifndef LREMANUFACTURERNAME_H
+#define LREMANUFACTURERNAME_H
+
+/* function declarations */
+void init_lreManufacturerName(void);
+Netsnmp_Node_Handler handle_lreManufacturerName;
+
+#endif /* LREMANUFACTURERNAME_H */
diff --git a/agent/mibgroup/iec-62439-3-mib.h b/agent/mibgroup/iec-62439-3-mib.h
index 40e44cc..9afe698 100644
--- a/agent/mibgroup/iec-62439-3-mib.h
+++ b/agent/mibgroup/iec-62439-3-mib.h
@@ -2,6 +2,6 @@
  * module to include the modules
  */
 
-config_require(iec-62439-3-mib/lreManufacturerName)
-config_require(iec-62439-3-mib/lreInterfaceConfigTable)
+config_require(IEC-62439-3-MIB/lreManufacturerName)
+config_require(IEC-62439-3-MIB/lreInterfaceConfigTable/lreInterfaceConfigTable)
 config_add_mib(IEC-62439-3-MIB)
diff --git a/agent/mibgroup/iec-62439-3-mib/lreInterfaceConfigTable.c b/agent/mibgroup/iec-62439-3-mib/lreInterfaceConfigTable.c
deleted file mode 100644
index 3307541..0000000
--- a/agent/mibgroup/iec-62439-3-mib/lreInterfaceConfigTable.c
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Note: this file originally auto-generated by mib2c using
- *        $
- */
-
-#include <net-snmp/net-snmp-config.h>
-#include <net-snmp/net-snmp-includes.h>
-#include <net-snmp/agent/net-snmp-agent-includes.h>
-#include "lreInterfaceConfigTable.h"
-
-typedef struct lre_interface_config_table_entry_s {
-    u_long interface_config_index;
-    int row_stats;
-    int node_type;
-    char node_name[128];
-    char version_name[32];
-    char mac_address[32];
-    int port_admin_state_A;
-    int port_admin_state_B;
-    int link_status_A;
-    int link_status_B;
-    int duplicate_discard;
-    int transparent_reception;
-    int hsr_lre_mode;
-    int switching_end_node;
-    int redbox_identity;
-    int evaluate_supervision;
-    int nodes_table_clear;
-    int dup_list_reside_max_time;
-} lre_if_config_table_entry;
-
-static lre_if_config_table_entry default_lre_if_config_table_entry = {
-    0,1,2,{'h','s','r','0','\0'},{'v','e','r','s','i','o','n',' ','1','\0'},
-    {1,2,3,4,5,6,'\0'},1,0,1,0,2,1,3,1,1,1,0,100};
-
-static int if_count = 1;
-/** Initialize the lreInterfaceConfigTable table by defining its contents and how it's structured */
-void
-initialize_table_lreInterfaceConfigTable(void)
-{
-    const oid lreInterfaceConfigTable_oid[] = {1,0,62439,2,21,0,1,0,1};
-    const oid lreInterfaceCount_oid[] = {1,0,62439,2,21,0,0,2};
-    netsnmp_table_data_set *table_set;
-    netsnmp_table_row *row;
-
-    netsnmp_register_scalar(
-        netsnmp_create_handler_registration("lreInterfaceCount", handle_lreInterfaceCount,
-                               lreInterfaceCount_oid, OID_LENGTH(lreInterfaceCount_oid),
-                               HANDLER_CAN_RONLY
-        ));
-
-    /* create the table structure itself */
-    table_set = netsnmp_create_table_data_set("lreInterfaceConfigTable");
-
-    /* comment this out or delete if you don't support creation of new rows */
-    /*
-    table_set->allow_creation = 1;
-    */
-
-    /***************************************************
-     * Adding indexes
-     */
-    DEBUGMSGTL(("initialize_table_lreInterfaceConfigTable",
-                "adding indexes to table lreInterfaceConfigTable\n"));
-    netsnmp_table_set_add_indexes(table_set,
-                           ASN_UNSIGNED,  /* index: lreInterfaceConfigIndex */
-                           0);
-
-    DEBUGMSGTL(("initialize_table_lreInterfaceConfigTable",
-                "adding column types to table lreInterfaceConfigTable\n"));
-    netsnmp_table_set_multi_add_default_row(table_set,
-                                            COLUMN_LREINTERFACECONFIGINDEX, ASN_UNSIGNED, 0,
-                                            NULL, 0,
-                                            COLUMN_LREROWSTATUS, ASN_INTEGER, 1,
-                                            NULL, 0,
-                                            COLUMN_LRENODETYPE, ASN_INTEGER, 1,
-                                            NULL, 0,
-                                            COLUMN_LRENODENAME, ASN_OCTET_STR, 1,
-                                            NULL, 0,
-                                            COLUMN_LREVERSIONNAME, ASN_OCTET_STR, 0,
-                                            NULL, 0,
-                                            COLUMN_LREMACADDRESS, ASN_OCTET_STR, 1,
-                                            NULL, 0,
-                                            COLUMN_LREPORTADMINSTATEA, ASN_INTEGER, 1,
-                                            NULL, 0,
-                                            COLUMN_LREPORTADMINSTATEB, ASN_INTEGER, 1,
-                                            NULL, 0,
-                                            COLUMN_LRELINKSTATUSA, ASN_INTEGER, 0,
-                                            NULL, 0,
-                                            COLUMN_LRELINKSTATUSB, ASN_INTEGER, 0,
-                                            NULL, 0,
-                                            COLUMN_LREDUPLICATEDISCARD, ASN_INTEGER, 1,
-                                            NULL, 0,
-                                            COLUMN_LRETRANSPARENTRECEPTION, ASN_INTEGER, 1,
-                                            NULL, 0,
-                                            COLUMN_LREHSRLREMODE, ASN_INTEGER, 1,
-                                            NULL, 0,
-                                            COLUMN_LRESWITCHINGENDNODE, ASN_INTEGER, 1,
-                                            NULL, 0,
-                                            COLUMN_LREREDBOXIDENTITY, ASN_INTEGER, 1,
-                                            NULL, 0,
-                                            COLUMN_LREEVALUATESUPERVISION, ASN_INTEGER, 1,
-                                            NULL, 0,
-                                            COLUMN_LRENODESTABLECLEAR, ASN_INTEGER, 1,
-                                            NULL, 0,
-                                            COLUMN_LREPROXYNODETABLECLEAR, ASN_INTEGER, 1,
-                                            NULL, 0,
-                                            COLUMN_LREDUPLISTRESIDEMAXTIME, ASN_INTEGER, 1,
-                                            NULL, 0,
-                              0);
-
-    /* registering the table with the master agent */
-    /* note: if you don't need a subhandler to deal with any aspects
-       of the request, change lreInterfaceConfigTable_handler to "NULL" */
-    netsnmp_register_table_data_set(netsnmp_create_handler_registration("lreInterfaceConfigTable", lreInterfaceConfigTable_handler,
-                                                        lreInterfaceConfigTable_oid,
-                                                        OID_LENGTH(lreInterfaceConfigTable_oid),
-                                                        HANDLER_CAN_RWRITE),
-                            table_set, NULL);
-
-    /*
-     * create the a row for the table, and add the data
-     */
-    row = netsnmp_create_table_data_row();
-
-    /*
-     * set the index to the 0
-     */
-    netsnmp_table_row_add_index(row, ASN_UNSIGNED,
-		                &default_lre_if_config_table_entry.interface_config_index,
-				sizeof(&default_lre_if_config_table_entry.interface_config_index));
-
-    /* set hardcoded values for now */
-    netsnmp_set_row_column(row, COLUMN_LREROWSTATUS, ASN_INTEGER,
-                           &default_lre_if_config_table_entry.row_stats,
-			   sizeof(default_lre_if_config_table_entry.row_stats));
-    netsnmp_set_row_column(row, COLUMN_LRENODETYPE, ASN_INTEGER,
-                           &default_lre_if_config_table_entry.node_type,
-			   sizeof(default_lre_if_config_table_entry.node_type));
-    netsnmp_set_row_column(row, COLUMN_LRENODENAME, ASN_OCTET_STR,
-			   &default_lre_if_config_table_entry.node_name[0],
-			   strlen(default_lre_if_config_table_entry.node_name));
-    netsnmp_set_row_column(row, COLUMN_LREVERSIONNAME, ASN_OCTET_STR,
-			   &default_lre_if_config_table_entry.version_name[0],
-			   strlen(default_lre_if_config_table_entry.version_name));
-    netsnmp_set_row_column(row, COLUMN_LREMACADDRESS, ASN_OCTET_STR,
-			   &default_lre_if_config_table_entry.mac_address[0], 6);
-    netsnmp_set_row_column(row, COLUMN_LREPORTADMINSTATEA, ASN_INTEGER,
-			   &default_lre_if_config_table_entry.port_admin_state_A,
-			   sizeof(default_lre_if_config_table_entry.port_admin_state_A));
-    netsnmp_set_row_column(row, COLUMN_LREPORTADMINSTATEB, ASN_INTEGER,
-			   &default_lre_if_config_table_entry.port_admin_state_B,
-			   sizeof(default_lre_if_config_table_entry.port_admin_state_B));
-    netsnmp_set_row_column(row, COLUMN_LRELINKSTATUSA, ASN_INTEGER,
-			   &default_lre_if_config_table_entry.link_status_A,
-			   sizeof(default_lre_if_config_table_entry.link_status_A));
-    netsnmp_set_row_column(row, COLUMN_LRELINKSTATUSB, ASN_INTEGER,
-			   &default_lre_if_config_table_entry.link_status_B,
-			   sizeof(default_lre_if_config_table_entry.link_status_B));
-    netsnmp_set_row_column(row, COLUMN_LREDUPLICATEDISCARD, ASN_INTEGER,
-			   &default_lre_if_config_table_entry.duplicate_discard,
-			   sizeof(default_lre_if_config_table_entry.duplicate_discard));
-    netsnmp_set_row_column(row, COLUMN_LRETRANSPARENTRECEPTION, ASN_INTEGER,
-			   &default_lre_if_config_table_entry.transparent_reception,
-			   sizeof(default_lre_if_config_table_entry.transparent_reception));
-    netsnmp_set_row_column(row, COLUMN_LREHSRLREMODE, ASN_INTEGER,
-			   &default_lre_if_config_table_entry.hsr_lre_mode,
-			   sizeof(default_lre_if_config_table_entry.hsr_lre_mode));
-    netsnmp_set_row_column(row, COLUMN_LRESWITCHINGENDNODE, ASN_INTEGER,
-			   &default_lre_if_config_table_entry.switching_end_node,
-			   sizeof(default_lre_if_config_table_entry.switching_end_node));
-    netsnmp_set_row_column(row, COLUMN_LREREDBOXIDENTITY, ASN_INTEGER,
-			   &default_lre_if_config_table_entry.redbox_identity,
-			   sizeof(default_lre_if_config_table_entry.redbox_identity));
-    netsnmp_set_row_column(row, COLUMN_LREEVALUATESUPERVISION, ASN_INTEGER,
-			   &default_lre_if_config_table_entry.evaluate_supervision,
-			   sizeof(default_lre_if_config_table_entry.evaluate_supervision));
-    netsnmp_set_row_column(row, COLUMN_LRENODESTABLECLEAR, ASN_INTEGER,
-			   &default_lre_if_config_table_entry.nodes_table_clear,
-			   sizeof(default_lre_if_config_table_entry.nodes_table_clear));
-    netsnmp_set_row_column(row, COLUMN_LREPROXYNODETABLECLEAR, ASN_INTEGER,
-			   &default_lre_if_config_table_entry.dup_list_reside_max_time,
-			   sizeof(default_lre_if_config_table_entry.dup_list_reside_max_time));
-    /*
-     * add the row to the table
-     */
-    netsnmp_table_dataset_add_row(table_set, row);
-    DEBUGMSGTL(("lreInterfaceConfigTable ", "Done initializing.\n"));
-}
-
-/** Initializes the lreInterfaceConfigTable module */
-void
-init_lreInterfaceConfigTable(void)
-{
-
-  /* here we initialize all the tables we're planning on supporting */
-    initialize_table_lreInterfaceConfigTable();
-}
-
-/** handles requests for the lreInterfaceConfigTable table, if anything else needs to be done */
-int
-lreInterfaceConfigTable_handler(
-    netsnmp_mib_handler               *handler,
-    netsnmp_handler_registration      *reginfo,
-    netsnmp_agent_request_info        *reqinfo,
-    netsnmp_request_info              *requests) {
-    /* perform anything here that you need to do.  The requests have
-       already been processed by the master table_dataset handler, but
-       this gives you chance to act on the request in some other way
-       if need be. */
-    return SNMP_ERR_NOERROR;
-}
-
-int
-handle_lreInterfaceCount(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
-{
-    /* We are never called for a GETNEXT if it's registered as a
-       "instance", as it's "magically" handled for us.  */
-
-    printf("handle_lreInterfaceCount");
-    /* a instance handler also only hands us one request at a time, so
-       we don't need to loop over a list of requests; we'll only get one */
-
-    switch(reqinfo->mode) {
-
-        case MODE_GET:
-            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
-                                     &if_count /* XXX: a pointer to the scalar's data */,
-                                     sizeof(if_count) /* XXX: the length of the data in bytes */);
-            break;
-
-
-        default:
-            /* we should never get here, so this is a really bad error */
-            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lreInterfaceCount\n", reqinfo->mode );
-            return SNMP_ERR_GENERR;
-    }
-
-    return SNMP_ERR_NOERROR;
-}
diff --git a/agent/mibgroup/iec-62439-3-mib/lreInterfaceConfigTable.h b/agent/mibgroup/iec-62439-3-mib/lreInterfaceConfigTable.h
deleted file mode 100644
index d26a2ca..0000000
--- a/agent/mibgroup/iec-62439-3-mib/lreInterfaceConfigTable.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Note: this file originally auto-generated by mib2c using
- *  $
- */
-#ifndef LREINTERFACECONFIGTABLE_H
-#define LREINTERFACECONFIGTABLE_H
-
-/* function declarations */
-void init_lreInterfaceConfigTable(void);
-void initialize_table_lreInterfaceConfigTable(void);
-Netsnmp_Node_Handler lreInterfaceConfigTable_handler;
-
-/* function declarations */
-int handle_lreInterfaceCount(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests);
-
-/* column number definitions for table lreInterfaceConfigTable */
-       #define COLUMN_LREINTERFACECONFIGINDEX		1
-       #define COLUMN_LREROWSTATUS		2
-       #define COLUMN_LRENODETYPE		3
-       #define COLUMN_LRENODENAME		4
-       #define COLUMN_LREVERSIONNAME		5
-       #define COLUMN_LREMACADDRESS		6
-       #define COLUMN_LREPORTADMINSTATEA		7
-       #define COLUMN_LREPORTADMINSTATEB		8
-       #define COLUMN_LRELINKSTATUSA		9
-       #define COLUMN_LRELINKSTATUSB		10
-       #define COLUMN_LREDUPLICATEDISCARD		11
-       #define COLUMN_LRETRANSPARENTRECEPTION		12
-       #define COLUMN_LREHSRLREMODE		13
-       #define COLUMN_LRESWITCHINGENDNODE		14
-       #define COLUMN_LREREDBOXIDENTITY		15
-       #define COLUMN_LREEVALUATESUPERVISION		16
-       #define COLUMN_LRENODESTABLECLEAR		17
-       #define COLUMN_LREPROXYNODETABLECLEAR		18
-       #define COLUMN_LREDUPLISTRESIDEMAXTIME		19
-#endif /* LREINTERFACECONFIGTABLE_H */
diff --git a/agent/mibgroup/iec-62439-3-mib/lreManufacturerName.c b/agent/mibgroup/iec-62439-3-mib/lreManufacturerName.c
deleted file mode 100644
index 9d0c221..0000000
--- a/agent/mibgroup/iec-62439-3-mib/lreManufacturerName.c
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Note: this file originally auto-generated by mib2c using
- *        $
- */
-
-#include <net-snmp/net-snmp-config.h>
-#include <net-snmp/net-snmp-includes.h>
-#include <net-snmp/agent/net-snmp-agent-includes.h>
-#include "lreManufacturerName.h"
-
-/* can be overridden by snmpd.conf override attribute for a specific
- * LRE to match the manufacture name
- */
-#define default_lreManufacturerName "Linux"
-
-/** Initializes the lreManufacturerName module */
-void
-init_lreManufacturerName(void)
-{
-    const oid lreManufacturerName_oid[] = { 1,0,62439,2,21,0,0,1 };
-
-  DEBUGMSGTL(("lreManufacturerName", "Initializing\n"));
-    printf("init_lreManufacturerName");
-
-    netsnmp_register_scalar(
-        netsnmp_create_handler_registration("lreManufacturerName", handle_lreManufacturerName,
-                               lreManufacturerName_oid, OID_LENGTH(lreManufacturerName_oid),
-                               HANDLER_CAN_RONLY
-        ));
-}
-
-int
-handle_lreManufacturerName(netsnmp_mib_handler *handler,
-                          netsnmp_handler_registration *reginfo,
-                          netsnmp_agent_request_info   *reqinfo,
-                          netsnmp_request_info         *requests)
-{
-    /* We are never called for a GETNEXT if it's registered as a
-       "instance", as it's "magically" handled for us.  */
-
-    char name[64];
-    printf("handle_lreManufacturerName");
-    /* a instance handler also only hands us one request at a time, so
-       we don't need to loop over a list of requests; we'll only get one. */
- 
-    switch(reqinfo->mode) {
-
-        case MODE_GET:
-	    strncpy(&name[0], default_lreManufacturerName, sizeof(name)-1);
-	    name[sizeof(name)-1] = '\0';
-            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
-                                     &name[0] /* XXX: a pointer to the scalar's data */,
-                                     sizeof(name) /* XXX: the length of the data in bytes */);
-            break;
-
-
-        default:
-            /* we should never get here, so this is a really bad error */
-            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lreManufacturerName\n", reqinfo->mode );
-            return SNMP_ERR_GENERR;
-    }
-
-    return SNMP_ERR_NOERROR;
-}
diff --git a/agent/mibgroup/iec-62439-3-mib/lreManufacturerName.h b/agent/mibgroup/iec-62439-3-mib/lreManufacturerName.h
deleted file mode 100644
index c9fcd2c..0000000
--- a/agent/mibgroup/iec-62439-3-mib/lreManufacturerName.h
+++ /dev/null
@@ -1,12 +0,0 @@
-/*
- * Note: this file originally auto-generated by mib2c using
- *        $
- */
-#ifndef LREMANUFACTURERNAME_H
-#define LREMANUFACTURERNAME_H
-
-/* function declarations */
-void init_lreManufacturerName(void);
-Netsnmp_Node_Handler handle_lreManufacturerName;
-
-#endif /* LREMANUFACTURERNAME_H */
-- 
1.9.1

