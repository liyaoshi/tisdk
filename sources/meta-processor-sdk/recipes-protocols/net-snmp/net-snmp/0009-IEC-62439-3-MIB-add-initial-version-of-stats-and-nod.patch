From 5d2e1b3538156a115d16a4cfcf7ad6c9475dac6b Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Wed, 24 May 2017 12:10:47 -0400
Subject: [PATCH 09/12] IEC-62439-3-MIB: add initial version of stats and
 node_table code

Using mib2c, generate the template code for lreInterface_statsTable
and lreNodesTable.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
---
 .../defaults/node-lreCntDuplicateA.m2d             |   35 +
 .../defaults/node-lreCntDuplicateB.m2d             |   35 +
 .../defaults/node-lreCntDuplicateC.m2d             |   35 +
 .../defaults/node-lreCntErrWrongLanA.m2d           |   35 +
 .../defaults/node-lreCntErrWrongLanB.m2d           |   35 +
 .../defaults/node-lreCntErrWrongLanC.m2d           |   35 +
 .../defaults/node-lreCntErrorsA.m2d                |   35 +
 .../defaults/node-lreCntErrorsB.m2d                |   35 +
 .../defaults/node-lreCntErrorsC.m2d                |   35 +
 .../defaults/node-lreCntMultiA.m2d                 |   35 +
 .../defaults/node-lreCntMultiB.m2d                 |   35 +
 .../defaults/node-lreCntMultiC.m2d                 |   35 +
 .../defaults/node-lreCntNodes.m2d                  |   35 +
 .../defaults/node-lreCntOwnRxA.m2d                 |   35 +
 .../defaults/node-lreCntOwnRxB.m2d                 |   35 +
 .../defaults/node-lreCntProxyNodes.m2d             |   35 +
 .../defaults/node-lreCntRxA.m2d                    |   35 +
 .../defaults/node-lreCntRxB.m2d                    |   35 +
 .../defaults/node-lreCntRxC.m2d                    |   35 +
 .../defaults/node-lreCntTxA.m2d                    |   35 +
 .../defaults/node-lreCntTxB.m2d                    |   35 +
 .../defaults/node-lreCntTxC.m2d                    |   35 +
 .../defaults/node-lreCntUniqueA.m2d                |   35 +
 .../defaults/node-lreCntUniqueB.m2d                |   35 +
 .../defaults/node-lreCntUniqueC.m2d                |   35 +
 .../defaults/node-lreInterfaceStatsIndex.m2d       |   35 +
 .../defaults/table-lreInterfaceStatsTable.m2d      |  103 ++
 .../lreInterfaceStatsTable-README-FIRST.txt        |  167 +++
 ...aceStatsTable-README-lreInterfaceStatsTable.txt | 1128 +++++++++++++++
 .../lreInterfaceStatsTable.c                       |  202 +++
 .../lreInterfaceStatsTable.h                       |  305 ++++
 .../lreInterfaceStatsTable_data_access.c           |  559 +++++++
 .../lreInterfaceStatsTable_data_access.h           |   76 +
 .../lreInterfaceStatsTable_data_get.c              | 1518 ++++++++++++++++++++
 .../lreInterfaceStatsTable_data_get.h              |   83 ++
 .../lreInterfaceStatsTable_data_set.c              |   25 +
 .../lreInterfaceStatsTable_data_set.h              |   27 +
 .../lreInterfaceStatsTable_enums.h                 |   40 +
 .../lreInterfaceStatsTable_interface.c             | 1034 +++++++++++++
 .../lreInterfaceStatsTable_interface.h             |   84 ++
 .../lreInterfaceStatsTable_oids.h                  |   81 ++
 .../defaults/node-lreInterfaceStatsIndex.m2d       |   35 +
 .../lreNodesTable/defaults/node-lreNodesIndex.m2d  |   35 +
 .../defaults/node-lreNodesMacAddress.m2d           |   43 +
 .../lreNodesTable/defaults/node-lreRemNodeType.m2d |   35 +
 .../defaults/node-lreTimeLastSeenA.m2d             |   35 +
 .../defaults/node-lreTimeLastSeenB.m2d             |   35 +
 .../lreNodesTable/defaults/table-lreNodesTable.m2d |  103 ++
 .../lreNodesTable/lreNodesTable-README-FIRST.txt   |  167 +++
 .../lreNodesTable-README-lreNodesTable.txt         |  552 +++++++
 .../IEC-62439-3-MIB/lreNodesTable/lreNodesTable.c  |  202 +++
 .../IEC-62439-3-MIB/lreNodesTable/lreNodesTable.h  |  206 +++
 .../lreNodesTable/lreNodesTable_data_access.c      |  427 ++++++
 .../lreNodesTable/lreNodesTable_data_access.h      |   76 +
 .../lreNodesTable/lreNodesTable_data_get.c         |  364 +++++
 .../lreNodesTable/lreNodesTable_data_get.h         |   62 +
 .../lreNodesTable/lreNodesTable_data_set.c         |   25 +
 .../lreNodesTable/lreNodesTable_data_set.h         |   27 +
 .../lreNodesTable/lreNodesTable_enums.h            |   60 +
 .../lreNodesTable/lreNodesTable_interface.c        |  903 ++++++++++++
 .../lreNodesTable/lreNodesTable_interface.h        |   84 ++
 .../lreNodesTable/lreNodesTable_oids.h             |   39 +
 62 files changed, 9857 insertions(+)
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntDuplicateA.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntDuplicateB.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntDuplicateC.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrWrongLanA.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrWrongLanB.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrWrongLanC.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrorsA.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrorsB.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrorsC.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntMultiA.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntMultiB.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntMultiC.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntNodes.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntOwnRxA.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntOwnRxB.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntProxyNodes.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntRxA.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntRxB.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntRxC.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntTxA.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntTxB.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntTxC.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntUniqueA.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntUniqueB.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntUniqueC.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreInterfaceStatsIndex.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/table-lreInterfaceStatsTable.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable-README-FIRST.txt
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable-README-lreInterfaceStatsTable.txt
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_access.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_access.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_get.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_get.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_set.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_set.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_enums.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_interface.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_interface.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_oids.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreInterfaceStatsIndex.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreNodesIndex.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreNodesMacAddress.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreRemNodeType.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreTimeLastSeenA.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreTimeLastSeenB.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/table-lreNodesTable.m2d
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable-README-FIRST.txt
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable-README-lreNodesTable.txt
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_access.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_access.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_get.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_get.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_set.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_set.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_enums.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_interface.c
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_interface.h
 create mode 100644 agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_oids.h

diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntDuplicateA.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntDuplicateA.m2d
new file mode 100644
index 0000000..bd7e88a
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntDuplicateA.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntDuplicateA
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntDuplicateB.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntDuplicateB.m2d
new file mode 100644
index 0000000..c50a7c7
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntDuplicateB.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntDuplicateB
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntDuplicateC.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntDuplicateC.m2d
new file mode 100644
index 0000000..ebecd38
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntDuplicateC.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntDuplicateC
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrWrongLanA.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrWrongLanA.m2d
new file mode 100644
index 0000000..163cbf6
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrWrongLanA.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntErrWrongLanA
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrWrongLanB.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrWrongLanB.m2d
new file mode 100644
index 0000000..b9e173c
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrWrongLanB.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntErrWrongLanB
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrWrongLanC.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrWrongLanC.m2d
new file mode 100644
index 0000000..71ca611
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrWrongLanC.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntErrWrongLanC
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrorsA.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrorsA.m2d
new file mode 100644
index 0000000..dc2bcb6
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrorsA.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntErrorsA
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrorsB.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrorsB.m2d
new file mode 100644
index 0000000..ad28e35
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrorsB.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntErrorsB
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrorsC.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrorsC.m2d
new file mode 100644
index 0000000..24909f6
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntErrorsC.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntErrorsC
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntMultiA.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntMultiA.m2d
new file mode 100644
index 0000000..347b7c5
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntMultiA.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntMultiA
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntMultiB.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntMultiB.m2d
new file mode 100644
index 0000000..56e5e4a
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntMultiB.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntMultiB
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntMultiC.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntMultiC.m2d
new file mode 100644
index 0000000..3646922
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntMultiC.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntMultiC
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntNodes.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntNodes.m2d
new file mode 100644
index 0000000..a387fac
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntNodes.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntNodes
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntOwnRxA.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntOwnRxA.m2d
new file mode 100644
index 0000000..e3041f9
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntOwnRxA.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntOwnRxA
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntOwnRxB.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntOwnRxB.m2d
new file mode 100644
index 0000000..dae81e6
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntOwnRxB.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntOwnRxB
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntProxyNodes.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntProxyNodes.m2d
new file mode 100644
index 0000000..2557fad
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntProxyNodes.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntProxyNodes
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntRxA.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntRxA.m2d
new file mode 100644
index 0000000..6a6ac34
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntRxA.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntRxA
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntRxB.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntRxB.m2d
new file mode 100644
index 0000000..2a6ddf6
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntRxB.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntRxB
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntRxC.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntRxC.m2d
new file mode 100644
index 0000000..aeb4363
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntRxC.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntRxC
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntTxA.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntTxA.m2d
new file mode 100644
index 0000000..6e521e6
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntTxA.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntTxA
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntTxB.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntTxB.m2d
new file mode 100644
index 0000000..6989fde
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntTxB.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntTxB
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntTxC.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntTxC.m2d
new file mode 100644
index 0000000..3c02cbe
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntTxC.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntTxC
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntUniqueA.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntUniqueA.m2d
new file mode 100644
index 0000000..ad8814e
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntUniqueA.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntUniqueA
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntUniqueB.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntUniqueB.m2d
new file mode 100644
index 0000000..bd0db02
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntUniqueB.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntUniqueB
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntUniqueC.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntUniqueC.m2d
new file mode 100644
index 0000000..d59c42e
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreCntUniqueC.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreCntUniqueC
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreInterfaceStatsIndex.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreInterfaceStatsIndex.m2d
new file mode 100644
index 0000000..69942dd
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/node-lreInterfaceStatsIndex.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreInterfaceStatsIndex
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/table-lreInterfaceStatsTable.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/table-lreInterfaceStatsTable.m2d
new file mode 100644
index 0000000..a11a68e
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/defaults/table-lreInterfaceStatsTable.m2d
@@ -0,0 +1,103 @@
+## ########################################################################
+##
+## mib2c Table setting for lreInterfaceStatsTable
+##
+## ########################################################################
+##
+## User context structure type
+##
+@eval $m2c_context_reg = "netsnmp_data_list"@
+##
+## ########################################################################
+##
+## Allocate data structure in row structure? (vs embedd)
+##
+@eval $m2c_data_allocate = 0@
+##
+## ########################################################################
+##
+## Generate code to cache data?
+##
+@eval $m2c_data_cache = 1@
+##
+## ########################################################################
+##
+## Data context structure type
+##
+@eval $m2c_data_context = "generated"@ [generated|NAME]
+##
+## ########################################################################
+##
+## Generate function to initialize row context when created?
+##
+@eval $m2c_data_init = 1@
+##
+## ########################################################################
+##
+## Persistence of data context
+## // 0:persistent, 1:semi-transient, 2:transient
+##
+@eval $m2c_data_transient = 2@
+##
+## ########################################################################
+##
+## Include some example code?
+##
+@eval $m2c_include_examples = 1@
+##
+## ########################################################################
+##
+## Generate code for irreversible_commit mode?
+##
+@eval $m2c_irreversible_commit = 0@
+##
+## ########################################################################
+##
+## Data access method
+##
+@eval $m2c_table_access = "container-cached"@
+##
+## ########################################################################
+##
+## Generate row dependency function?
+##
+@eval $m2c_table_dependencies = 0@
+##
+## ########################################################################
+##
+## Generate data store/restore functions for persistent storage?
+##
+@eval $m2c_table_persistent = 0@
+##
+## ########################################################################
+##
+## Generate code for dynamic row creation?
+##
+@eval $m2c_table_row_creation = 0@
+##
+## ########################################################################
+##
+## Generate code for settable objects?
+##
+@eval $m2c_table_settable = 0@
+##
+## ########################################################################
+##
+## Skip mapping between data context and MIB formats?
+## // 0:generate maps, 1:skip maps, -1:skip unless enum/oid
+##
+@eval $m2c_table_skip_mapping = 1@
+##
+## ########################################################################
+##
+## Generate code for sparse tables?
+##
+@eval $m2c_table_sparse = 0@
+##
+## ########################################################################
+##
+## Generate Makefile/AgentX code?
+##
+@eval $mfd_generate_makefile = 0@
+@eval $mfd_generate_subagent = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable-README-FIRST.txt b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable-README-FIRST.txt
new file mode 100644
index 0000000..e2d9345
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable-README-FIRST.txt
@@ -0,0 +1,167 @@
+************************************************************************
+lreInterfaceStatsTable README
+------------------------------------------------------------------------
+This document describes the results of the mib2c code generation
+system using the mfd code generation template.  The resulting files
+are documented both in this README file as well as per-table specific
+README files.  All of the files generated by this run of mib2c will
+begin with the lreInterfaceStatsTable prefix.
+
+Quick Start
+-----------
+For those interested in a quick start, to get a pseudo-todo list, try
+this command in directory with the generated code:
+
+ grep -n "TODO:" *.[ch] | sed 's/\([^ ]*\) \(.*\)TODO\(.*\)/\3 (\1)/' | sort -n
+
+Key:
+  :o: Optional
+  :r: Recommended
+  :M: Mandatory
+  :A: Advanced users
+
+This will give you and ordered list of places in the code that you
+may (or must) take a closer look at).
+
+You may also want to take a look at the on-line tutorial, found here:
+
+    http://www.net-snmp.org/tutorial/tutorial-5/toolkit/mfd/index.html
+
+
+MIBs For Dummies Overview
+-------------------------
+The MIBs For Dummies (MFD) configuration files have been written to help
+SNMP novices implement SNMP MIBs. This section will be a brief
+introduction to some of the general concepts you should be familar with.
+
+  Managed Information Base (MIB)
+  ------------------------------
+  A SNMP MIB (Managed information base) is a text file that describes the
+  syntax for some set of data objects. The MIB creates a correlation
+  between an ASCII name for an object and a number OID (Object Identifier).
+  The SNMP protocol communicates information using the OIDs, and the MIB
+  allows tools to display a name, which we humans find easier to deal with.
+
+  To use an analogy, a MIB is much like a menu at a restaurant. If you've
+  ever been to a reataurant and ordered a meal, and later received a bill
+  that simply had '#6' on it, you get the idea. The name is easier for
+  the customers to remember, and the waiters and chefs use the number for
+  efficency.
+
+
+    Scalars
+    -------
+    A scalar variable is a unique object in a MIB which can represent
+    a single value. For example, the SNMP standard MIB-II defines a
+    variable, sysContact.0, which is a string containing the contact
+    information for the person in charge of a particular agent. Note
+    that scalar variable always end with '.0'.
+    
+
+    Rows and Tables
+    ---------------
+    When a group of related attributes occur more than once, they can be
+    grouped together in a table. A table has an index, which uniquely
+    identifies a particular row, and data columns, which contain the
+    attributes for that row.
+
+    For example, the SNMP standard MIB-II defines a table, ifTable, which
+    contains information on the ethernet interfaces on a system.
+    
+
+  Data Structures
+  ---------------
+  The code generated by the MFD configuration files has a few important
+  structures.
+
+
+    The Data Context
+    ----------------
+    The data context structure should contain the necessary information
+    to provide the data for the columns in a given row. As long as you
+    can extract the data for a column for the data context, the data context
+    can be anything you want: a pointer to an existing structure, the
+    parameters needed for a function call or an actual copy of the data.
+
+    By default, a data context structure is generated with storage for
+    all the data in a row. Information on changing the default is presented
+    later on in this help.
+
+
+    The MIB Context
+    ---------------
+    The MIB context structure is generated with storage for all the
+    indexes of a table. This data will be used when searching for the
+    correct row to process for a request.
+
+
+    The Row Request Context
+    -----------------------
+    Each table will have a unique data structure for holding data during
+    the processing of a particular row. The row request context contains
+    the registration context (that you supply during initilization),
+    the data context, the MIB context, the undo context (for settable
+    tables) and other data. There is also a netsnmp_data_list, which can
+    be used to temporary storage during processing.
+
+
+    The Table Registration Pointer
+    ------------------------------
+    During initilization, you may provide a pointer to arbitrary data for
+    you own use. This pointer will be saved in the row request context,
+    and is passed as a parameter to several functions. It is not required,
+    and is provided as a way for you to access table specific data in
+    the generated code.
+
+
+
+These files are top-level files potentially useful for all the tables: 
+------------------------------------------------------------------------
+
+  File    : lreInterfaceStatsTable_Makefile
+  ----------------------------------------------------------------------
+  Purpose : Make file for compiling a (sub)agent.  This file is only
+            useful if you don't want to compile your code directly
+            into the Net-SNMP master agent.
+  Editable: Optional
+  Usage   : make -f lreInterfaceStatsTable_Makefile
+
+
+  File    : lreInterfaceStatsTable_subagent.c
+  ----------------------------------------------------------------------
+  Purpose : This file contains a main() function for an agent or
+            sub-agent and is compiled using the Makefile above.
+
+
+
+
+Table specific README files
+------------------------------------------------------------------------
+Each table for which code was generated has its own README file
+describing the files specifically associated with each table.  You
+should probably read these next:
+
+   lreInterfaceStatsTable-README-lreInterfaceStatsTable.txt
+
+
+
+These are miscellaneous auto-generated code files you generally
+shouldn't edit.  They contain code that ties your code together with
+the Net-SNMP agent.
+------------------------------------------------------------------------
+  File    : lreInterfaceStatsTable.h
+  Purpose : Header file for the module set.  Includes config_require
+            macros to auto-load the other code pieces when compiled
+            into the agent.
+
+  File    : lreInterfaceStatsTable_oids.h
+  Purpose : C #define definitions of the tables, columns, and OIDs
+
+  File    : lreInterfaceStatsTable_enums.h
+  Purpose : C #define definitions of the enumerated type values for
+            each column of each table that requires them.
+
+  File    : lreInterfaceStatsTable_interface.c
+  Purpose : MFD interface to Net-SNMP.  This auto-generated code ties the
+            functions you will fill out to the code that the agent needs.
+
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable-README-lreInterfaceStatsTable.txt b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable-README-lreInterfaceStatsTable.txt
new file mode 100644
index 0000000..a7bdc2b
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable-README-lreInterfaceStatsTable.txt
@@ -0,0 +1,1128 @@
+************************************************************************
+lreInterfaceStatsTable README
+------------------------------------------------------------------------
+  This readme file describes the code generated by mib2c (using the MIBs
+  for Dummies (MFD) configuration file). The code generated was
+  generated specifically for the following SNMP table:
+
+     lreInterfaceStatsTable
+
+  Your code will be called when the snmp agent receives requests for
+  the lreInterfaceStatsTable table.  The agent will start by looking for the right
+  row in your existing data to operate on, if one exists.
+
+
+  Configuration Variables
+  ------------------------------------------------------------
+  Some variables used for code generation may be set to affect the code
+  generation. You may override these variables by setting them in the
+  file defaults/table-lreInterfaceStatsTable.m2d, and then re-running mib2c.
+
+    m2c_table_settable (currently '0')
+    --------------------------------------------------------
+    This variable determines whether or not code is generated to support
+    MIB object which have an access of read-write or read-create. The
+    default is set based on whether or not the table contains writable
+    objects, but can be over-ridden.
+
+    Syntax: @eval $m2c_table_settable = 0@
+
+
+    m2c_table_dependencies (currently '0')
+    --------------------------------------------------------
+    This variable determines whether or not code is generated to support
+    checking dependencies between columns, rows or tables. The default
+    is set based on whether or not the table contains writable objects,
+    but can be over-ridden.
+
+    Syntax: @eval $m2c_table_dependencies = 0@
+
+
+    m2c_table_row_creation (currently '0')
+    --------------------------------------------------------
+    This variable determines whether or not code is generated to support
+    checking creation of new rows via SNMP. The default is set based on
+    whether or not the table contains read-create objects, but can be
+    over-ridden.
+
+    Syntax: @eval $m2c_table_row_creation = 0@
+
+
+    m2c_context_reg (currently 'netsnmp_data_list')
+    --------------------------------------------------------
+    This variable contains the structure name to typedef for the
+    lreInterfaceStatsTable_registration.
+
+    During initilization, you will provide a pointer to a structure of
+    this type. This pointer is used as a parameter to many functions so
+    that you have access to your registration data. The default is a
+    netsnmp_data_list pointer, which will allow you to keep multiple
+    pointers tagged by a text name. If you have a new or existing structure
+    you would rather use, you can redefine this variable.
+    
+
+    To avoid regenerating code, you may also change this typedef directly
+    in the lreInterfaceStatsTable.h header.
+
+    Syntax: @eval $m2c_context_reg = "struct my_registration_context@
+
+
+    m2c_data_context (currently 'generated')
+    --------------------------------------------------------
+    This variable contains the structure name to typedef for the
+    lreInterfaceStatsTable_data.
+
+    This typedef is used in the row request context structure for the table,
+    lreInterfaceStatsTable_rowreq_ctx.
+
+    The typedef in the primary table context will be used for the data and
+    undo structure types. This structure should contain all the data
+    needed for all the columns in the table. The default is 'generated',
+    which will cuase a new data strcuture to be generated with data members
+    for each column.
+
+    To avoid regenerating code, you may also change this typedef directly
+    in the lreInterfaceStatsTable.h header.
+
+    Syntax: @eval $m2c_data_context = "struct my_data_context"@
+
+
+    m2c_data_allocate (currently '0')
+    --------------------------------------------------------
+    This variable determines whether or not the data context (see above)
+    requires memory to be allocated. The default generated data structure
+    does not. If you are using a custom data context which needs to
+    allocate memory, override this value and two additional functions
+    will be generated:
+
+      lreInterfaceStatsTable_allocate_data
+      lreInterfaceStatsTable_release_data
+
+    Syntax: @eval $m2c_data_allocate = 1@
+
+
+    m2c_data_init (currently '1')
+    --------------------------------------------------------
+    This variable determines whether or not the data context (see above)
+    or any other items you have added to the table context requires
+    initialization. The default generated data structure does not. If you
+    are using a custom data context or have added items needing initialization
+    to the table context, override this value and two additional functions
+    will be generated:
+
+      lreInterfaceStatsTable_rowreq_ctx_init
+      lreInterfaceStatsTable_rowreq_ctx_cleanup
+
+    Syntax: @eval 1 = 1@
+
+
+    m2c_table_access (currently 'container-cached')
+    ------------------------------------------------------------------
+    This variable determines which data interface will be use to generate
+    code for looking up data for a given index. The default is the
+    'container-cached' access code, which caches the data in a netsnmp-
+    container (usually a sorted array).
+
+    Available options can be determined by checking for mib2c configuration
+    files that begin with 'mfd-access-*'.
+
+    Syntax: @eval $m2c_table_access = 'container-cached'@
+
+ 
+    m2c_include_examples (currently '1')
+    ------------------------------------------------------------------
+    This variable determines whether or not to generate example code. The
+    default is to generate example code.
+
+    Syntax: @eval $m2c_include_examples = 0@
+
+
+    m2c_data_transient (currently '2')
+    ------------------------------------------------------------------
+    This variable determines how the generated example code deals with the
+    data during data lookup. See the table readme file for details on how
+    the current table access method interprets this value. In general,
+    a value of 0 indicates persistent data, 1 indicates semi-transient and
+    2 indicates transient data.
+
+    Syntax: @eval $m2c_data_transient = 0@
+
+
+ Index(es) for the lreInterfaceStatsTable table
+  ------------------------------------------------------------
+  The index(es) for the lreInterfaceStatsTable table are:
+
+     lreInterfaceStatsIndex:
+        Syntax:      UNSIGNED32
+        DataType:    UNSIGNED32
+        ASN type:    ASN_UNSIGNED
+        C-code type: u_long
+
+  You should know how to set all these values from your data context,
+  lreInterfaceStatsTable_data.
+
+
+************************************************************************
+lreInterfaceStatsTable File Overview
+------------------------------------------------------------------------
+  Several files have been generated to implement the lreInterfaceStatsTable
+  table. We'll go through these files, one by one, explaining each and
+  letting you know which you need to edit.
+
+
+File: lreInterfaceStatsTable_data_access.[c|h]
+------------------------------------------------------------------------
+  The lreInterfaceStatsTable_data_access file contains the interface to your data in
+  its raw format.  These functions are used to build the row cache or 
+  locate the row (depending on the table access method).
+
+  Set MIB context
+  -----------------
+  TODO : Set MIB index values
+  FUNC : lreInterfaceStatsTable_indexes_set
+  WHERE: lreInterfaceStatsTable_data_access.c
+
+  This is a convenience function for setting the index context from
+  the native C data. Where necessary, value mapping should be done.
+
+  This function should update the table index values (found in
+  tbl_idx) for the given raw data.
+
+  
+  container summary
+  ------------------------
+    The container data access code is for cases when you want to
+    store your data in the agent/sub-agent.
+
+    ... to be continued...
+
+
+  cache summary
+  ------------------------
+    The container-cached data access code is for cases when you want to
+    cache your data in the agent/sub-agent.
+
+    ... to be continued...
+
+
+
+
+File: lreInterfaceStatsTable_enums.h
+------------------------------------------------------------------------
+  This file contains macros for mapping enumeration values when the
+  enumerated values defined by the MIB do not match the values used
+  internally.
+
+  Review this file to see if any values need to be updated.
+
+
+File: lreInterfaceStatsTable_data_get.c
+------------------------------------------------------------------------
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntTxA_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntTxB_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntTxC_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntErrWrongLanA_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntErrWrongLanB_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntErrWrongLanC_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntRxA_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntRxB_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntRxC_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntErrorsA_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntErrorsB_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntErrorsC_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntNodes_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntProxyNodes_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntUniqueA_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntUniqueB_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntUniqueC_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntDuplicateA_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntDuplicateB_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntDuplicateC_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntMultiA_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntMultiB_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntMultiC_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntOwnRxA_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreCntOwnRxB_get
+
+
+
+File: lreInterfaceStatsTable_data_set.c
+------------------------------------------------------------------------
+
+  This table does not support set requests.
+
+
+************************************************************************
+lreInterfaceStatsTable Reference
+------------------------------------------------------------------------
+
+Function flow
+----------------------------------------------------
+To give you the general idea of how the functions flow works, this
+example flow is from a complete table implementation.
+
+NOTE: Depending on your configuration, some of the functions used in the
+      examples below  may not have been generated for the
+      lreInterfaceStatsTable table.
+
+      Conversely, the examples below may not include some functions that
+      were generated for the lreInterfaceStatsTable table.
+
+To watch the flow of the lreInterfaceStatsTable table, use the
+following debug tokens:
+
+        snmp_agent
+        helper:table:req
+        lreInterfaceStatsTable
+        verbose:lreInterfaceStatsTable
+        internal:lreInterfaceStatsTable
+
+e.g.
+        snmpd -f -Le -DlreInterfaceStatsTable,verbose:lreInterfaceStatsTable,internal:lreInterfaceStatsTable
+
+
+Initialization
+--------------------------------
+init_xxxTable: called                           xxx.c
+   initialize_table_xxxTable                    xxx.c
+      _xxxTable_initialize_interface            xxx_interface.c
+         xxxTable_init_data                     xxx_data_access.c
+      _xxxTable_container_init                  xxx_interface.c
+         xxxTable_container_init                xxx_data_access.c
+
+
+GET Request
+--------------------------------
+_cache_load                                     xxx_interface.c
+   xxxTable_cache_load                          xxx_data_access.c
+      xxxTable_allocate_rowreq_ctx              xxx_interface.c
+         xxxTable_allocate_data                 xxx_data_get.c
+         xxxTable_rowreq_ctx_init               xxx_data_get.c
+      xxxTable_indexes_set                      xxx_data_get.c
+         xxxTable_indexes_set_tbl_idx           xxx_data_get.c
+
+xxxTable_pre_request                              
+
+_mfd_xxxTable_object_lookup                     xxx_interface.c
+   xxxTable_row_prep                            xxx_data_access.c
+
+_mfd_xxxTable_get_values                        xxx_interface.c
+   _mfd_xxxTable_get_column                     xxx_interface.c
+      yyy_get                                   xxx_data_get.c
+
+xxxTable_post_request
+
+
+GETNEXT Request
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request                            ...
+_mfd_xxxTable_object_lookup                     ...
+_mfd_xxxTable_get_values                        ...
+xxxTable_post_request                           ...
+
+
+SET Request: success
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request
+_mfd_xxxTable_object_lookup                     ...
+
+_mfd_xxxTable_check_objects                     xxx_interface.c
+   _xxxTable_check_column                       xxx_interface.c
+      yyy_check_value                           xxx_data_set.c
+
+_mfd_xxxTable_undo_setup                        xxx_interface.c
+   xxxTable_allocate_data                       ...
+   xxxTable_undo_setup                          xxx_interface.c
+      _xxxTable_undo_setup_column               xxx_interface.c
+         yyy_undo_setup                         xxx_data_set.c
+
+_mfd_xxxTable_set_values                        xxx_interface.c
+   _xxxTable_set_column                         xxx_interface.c
+      yyy_set                                   xxx_data_set.c
+
+_mfd_xxxTable_check_dependencies                xxx_interface.c
+   xxxTable_check_dependencies                  xxx_data_set.c
+
+_mfd_xxxTable_commit                            xxx_interface.c
+   xxxTable_commit                              xxx_data_set.c
+
+_mfd_xxxTable_undo_cleanup                      xxx_interface.c
+   xxxTable_undo_cleanup                        xxx_data_set.c
+      xxxTable_release_data                     ...
+
+xxxTable_post_request                           ...
+
+
+SET Request: row creation
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request
+
+_mfd_xxxTable_object_lookup                     ...
+   xxxTable_index_from_oid                      xxx_interface.c
+   xxxTable_allocate_rowreq_ctx                 ...
+      ...
+   _xxxTable_check_indexes                      xxx_interface.c
+      yyy_check_index                           xxx_data_set.c
+      xxxTable_validate_index                   xxx_data_set.c
+
+_mfd_xxxTable_check_objects                     ...
+   _xxxTable_check_column                       ...
+      yyy_check_value                           ...
+   _xxxTable_check_column                       ...
+      yyy_check_value                           ...
+
+_mfd_xxxTable_undo_setup                        ...
+_mfd_xxxTable_set_values                        ...
+_mfd_xxxTable_check_dependencies                ...
+_mfd_xxxTable_commit                            ...
+_mfd_xxxTable_undo_cleanup                      ...
+xxxTable_post_request                           ...
+
+
+SET Resuest: value error
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request                            ...
+_mfd_xxxTable_object_lookup                     ...
+
+_mfd_xxxTable_check_objects                     ...
+   _xxxTable_check_column                       ...
+      yyy_check_value                           ...
+      ERROR:"yyy value not supported"
+
+xxxTable_post_request                           ...
+
+
+SET Request: commit failure
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request                            ...
+_mfd_xxxTable_object_lookup                     ...
+_mfd_xxxTable_check_objects                     ...
+_mfd_xxxTable_undo_setup                        ...
+_mfd_xxxTable_set_values                        ...
+_mfd_xxxTable_check_dependencies                ...
+
+_mfd_xxxTable_commit                            ...
+   xxxTable_commit                              ...
+   ERROR: bad rc -1
+
+_mfd_xxxTable_undo_commit                       xxx_interface.c
+   xxxTable_undo_commit                         xxx_data_set.c
+
+_mfd_xxxTable_undo_values                       xxx_interface.c
+   _xxxTable_undo_column                        xxx_interface.c
+      yyy_undo                                  xxx_data_set.c
+
+_mfd_xxxTable_undo_cleanup                      ...
+xxxTable_post_request                           ...
+
+
+Row release (user initiated)
+--------------------------------
+xxxTable_release_rowreq_ctx                     xxx_interface.c
+   xxxTable_rowreq_ctx_cleanup                  xxx_data_get.c
+   xxxTable_release_data                        xxx_data_get.c
+
+
+
+Table / column details
+----------------------------------------------------
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceStatsTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceStatsTable is subid 1 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.1, length: 9
+*/
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreInterfaceStatsIndex
+ * lreInterfaceStatsIndex is subid 1 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is NoAccess.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.1
+ * Description:
+A unique value for each LRE.
+ *
+ * Attributes:
+ *   accessible 0     isscalar 0     enums  0      hasdefval 0
+ *   readable   0     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
+ * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
+ *
+ *
+ *
+ * NOTE: NODE lreInterfaceStatsIndex IS NOT ACCESSIBLE
+ *
+ *
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntTxA
+ * lreCntTxA is subid 2 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.2
+ * Description:
+
+                number of frames sent over port A that are HSR tagged or
+                fitted with a PRP
+                Redundancy Control Trailer.
+                Only frames that are HSR tagged or do have a PRP RCT are counted.
+                A frame aborted during the transmission is not counted.
+                Initial value = 0.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntTxB
+ * lreCntTxB is subid 3 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.3
+ * Description:
+
+                number of frames sent over port B that are HSR tagged or
+                fitted with a PRP
+                Redundancy Control Trailer.
+                Only frames that are HSR tagged or do have a PRP RCT are counted.
+                A frame aborted during the transmission is not counted.
+                Initial value = 0.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntTxC
+ * lreCntTxC is subid 4 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.4
+ * Description:
+
+                number of frames sent towards the application interface of
+                the DANP or DANH
+                or over the interlink of the RedBox. Frames with and without PRP RCT or HSR
+                tag are counted, but not link-local frames.
+                A frame aborted during the transmission is not counted.
+                Initial value = 0.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntErrWrongLanA
+ * lreCntErrWrongLanA is subid 5 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.5
+ * Description:
+
+                number of frames with the wrong LAN identifier received on
+                LRE port A.
+                Initial value = 0. Only applicable to PRP ports.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntErrWrongLanB
+ * lreCntErrWrongLanB is subid 6 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.6
+ * Description:
+
+                number of frames with the wrong LAN identifier received on
+                LRE port B
+                Initial value = 0. Only applicable to PRP ports.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntErrWrongLanC
+ * lreCntErrWrongLanC is subid 7 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.7
+ * Description:
+
+                number of frames with the wrong LAN identifier received on
+                the interlink of
+                a RedBox. Only applicable to HSR RedBoxes in HSR-PRP configuration
+                (hsrredboxprpa and hsrredboxprpb).
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntRxA
+ * lreCntRxA is subid 8 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.8
+ * Description:
+
+                number of frames received on a LRE port A. Only frames that
+                are HSR tagged
+                or fitted with a PRP Redundancy Control Trailer are counted. Frames that are
+                not forwarded anywhere (e.g. because the sender of the frame is in the proxy
+                node table) are counted, too. Only frames received completely and without
+                error are counted.
+                Initial value = 0.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntRxB
+ * lreCntRxB is subid 9 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.9
+ * Description:
+
+                number of frames received on a LRE port B. Only frames that
+                are HSR tagged
+                or fitted with a PRP Redundancy Control Trailer are counted. Frames that are
+                not forwarded anywhere (e.g. because the sender of the frame is in the proxy
+                node table) are counted, too. Only frames received completely and without
+                error are counted.
+                Initial value = 0.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntRxC
+ * lreCntRxC is subid 10 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.10
+ * Description:
+
+  number of frames received from the application interface of a
+  DANP or DANH or
+  the number of number of frames received on the interlink of a RedBox. Frames
+  with and without PRP RCT or HSR tag are counted, but not link-local frames.
+  Only frames received completely and without error are counted.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntErrorsA
+ * lreCntErrorsA is subid 11 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.11
+ * Description:
+
+  number of frames with errors received on this LRE port A.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntErrorsB
+ * lreCntErrorsB is subid 12 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.12
+ * Description:
+
+  number of frames with errors received on this LRE port B.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntErrorsC
+ * lreCntErrorsC is subid 13 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.13
+ * Description:
+
+  number of frames with errors received on the application
+  interface of a DANP or
+  DANH or on the interlink of a RedBox.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntNodes
+ * lreCntNodes is subid 14 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.14
+ * Description:
+number of nodes in the Nodes Table.
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is INTEGER32 (based on perltype INTEGER32)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntProxyNodes
+ * lreCntProxyNodes is subid 15 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.15
+ * Description:
+
+  number of nodes in the Proxy Node Table. Only applicable to
+  RedBox.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is INTEGER32 (based on perltype INTEGER32)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntUniqueA
+ * lreCntUniqueA is subid 16 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.16
+ * Description:
+
+  number of entries in the duplicate detection mechanism on
+  port A for which
+  no duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntUniqueB
+ * lreCntUniqueB is subid 17 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.17
+ * Description:
+
+  number of entries in the duplicate detection mechanism on
+  port B for which
+  no duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntUniqueC
+ * lreCntUniqueC is subid 18 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.18
+ * Description:
+
+  number of entries in the duplicate detection mechanism on the
+  application interface
+  of the DAN or the interlink of the RedBox for which no duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntDuplicateA
+ * lreCntDuplicateA is subid 19 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.19
+ * Description:
+
+  number of entries in the duplicate detection mechanism on
+  port A for which
+  one single duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntDuplicateB
+ * lreCntDuplicateB is subid 20 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.20
+ * Description:
+
+  number of entries in the duplicate detection mechanism on
+  port B for which
+  one single duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntDuplicateC
+ * lreCntDuplicateC is subid 21 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.21
+ * Description:
+
+  number of entries in the duplicate detection mechanism on the
+  application interface
+  of the DAN or the interlink of the RedBox for which one single duplicate was
+  received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntMultiA
+ * lreCntMultiA is subid 22 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.22
+ * Description:
+
+  number of entries in the duplicate detection mechanism on
+  port A for which
+  more than one duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntMultiB
+ * lreCntMultiB is subid 23 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.23
+ * Description:
+
+  number of entries in the duplicate detection mechanism on
+  port B for which
+  more than one duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntMultiC
+ * lreCntMultiC is subid 24 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.24
+ * Description:
+
+  number of entries in the duplicate detection mechanism on the
+  application interface
+  of the DAN or the interlink of the RedBox for which more than one duplicate was
+  received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntOwnRxA
+ * lreCntOwnRxA is subid 25 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.25
+ * Description:
+
+  number of HSR tagged frames received on Port A that
+  originated from this
+  device. Frames originate from this device if the source MAC matches the
+  MAC of the LRE, or if the source MAC appears in the proxy node table (if
+  implemented). Applicable only to HSR.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntOwnRxB
+ * lreCntOwnRxB is subid 26 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.26
+ * Description:
+
+  number of HSR tagged frames received on Port B that
+  originated from this
+  device. Frames originate from this device if the source MAC matches the
+  MAC of the LRE, or if the source MAC appears in the proxy node table (if
+  implemented). Applicable only to HSR.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+
+
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable.c b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable.c
new file mode 100644
index 0000000..9bb01ad
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable.c
@@ -0,0 +1,202 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $ 
+ *
+ * $Id:$
+ */
+/** \page MFD helper for lreInterfaceStatsTable
+ *
+ * \section intro Introduction
+ * Introductory text.
+ *
+ */
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreInterfaceStatsTable.h"
+
+#include <net-snmp/agent/mib_modules.h>
+
+#include "lreInterfaceStatsTable_interface.h"
+
+const oid lreInterfaceStatsTable_oid[] = { LREINTERFACESTATSTABLE_OID };
+const int lreInterfaceStatsTable_oid_size = OID_LENGTH(lreInterfaceStatsTable_oid);
+
+    lreInterfaceStatsTable_registration  lreInterfaceStatsTable_user_context;
+
+void initialize_table_lreInterfaceStatsTable(void);
+void shutdown_table_lreInterfaceStatsTable(void);
+
+
+/**
+ * Initializes the lreInterfaceStatsTable module
+ */
+void
+init_lreInterfaceStatsTable(void)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:init_lreInterfaceStatsTable","called\n"));
+
+    /*
+     * TODO:300:o: Perform lreInterfaceStatsTable one-time module initialization.
+     */
+     
+    /*
+     * here we initialize all the tables we're planning on supporting
+     */
+    if (should_init("lreInterfaceStatsTable"))
+        initialize_table_lreInterfaceStatsTable();
+
+} /* init_lreInterfaceStatsTable */
+
+/**
+ * Shut-down the lreInterfaceStatsTable module (agent is exiting)
+ */
+void
+shutdown_lreInterfaceStatsTable(void)
+{
+    if (should_init("lreInterfaceStatsTable"))
+        shutdown_table_lreInterfaceStatsTable();
+
+}
+
+/**
+ * Initialize the table lreInterfaceStatsTable 
+ *    (Define its contents and how it's structured)
+ */
+void
+initialize_table_lreInterfaceStatsTable(void)
+{
+    lreInterfaceStatsTable_registration * user_context;
+    u_long flags;
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:initialize_table_lreInterfaceStatsTable","called\n"));
+
+    /*
+     * TODO:301:o: Perform lreInterfaceStatsTable one-time table initialization.
+     */
+
+    /*
+     * TODO:302:o: |->Initialize lreInterfaceStatsTable user context
+     * if you'd like to pass in a pointer to some data for this
+     * table, allocate or set it up here.
+     */
+    /*
+     * a netsnmp_data_list is a simple way to store void pointers. A simple
+     * string token is used to add, find or remove pointers.
+     */
+    user_context = netsnmp_create_data_list("lreInterfaceStatsTable", NULL, NULL);
+    
+    /*
+     * No support for any flags yet, but in the future you would
+     * set any flags here.
+     */
+    flags = 0;
+    
+    /*
+     * call interface initialization code
+     */
+    _lreInterfaceStatsTable_initialize_interface(user_context, flags);
+} /* initialize_table_lreInterfaceStatsTable */
+
+/**
+ * Shutdown the table lreInterfaceStatsTable 
+ */
+void
+shutdown_table_lreInterfaceStatsTable(void)
+{
+    /*
+     * call interface shutdown code
+     */
+    _lreInterfaceStatsTable_shutdown_interface(&lreInterfaceStatsTable_user_context);
+}
+
+/**
+ * extra context initialization (eg default values)
+ *
+ * @param rowreq_ctx    : row request context
+ * @param user_init_ctx : void pointer for user (parameter to rowreq_ctx_allocate)
+ *
+ * @retval MFD_SUCCESS  : no errors
+ * @retval MFD_ERROR    : error (context allocate will fail)
+ */
+int
+lreInterfaceStatsTable_rowreq_ctx_init(lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx,
+                           void *user_init_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_rowreq_ctx_init","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+    
+    /*
+     * TODO:210:o: |-> Perform extra lreInterfaceStatsTable rowreq initialization. (eg DEFVALS)
+     */
+
+    return MFD_SUCCESS;
+} /* lreInterfaceStatsTable_rowreq_ctx_init */
+
+/**
+ * extra context cleanup
+ *
+ */
+void lreInterfaceStatsTable_rowreq_ctx_cleanup(lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_rowreq_ctx_cleanup","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+    
+    /*
+     * TODO:211:o: |-> Perform extra lreInterfaceStatsTable rowreq cleanup.
+     */
+} /* lreInterfaceStatsTable_rowreq_ctx_cleanup */
+
+/**
+ * pre-request callback
+ *
+ *
+ * @retval MFD_SUCCESS              : success.
+ * @retval MFD_ERROR                : other error
+ */
+int
+lreInterfaceStatsTable_pre_request(lreInterfaceStatsTable_registration * user_context)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_pre_request","called\n"));
+
+    /*
+     * TODO:510:o: Perform lreInterfaceStatsTable pre-request actions.
+     */
+
+    return MFD_SUCCESS;
+} /* lreInterfaceStatsTable_pre_request */
+
+/**
+ * post-request callback
+ *
+ * Note:
+ *   New rows have been inserted into the container, and
+ *   deleted rows have been removed from the container and
+ *   released.
+ *
+ * @param user_context
+ * @param rc : MFD_SUCCESS if all requests succeeded
+ *
+ * @retval MFD_SUCCESS : success.
+ * @retval MFD_ERROR   : other error (ignored)
+ */
+int
+lreInterfaceStatsTable_post_request(lreInterfaceStatsTable_registration * user_context, int rc)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_post_request","called\n"));
+
+    /*
+     * TODO:511:o: Perform lreInterfaceStatsTable post-request actions.
+     */
+
+    return MFD_SUCCESS;
+} /* lreInterfaceStatsTable_post_request */
+
+
+/** @{ */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable.h
new file mode 100644
index 0000000..1fee685
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable.h
@@ -0,0 +1,305 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+#ifndef LREINTERFACESTATSTABLE_H
+#define LREINTERFACESTATSTABLE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/** @addtogroup misc misc: Miscellaneous routines
+ *
+ * @{
+ */
+#include <net-snmp/library/asn1.h>
+
+/* other required module components */
+    /* *INDENT-OFF*  */
+config_add_mib(IEC-62439-3-MIB)
+config_require(IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_interface)
+config_require(IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_access)
+config_require(IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_get)
+config_require(IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_set)
+    /* *INDENT-ON*  */
+
+/* OID and column number definitions for lreInterfaceStatsTable */
+#include "lreInterfaceStatsTable_oids.h"
+
+/* enum definions */
+#include "lreInterfaceStatsTable_enums.h"
+
+/* *********************************************************************
+ * function declarations
+ */
+void init_lreInterfaceStatsTable(void);
+void shutdown_lreInterfaceStatsTable(void);
+
+/* *********************************************************************
+ * Table declarations
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceStatsTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceStatsTable is subid 1 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.1, length: 9
+*/
+/* *********************************************************************
+ * When you register your mib, you get to provide a generic
+ * pointer that will be passed back to you for most of the
+ * functions calls.
+ *
+ * TODO:100:r: Review all context structures
+ */
+    /*
+     * TODO:101:o: |-> Review lreInterfaceStatsTable registration context.
+     */
+typedef netsnmp_data_list lreInterfaceStatsTable_registration;
+
+/**********************************************************************/
+/*
+ * TODO:110:r: |-> Review lreInterfaceStatsTable data context structure.
+ * This structure is used to represent the data for lreInterfaceStatsTable.
+ */
+/*
+ * This structure contains storage for all the columns defined in the
+ * lreInterfaceStatsTable.
+ */
+typedef struct lreInterfaceStatsTable_data_s {
+    
+        /*
+         * lreCntTxA(2)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntTxA;
+    
+        /*
+         * lreCntTxB(3)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntTxB;
+    
+        /*
+         * lreCntTxC(4)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntTxC;
+    
+        /*
+         * lreCntErrWrongLanA(5)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntErrWrongLanA;
+    
+        /*
+         * lreCntErrWrongLanB(6)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntErrWrongLanB;
+    
+        /*
+         * lreCntErrWrongLanC(7)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntErrWrongLanC;
+    
+        /*
+         * lreCntRxA(8)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntRxA;
+    
+        /*
+         * lreCntRxB(9)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntRxB;
+    
+        /*
+         * lreCntRxC(10)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntRxC;
+    
+        /*
+         * lreCntErrorsA(11)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntErrorsA;
+    
+        /*
+         * lreCntErrorsB(12)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntErrorsB;
+    
+        /*
+         * lreCntErrorsC(13)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntErrorsC;
+    
+        /*
+         * lreCntNodes(14)/INTEGER32/ASN_INTEGER/long(long)//l/A/w/e/r/d/h
+         */
+   long   lreCntNodes;
+    
+        /*
+         * lreCntProxyNodes(15)/INTEGER32/ASN_INTEGER/long(long)//l/A/w/e/r/d/h
+         */
+   long   lreCntProxyNodes;
+    
+        /*
+         * lreCntUniqueA(16)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntUniqueA;
+    
+        /*
+         * lreCntUniqueB(17)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntUniqueB;
+    
+        /*
+         * lreCntUniqueC(18)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntUniqueC;
+    
+        /*
+         * lreCntDuplicateA(19)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntDuplicateA;
+    
+        /*
+         * lreCntDuplicateB(20)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntDuplicateB;
+    
+        /*
+         * lreCntDuplicateC(21)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntDuplicateC;
+    
+        /*
+         * lreCntMultiA(22)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntMultiA;
+    
+        /*
+         * lreCntMultiB(23)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntMultiB;
+    
+        /*
+         * lreCntMultiC(24)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntMultiC;
+    
+        /*
+         * lreCntOwnRxA(25)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntOwnRxA;
+    
+        /*
+         * lreCntOwnRxB(26)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreCntOwnRxB;
+    
+} lreInterfaceStatsTable_data;
+
+
+/*
+ * TODO:120:r: |-> Review lreInterfaceStatsTable mib index.
+ * This structure is used to represent the index for lreInterfaceStatsTable.
+ */
+typedef struct lreInterfaceStatsTable_mib_index_s {
+
+        /*
+         * lreInterfaceStatsIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+         */
+   u_long   lreInterfaceStatsIndex;
+
+
+} lreInterfaceStatsTable_mib_index;
+
+    /*
+     * TODO:121:r: |   |-> Review lreInterfaceStatsTable max index length.
+     * If you KNOW that your indexes will never exceed a certain
+     * length, update this macro to that length.
+*/
+#define MAX_lreInterfaceStatsTable_IDX_LEN     1
+
+
+/* *********************************************************************
+ * TODO:130:o: |-> Review lreInterfaceStatsTable Row request (rowreq) context.
+ * When your functions are called, you will be passed a
+ * lreInterfaceStatsTable_rowreq_ctx pointer.
+ */
+typedef struct lreInterfaceStatsTable_rowreq_ctx_s {
+
+    /** this must be first for container compare to work */
+    netsnmp_index        oid_idx;
+    oid                  oid_tmp[MAX_lreInterfaceStatsTable_IDX_LEN];
+    
+    lreInterfaceStatsTable_mib_index        tbl_idx;
+    
+    lreInterfaceStatsTable_data              data;
+
+    /*
+     * flags per row. Currently, the first (lower) 8 bits are reserved
+     * for the user. See mfd.h for other flags.
+     */
+    u_int                       rowreq_flags;
+
+    /*
+     * TODO:131:o: |   |-> Add useful data to lreInterfaceStatsTable rowreq context.
+     */
+    
+    /*
+     * storage for future expansion
+     */
+    netsnmp_data_list             *lreInterfaceStatsTable_data_list;
+
+} lreInterfaceStatsTable_rowreq_ctx;
+
+typedef struct lreInterfaceStatsTable_ref_rowreq_ctx_s {
+    lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx;
+} lreInterfaceStatsTable_ref_rowreq_ctx;
+
+/* *********************************************************************
+ * function prototypes
+ */
+    int lreInterfaceStatsTable_pre_request(lreInterfaceStatsTable_registration * user_context);
+    int lreInterfaceStatsTable_post_request(lreInterfaceStatsTable_registration * user_context,
+        int rc);
+
+    int lreInterfaceStatsTable_rowreq_ctx_init(lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx,
+                                   void *user_init_ctx);
+    void lreInterfaceStatsTable_rowreq_ctx_cleanup(lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx);
+
+
+    lreInterfaceStatsTable_rowreq_ctx *
+                  lreInterfaceStatsTable_row_find_by_mib_index(lreInterfaceStatsTable_mib_index *mib_idx);
+
+extern const oid lreInterfaceStatsTable_oid[];
+extern const int lreInterfaceStatsTable_oid_size;
+
+
+#include "lreInterfaceStatsTable_interface.h"
+#include "lreInterfaceStatsTable_data_access.h"
+#include "lreInterfaceStatsTable_data_get.h"
+#include "lreInterfaceStatsTable_data_set.h"
+
+/*
+ * DUMMY markers, ignore
+ *
+ * TODO:099:x: *************************************************************
+ * TODO:199:x: *************************************************************
+ * TODO:299:x: *************************************************************
+ * TODO:399:x: *************************************************************
+ * TODO:499:x: *************************************************************
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACESTATSTABLE_H */
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_access.c b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_access.c
new file mode 100644
index 0000000..71fa8d5
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_access.c
@@ -0,0 +1,559 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $ 
+ *
+ * $Id:$
+ */
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreInterfaceStatsTable.h"
+
+
+#include "lreInterfaceStatsTable_data_access.h"
+
+/** @ingroup interface
+ * @addtogroup data_access data_access: Routines to access data
+ *
+ * These routines are used to locate the data used to satisfy
+ * requests.
+ * 
+ * @{
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceStatsTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceStatsTable is subid 1 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.1, length: 9
+*/
+
+/**
+ * initialization for lreInterfaceStatsTable data access
+ *
+ * This function is called during startup to allow you to
+ * allocate any resources you need for the data table.
+ *
+ * @param lreInterfaceStatsTable_reg
+ *        Pointer to lreInterfaceStatsTable_registration
+ *
+ * @retval MFD_SUCCESS : success.
+ * @retval MFD_ERROR   : unrecoverable error.
+ */
+int
+lreInterfaceStatsTable_init_data(lreInterfaceStatsTable_registration * lreInterfaceStatsTable_reg)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_init_data","called\n"));
+
+    /*
+     * TODO:303:o: Initialize lreInterfaceStatsTable data.
+     */
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+    /*
+     * if you are the sole writer for the file, you could
+     * open it here. However, as stated earlier, we are assuming
+     * the worst case, which in this case means that the file is
+     * written to by someone else, and might not even exist when
+     * we start up. So we can't do anything here.
+     */
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+
+    return MFD_SUCCESS;
+} /* lreInterfaceStatsTable_init_data */
+
+/**
+ * container overview
+ *
+ */
+
+/**
+ * container initialization
+ *
+ * @param container_ptr_ptr A pointer to a container pointer. If you
+ *        create a custom container, use this parameter to return it
+ *        to the MFD helper. If set to NULL, the MFD helper will
+ *        allocate a container for you.
+ * @param  cache A pointer to a cache structure. You can set the timeout
+ *         and other cache flags using this pointer.
+ *
+ *  This function is called at startup to allow you to customize certain
+ *  aspects of the access method. For the most part, it is for advanced
+ *  users. The default code should suffice for most cases. If no custom
+ *  container is allocated, the MFD code will create one for your.
+ *
+ *  This is also the place to set up cache behavior. The default, to
+ *  simply set the cache timeout, will work well with the default
+ *  container. If you are using a custom container, you may want to
+ *  look at the cache helper documentation to see if there are any
+ *  flags you want to set.
+ *
+ * @remark
+ *  This would also be a good place to do any initialization needed
+ *  for you data source. For example, opening a connection to another
+ *  process that will supply the data, opening a database, etc.
+ */
+void
+lreInterfaceStatsTable_container_init(netsnmp_container **container_ptr_ptr,
+                             netsnmp_cache *cache)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_container_init","called\n"));
+    
+    if (NULL == container_ptr_ptr) {
+        snmp_log(LOG_ERR,"bad container param to lreInterfaceStatsTable_container_init\n");
+        return;
+    }
+
+    /*
+     * For advanced users, you can use a custom container. If you
+     * do not create one, one will be created for you.
+     */
+    *container_ptr_ptr = NULL;
+
+    if (NULL == cache) {
+        snmp_log(LOG_ERR,"bad cache param to lreInterfaceStatsTable_container_init\n");
+        return;
+    }
+
+    /*
+     * TODO:345:A: Set up lreInterfaceStatsTable cache properties.
+     *
+     * Also for advanced users, you can set parameters for the
+     * cache. Do not change the magic pointer, as it is used
+     * by the MFD helper. To completely disable caching, set
+     * cache->enabled to 0.
+     */
+    cache->timeout = LREINTERFACESTATSTABLE_CACHE_TIMEOUT; /* seconds */
+} /* lreInterfaceStatsTable_container_init */
+
+/**
+ * container shutdown
+ *
+ * @param container_ptr A pointer to the container.
+ *
+ *  This function is called at shutdown to allow you to customize certain
+ *  aspects of the access method. For the most part, it is for advanced
+ *  users. The default code should suffice for most cases.
+ *
+ *  This function is called before lreInterfaceStatsTable_container_free().
+ *
+ * @remark
+ *  This would also be a good place to do any cleanup needed
+ *  for you data source. For example, closing a connection to another
+ *  process that supplied the data, closing a database, etc.
+ */
+void
+lreInterfaceStatsTable_container_shutdown(netsnmp_container *container_ptr)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_container_shutdown","called\n"));
+    
+    if (NULL == container_ptr) {
+        snmp_log(LOG_ERR,"bad params to lreInterfaceStatsTable_container_shutdown\n");
+        return;
+    }
+
+} /* lreInterfaceStatsTable_container_shutdown */
+
+/**
+ * load initial data
+ *
+ * TODO:350:M: Implement lreInterfaceStatsTable data load
+ * This function will also be called by the cache helper to load
+ * the container again (after the container free function has been
+ * called to free the previous contents).
+ *
+ * @param container container to which items should be inserted
+ *
+ * @retval MFD_SUCCESS              : success.
+ * @retval MFD_RESOURCE_UNAVAILABLE : Can't access data source
+ * @retval MFD_ERROR                : other error.
+ *
+ *  This function is called to load the index(es) (and data, optionally)
+ *  for the every row in the data set.
+ *
+ * @remark
+ *  While loading the data, the only important thing is the indexes.
+ *  If access to your data is cheap/fast (e.g. you have a pointer to a
+ *  structure in memory), it would make sense to update the data here.
+ *  If, however, the accessing the data invovles more work (e.g. parsing
+ *  some other existing data, or peforming calculations to derive the data),
+ *  then you can limit yourself to setting the indexes and saving any
+ *  information you will need later. Then use the saved information in
+ *  lreInterfaceStatsTable_row_prep() for populating data.
+ *
+ * @note
+ *  If you need consistency between rows (like you want statistics
+ *  for each row to be from the same time frame), you should set all
+ *  data here.
+ *
+ */
+int
+lreInterfaceStatsTable_container_load(netsnmp_container *container)
+{
+    lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx;
+    size_t                 count = 0;
+
+    /*
+     * temporary storage for index values
+     */
+        /*
+         * lreInterfaceStatsIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+         */
+   u_long   lreInterfaceStatsIndex;
+
+    
+    /*
+     * this example code is based on a data source that is a
+     * text file to be read and parsed.
+     */
+    FILE *filep;
+    char line[MAX_LINE_SIZE];
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_container_load","called\n"));
+
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+    /*
+     * open our data file.
+     */
+    filep = fopen("/etc/dummy.conf", "r");
+    if(NULL ==  filep) {
+        return MFD_RESOURCE_UNAVAILABLE;
+    }
+
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+    /*
+     * TODO:351:M: |-> Load/update data in the lreInterfaceStatsTable container.
+     * loop over your lreInterfaceStatsTable data, allocate a rowreq context,
+     * set the index(es) [and data, optionally] and insert into
+     * the container.
+     */
+    while( 1 ) {
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+    /*
+     * get a line (skip blank lines)
+     */
+    do {
+        if (!fgets(line, sizeof(line), filep)) {
+            /* we're done */
+            fclose(filep);
+            filep = NULL;
+        }
+    } while (filep && (line[0] == '\n'));
+
+    /*
+     * check for end of data
+     */
+    if(NULL == filep)
+        break;
+
+    /*
+     * parse line into variables
+     */
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+
+        /*
+         * TODO:352:M: |   |-> set indexes in new lreInterfaceStatsTable rowreq context.
+         * data context will be set from the param (unless NULL,
+         *      in which case a new data context will be allocated)
+         */
+        rowreq_ctx = lreInterfaceStatsTable_allocate_rowreq_ctx(NULL);
+        if (NULL == rowreq_ctx) {
+            snmp_log(LOG_ERR, "memory allocation failed\n");
+            return MFD_RESOURCE_UNAVAILABLE;
+        }
+        if(MFD_SUCCESS != lreInterfaceStatsTable_indexes_set(rowreq_ctx
+                               , lreInterfaceStatsIndex
+               )) {
+            snmp_log(LOG_ERR,"error setting index while loading "
+                     "lreInterfaceStatsTable data.\n");
+            lreInterfaceStatsTable_release_rowreq_ctx(rowreq_ctx);
+            continue;
+        }
+
+        /*
+         * TODO:352:r: |   |-> populate lreInterfaceStatsTable data context.
+         * Populate data context here. (optionally, delay until row prep)
+         */
+    /*
+     * TRANSIENT or semi-TRANSIENT data:
+     * copy data or save any info needed to do it in row_prep.
+     */
+    /*
+     * setup/save data for lreCntTxA
+     * lreCntTxA(2)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntTxA = lreCntTxA;
+    
+    /*
+     * setup/save data for lreCntTxB
+     * lreCntTxB(3)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntTxB = lreCntTxB;
+    
+    /*
+     * setup/save data for lreCntTxC
+     * lreCntTxC(4)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntTxC = lreCntTxC;
+    
+    /*
+     * setup/save data for lreCntErrWrongLanA
+     * lreCntErrWrongLanA(5)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntErrWrongLanA = lreCntErrWrongLanA;
+    
+    /*
+     * setup/save data for lreCntErrWrongLanB
+     * lreCntErrWrongLanB(6)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntErrWrongLanB = lreCntErrWrongLanB;
+    
+    /*
+     * setup/save data for lreCntErrWrongLanC
+     * lreCntErrWrongLanC(7)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntErrWrongLanC = lreCntErrWrongLanC;
+    
+    /*
+     * setup/save data for lreCntRxA
+     * lreCntRxA(8)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntRxA = lreCntRxA;
+    
+    /*
+     * setup/save data for lreCntRxB
+     * lreCntRxB(9)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntRxB = lreCntRxB;
+    
+    /*
+     * setup/save data for lreCntRxC
+     * lreCntRxC(10)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntRxC = lreCntRxC;
+    
+    /*
+     * setup/save data for lreCntErrorsA
+     * lreCntErrorsA(11)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntErrorsA = lreCntErrorsA;
+    
+    /*
+     * setup/save data for lreCntErrorsB
+     * lreCntErrorsB(12)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntErrorsB = lreCntErrorsB;
+    
+    /*
+     * setup/save data for lreCntErrorsC
+     * lreCntErrorsC(13)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntErrorsC = lreCntErrorsC;
+    
+    /*
+     * setup/save data for lreCntNodes
+     * lreCntNodes(14)/INTEGER32/ASN_INTEGER/long(long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntNodes = lreCntNodes;
+    
+    /*
+     * setup/save data for lreCntProxyNodes
+     * lreCntProxyNodes(15)/INTEGER32/ASN_INTEGER/long(long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntProxyNodes = lreCntProxyNodes;
+    
+    /*
+     * setup/save data for lreCntUniqueA
+     * lreCntUniqueA(16)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntUniqueA = lreCntUniqueA;
+    
+    /*
+     * setup/save data for lreCntUniqueB
+     * lreCntUniqueB(17)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntUniqueB = lreCntUniqueB;
+    
+    /*
+     * setup/save data for lreCntUniqueC
+     * lreCntUniqueC(18)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntUniqueC = lreCntUniqueC;
+    
+    /*
+     * setup/save data for lreCntDuplicateA
+     * lreCntDuplicateA(19)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntDuplicateA = lreCntDuplicateA;
+    
+    /*
+     * setup/save data for lreCntDuplicateB
+     * lreCntDuplicateB(20)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntDuplicateB = lreCntDuplicateB;
+    
+    /*
+     * setup/save data for lreCntDuplicateC
+     * lreCntDuplicateC(21)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntDuplicateC = lreCntDuplicateC;
+    
+    /*
+     * setup/save data for lreCntMultiA
+     * lreCntMultiA(22)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntMultiA = lreCntMultiA;
+    
+    /*
+     * setup/save data for lreCntMultiB
+     * lreCntMultiB(23)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntMultiB = lreCntMultiB;
+    
+    /*
+     * setup/save data for lreCntMultiC
+     * lreCntMultiC(24)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntMultiC = lreCntMultiC;
+    
+    /*
+     * setup/save data for lreCntOwnRxA
+     * lreCntOwnRxA(25)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntOwnRxA = lreCntOwnRxA;
+    
+    /*
+     * setup/save data for lreCntOwnRxB
+     * lreCntOwnRxB(26)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreCntOwnRxB = lreCntOwnRxB;
+    
+        
+        /*
+         * insert into table container
+         */
+        CONTAINER_INSERT(container, rowreq_ctx);
+        ++count;
+    }
+
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+    if(NULL != filep)
+        fclose(filep);
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+
+    DEBUGMSGT(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_container_load",
+               "inserted %d records\n", count));
+
+    return MFD_SUCCESS;
+} /* lreInterfaceStatsTable_container_load */
+
+/**
+ * container clean up
+ *
+ * @param container container with all current items
+ *
+ *  This optional callback is called prior to all
+ *  item's being removed from the container. If you
+ *  need to do any processing before that, do it here.
+ *
+ * @note
+ *  The MFD helper will take care of releasing all the row contexts.
+ *
+ */
+void
+lreInterfaceStatsTable_container_free(netsnmp_container *container)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_container_free","called\n"));
+
+    /*
+     * TODO:380:M: Free lreInterfaceStatsTable container data.
+     */
+} /* lreInterfaceStatsTable_container_free */
+
+/**
+ * prepare row for processing.
+ *
+ *  When the agent has located the row for a request, this function is
+ *  called to prepare the row for processing. If you fully populated
+ *  the data context during the index setup phase, you may not need to
+ *  do anything.
+ *
+ * @param rowreq_ctx pointer to a context.
+ *
+ * @retval MFD_SUCCESS     : success.
+ * @retval MFD_ERROR       : other error.
+ */
+int
+lreInterfaceStatsTable_row_prep( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_row_prep","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:390:o: Prepare row for request.
+     * If populating row data was delayed, this is the place to
+     * fill in the row for this request.
+     */
+
+    return MFD_SUCCESS;
+} /* lreInterfaceStatsTable_row_prep */
+
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_access.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_access.h
new file mode 100644
index 0000000..d2877b1
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_access.h
@@ -0,0 +1,76 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+#ifndef LREINTERFACESTATSTABLE_DATA_ACCESS_H
+#define LREINTERFACESTATSTABLE_DATA_ACCESS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* *********************************************************************
+ * function declarations
+ */
+
+/* *********************************************************************
+ * Table declarations
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceStatsTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceStatsTable is subid 1 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.1, length: 9
+*/
+
+
+    int lreInterfaceStatsTable_init_data(lreInterfaceStatsTable_registration * lreInterfaceStatsTable_reg);
+
+
+    /*
+     * TODO:180:o: Review lreInterfaceStatsTable cache timeout.
+     * The number of seconds before the cache times out
+     */
+#define LREINTERFACESTATSTABLE_CACHE_TIMEOUT   60
+
+void lreInterfaceStatsTable_container_init(netsnmp_container **container_ptr_ptr,
+                             netsnmp_cache *cache);
+void lreInterfaceStatsTable_container_shutdown(netsnmp_container *container_ptr);
+
+int lreInterfaceStatsTable_container_load(netsnmp_container *container);
+void lreInterfaceStatsTable_container_free(netsnmp_container *container);
+
+int lreInterfaceStatsTable_cache_load(netsnmp_container *container);
+void lreInterfaceStatsTable_cache_free(netsnmp_container *container);
+
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+/* *********************************************************************
+ * Since we have no idea how you really access your data, we'll go with
+ * a worst case example: a flat text file.
+ */
+#define MAX_LINE_SIZE 256
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+    int lreInterfaceStatsTable_row_prep( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACESTATSTABLE_DATA_ACCESS_H */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_get.c b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_get.c
new file mode 100644
index 0000000..5ff7704
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_get.c
@@ -0,0 +1,1518 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $ 
+ *
+ * $Id:$
+ */
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreInterfaceStatsTable.h"
+
+
+/** @defgroup data_get data_get: Routines to get data
+ *
+ * TODO:230:M: Implement lreInterfaceStatsTable get routines.
+ * TODO:240:M: Implement lreInterfaceStatsTable mapping routines (if any).
+ *
+ * These routine are used to get the value for individual objects. The
+ * row context is passed, along with a pointer to the memory where the
+ * value should be copied.
+ *
+ * @{
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceStatsTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceStatsTable is subid 1 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.1, length: 9
+*/
+
+/* ---------------------------------------------------------------------
+ * TODO:200:r: Implement lreInterfaceStatsTable data context functions.
+ */
+
+
+/**
+ * set mib index(es)
+ *
+ * @param tbl_idx mib index structure
+ * @param lreInterfaceStatsIndex_val
+ *
+ * @retval MFD_SUCCESS     : success.
+ * @retval MFD_ERROR       : other error.
+ *
+ * @remark
+ *  This convenience function is useful for setting all the MIB index
+ *  components with a single function call. It is assume that the C values
+ *  have already been mapped from their native/rawformat to the MIB format.
+ */
+int
+lreInterfaceStatsTable_indexes_set_tbl_idx(lreInterfaceStatsTable_mib_index *tbl_idx, u_long lreInterfaceStatsIndex_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_indexes_set_tbl_idx","called\n"));
+
+    /* lreInterfaceStatsIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h */
+    tbl_idx->lreInterfaceStatsIndex = lreInterfaceStatsIndex_val;
+    
+
+    return MFD_SUCCESS;
+} /* lreInterfaceStatsTable_indexes_set_tbl_idx */
+
+/**
+ * @internal
+ * set row context indexes
+ *
+ * @param reqreq_ctx the row context that needs updated indexes
+ *
+ * @retval MFD_SUCCESS     : success.
+ * @retval MFD_ERROR       : other error.
+ *
+ * @remark
+ *  This function sets the mib indexs, then updates the oid indexs
+ *  from the mib index.
+ */
+int
+lreInterfaceStatsTable_indexes_set(lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long lreInterfaceStatsIndex_val)
+{
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_indexes_set","called\n"));
+
+    if(MFD_SUCCESS != lreInterfaceStatsTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
+                                   , lreInterfaceStatsIndex_val
+           ))
+        return MFD_ERROR;
+
+    /*
+     * convert mib index to oid index
+     */
+    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
+    if(0 != lreInterfaceStatsTable_index_to_oid(&rowreq_ctx->oid_idx,
+                                    &rowreq_ctx->tbl_idx)) {
+        return MFD_ERROR;
+    }
+
+    return MFD_SUCCESS;
+} /* lreInterfaceStatsTable_indexes_set */
+
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntTxA
+ * lreCntTxA is subid 2 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.2
+ * Description:
+
+                number of frames sent over port A that are HSR tagged or
+                fitted with a PRP
+                Redundancy Control Trailer.
+                Only frames that are HSR tagged or do have a PRP RCT are counted.
+                A frame aborted during the transmission is not counted.
+                Initial value = 0.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntTxA data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntTxA_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntTxA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntTxA_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntTxA_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntTxA_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntTxA data.
+ * copy (* lreCntTxA_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntTxA_val_ptr ) = rowreq_ctx->data.lreCntTxA;
+
+    return MFD_SUCCESS;
+} /* lreCntTxA_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntTxB
+ * lreCntTxB is subid 3 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.3
+ * Description:
+
+                number of frames sent over port B that are HSR tagged or
+                fitted with a PRP
+                Redundancy Control Trailer.
+                Only frames that are HSR tagged or do have a PRP RCT are counted.
+                A frame aborted during the transmission is not counted.
+                Initial value = 0.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntTxB data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntTxB_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntTxB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntTxB_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntTxB_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntTxB_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntTxB data.
+ * copy (* lreCntTxB_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntTxB_val_ptr ) = rowreq_ctx->data.lreCntTxB;
+
+    return MFD_SUCCESS;
+} /* lreCntTxB_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntTxC
+ * lreCntTxC is subid 4 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.4
+ * Description:
+
+                number of frames sent towards the application interface of
+                the DANP or DANH
+                or over the interlink of the RedBox. Frames with and without PRP RCT or HSR
+                tag are counted, but not link-local frames.
+                A frame aborted during the transmission is not counted.
+                Initial value = 0.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntTxC data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntTxC_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntTxC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntTxC_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntTxC_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntTxC_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntTxC data.
+ * copy (* lreCntTxC_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntTxC_val_ptr ) = rowreq_ctx->data.lreCntTxC;
+
+    return MFD_SUCCESS;
+} /* lreCntTxC_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntErrWrongLanA
+ * lreCntErrWrongLanA is subid 5 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.5
+ * Description:
+
+                number of frames with the wrong LAN identifier received on
+                LRE port A.
+                Initial value = 0. Only applicable to PRP ports.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntErrWrongLanA data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntErrWrongLanA_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntErrWrongLanA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntErrWrongLanA_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntErrWrongLanA_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntErrWrongLanA_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntErrWrongLanA data.
+ * copy (* lreCntErrWrongLanA_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntErrWrongLanA_val_ptr ) = rowreq_ctx->data.lreCntErrWrongLanA;
+
+    return MFD_SUCCESS;
+} /* lreCntErrWrongLanA_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntErrWrongLanB
+ * lreCntErrWrongLanB is subid 6 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.6
+ * Description:
+
+                number of frames with the wrong LAN identifier received on
+                LRE port B
+                Initial value = 0. Only applicable to PRP ports.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntErrWrongLanB data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntErrWrongLanB_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntErrWrongLanB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntErrWrongLanB_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntErrWrongLanB_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntErrWrongLanB_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntErrWrongLanB data.
+ * copy (* lreCntErrWrongLanB_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntErrWrongLanB_val_ptr ) = rowreq_ctx->data.lreCntErrWrongLanB;
+
+    return MFD_SUCCESS;
+} /* lreCntErrWrongLanB_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntErrWrongLanC
+ * lreCntErrWrongLanC is subid 7 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.7
+ * Description:
+
+                number of frames with the wrong LAN identifier received on
+                the interlink of
+                a RedBox. Only applicable to HSR RedBoxes in HSR-PRP configuration
+                (hsrredboxprpa and hsrredboxprpb).
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntErrWrongLanC data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntErrWrongLanC_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntErrWrongLanC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntErrWrongLanC_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntErrWrongLanC_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntErrWrongLanC_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntErrWrongLanC data.
+ * copy (* lreCntErrWrongLanC_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntErrWrongLanC_val_ptr ) = rowreq_ctx->data.lreCntErrWrongLanC;
+
+    return MFD_SUCCESS;
+} /* lreCntErrWrongLanC_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntRxA
+ * lreCntRxA is subid 8 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.8
+ * Description:
+
+                number of frames received on a LRE port A. Only frames that
+                are HSR tagged
+                or fitted with a PRP Redundancy Control Trailer are counted. Frames that are
+                not forwarded anywhere (e.g. because the sender of the frame is in the proxy
+                node table) are counted, too. Only frames received completely and without
+                error are counted.
+                Initial value = 0.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntRxA data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntRxA_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntRxA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntRxA_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntRxA_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntRxA_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntRxA data.
+ * copy (* lreCntRxA_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntRxA_val_ptr ) = rowreq_ctx->data.lreCntRxA;
+
+    return MFD_SUCCESS;
+} /* lreCntRxA_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntRxB
+ * lreCntRxB is subid 9 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.9
+ * Description:
+
+                number of frames received on a LRE port B. Only frames that
+                are HSR tagged
+                or fitted with a PRP Redundancy Control Trailer are counted. Frames that are
+                not forwarded anywhere (e.g. because the sender of the frame is in the proxy
+                node table) are counted, too. Only frames received completely and without
+                error are counted.
+                Initial value = 0.
+              
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntRxB data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntRxB_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntRxB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntRxB_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntRxB_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntRxB_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntRxB data.
+ * copy (* lreCntRxB_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntRxB_val_ptr ) = rowreq_ctx->data.lreCntRxB;
+
+    return MFD_SUCCESS;
+} /* lreCntRxB_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntRxC
+ * lreCntRxC is subid 10 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.10
+ * Description:
+
+  number of frames received from the application interface of a
+  DANP or DANH or
+  the number of number of frames received on the interlink of a RedBox. Frames
+  with and without PRP RCT or HSR tag are counted, but not link-local frames.
+  Only frames received completely and without error are counted.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntRxC data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntRxC_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntRxC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntRxC_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntRxC_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntRxC_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntRxC data.
+ * copy (* lreCntRxC_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntRxC_val_ptr ) = rowreq_ctx->data.lreCntRxC;
+
+    return MFD_SUCCESS;
+} /* lreCntRxC_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntErrorsA
+ * lreCntErrorsA is subid 11 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.11
+ * Description:
+
+  number of frames with errors received on this LRE port A.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntErrorsA data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntErrorsA_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntErrorsA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntErrorsA_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntErrorsA_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntErrorsA_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntErrorsA data.
+ * copy (* lreCntErrorsA_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntErrorsA_val_ptr ) = rowreq_ctx->data.lreCntErrorsA;
+
+    return MFD_SUCCESS;
+} /* lreCntErrorsA_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntErrorsB
+ * lreCntErrorsB is subid 12 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.12
+ * Description:
+
+  number of frames with errors received on this LRE port B.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntErrorsB data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntErrorsB_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntErrorsB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntErrorsB_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntErrorsB_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntErrorsB_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntErrorsB data.
+ * copy (* lreCntErrorsB_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntErrorsB_val_ptr ) = rowreq_ctx->data.lreCntErrorsB;
+
+    return MFD_SUCCESS;
+} /* lreCntErrorsB_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntErrorsC
+ * lreCntErrorsC is subid 13 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.13
+ * Description:
+
+  number of frames with errors received on the application
+  interface of a DANP or
+  DANH or on the interlink of a RedBox.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntErrorsC data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntErrorsC_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntErrorsC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntErrorsC_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntErrorsC_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntErrorsC_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntErrorsC data.
+ * copy (* lreCntErrorsC_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntErrorsC_val_ptr ) = rowreq_ctx->data.lreCntErrorsC;
+
+    return MFD_SUCCESS;
+} /* lreCntErrorsC_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntNodes
+ * lreCntNodes is subid 14 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.14
+ * Description:
+number of nodes in the Nodes Table.
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is INTEGER32 (based on perltype INTEGER32)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
+ */
+/**
+ * Extract the current value of the lreCntNodes data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntNodes_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntNodes_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, long * lreCntNodes_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntNodes_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntNodes_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntNodes data.
+ * copy (* lreCntNodes_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntNodes_val_ptr ) = rowreq_ctx->data.lreCntNodes;
+
+    return MFD_SUCCESS;
+} /* lreCntNodes_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntProxyNodes
+ * lreCntProxyNodes is subid 15 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.15
+ * Description:
+
+  number of nodes in the Proxy Node Table. Only applicable to
+  RedBox.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is INTEGER32 (based on perltype INTEGER32)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
+ */
+/**
+ * Extract the current value of the lreCntProxyNodes data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntProxyNodes_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntProxyNodes_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, long * lreCntProxyNodes_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntProxyNodes_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntProxyNodes_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntProxyNodes data.
+ * copy (* lreCntProxyNodes_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntProxyNodes_val_ptr ) = rowreq_ctx->data.lreCntProxyNodes;
+
+    return MFD_SUCCESS;
+} /* lreCntProxyNodes_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntUniqueA
+ * lreCntUniqueA is subid 16 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.16
+ * Description:
+
+  number of entries in the duplicate detection mechanism on
+  port A for which
+  no duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntUniqueA data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntUniqueA_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntUniqueA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntUniqueA_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntUniqueA_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntUniqueA_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntUniqueA data.
+ * copy (* lreCntUniqueA_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntUniqueA_val_ptr ) = rowreq_ctx->data.lreCntUniqueA;
+
+    return MFD_SUCCESS;
+} /* lreCntUniqueA_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntUniqueB
+ * lreCntUniqueB is subid 17 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.17
+ * Description:
+
+  number of entries in the duplicate detection mechanism on
+  port B for which
+  no duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntUniqueB data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntUniqueB_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntUniqueB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntUniqueB_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntUniqueB_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntUniqueB_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntUniqueB data.
+ * copy (* lreCntUniqueB_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntUniqueB_val_ptr ) = rowreq_ctx->data.lreCntUniqueB;
+
+    return MFD_SUCCESS;
+} /* lreCntUniqueB_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntUniqueC
+ * lreCntUniqueC is subid 18 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.18
+ * Description:
+
+  number of entries in the duplicate detection mechanism on the
+  application interface
+  of the DAN or the interlink of the RedBox for which no duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntUniqueC data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntUniqueC_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntUniqueC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntUniqueC_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntUniqueC_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntUniqueC_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntUniqueC data.
+ * copy (* lreCntUniqueC_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntUniqueC_val_ptr ) = rowreq_ctx->data.lreCntUniqueC;
+
+    return MFD_SUCCESS;
+} /* lreCntUniqueC_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntDuplicateA
+ * lreCntDuplicateA is subid 19 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.19
+ * Description:
+
+  number of entries in the duplicate detection mechanism on
+  port A for which
+  one single duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntDuplicateA data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntDuplicateA_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntDuplicateA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntDuplicateA_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntDuplicateA_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntDuplicateA_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntDuplicateA data.
+ * copy (* lreCntDuplicateA_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntDuplicateA_val_ptr ) = rowreq_ctx->data.lreCntDuplicateA;
+
+    return MFD_SUCCESS;
+} /* lreCntDuplicateA_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntDuplicateB
+ * lreCntDuplicateB is subid 20 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.20
+ * Description:
+
+  number of entries in the duplicate detection mechanism on
+  port B for which
+  one single duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntDuplicateB data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntDuplicateB_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntDuplicateB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntDuplicateB_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntDuplicateB_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntDuplicateB_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntDuplicateB data.
+ * copy (* lreCntDuplicateB_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntDuplicateB_val_ptr ) = rowreq_ctx->data.lreCntDuplicateB;
+
+    return MFD_SUCCESS;
+} /* lreCntDuplicateB_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntDuplicateC
+ * lreCntDuplicateC is subid 21 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.21
+ * Description:
+
+  number of entries in the duplicate detection mechanism on the
+  application interface
+  of the DAN or the interlink of the RedBox for which one single duplicate was
+  received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntDuplicateC data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntDuplicateC_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntDuplicateC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntDuplicateC_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntDuplicateC_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntDuplicateC_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntDuplicateC data.
+ * copy (* lreCntDuplicateC_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntDuplicateC_val_ptr ) = rowreq_ctx->data.lreCntDuplicateC;
+
+    return MFD_SUCCESS;
+} /* lreCntDuplicateC_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntMultiA
+ * lreCntMultiA is subid 22 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.22
+ * Description:
+
+  number of entries in the duplicate detection mechanism on
+  port A for which
+  more than one duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntMultiA data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntMultiA_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntMultiA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntMultiA_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntMultiA_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntMultiA_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntMultiA data.
+ * copy (* lreCntMultiA_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntMultiA_val_ptr ) = rowreq_ctx->data.lreCntMultiA;
+
+    return MFD_SUCCESS;
+} /* lreCntMultiA_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntMultiB
+ * lreCntMultiB is subid 23 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.23
+ * Description:
+
+  number of entries in the duplicate detection mechanism on
+  port B for which
+  more than one duplicate was received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntMultiB data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntMultiB_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntMultiB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntMultiB_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntMultiB_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntMultiB_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntMultiB data.
+ * copy (* lreCntMultiB_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntMultiB_val_ptr ) = rowreq_ctx->data.lreCntMultiB;
+
+    return MFD_SUCCESS;
+} /* lreCntMultiB_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntMultiC
+ * lreCntMultiC is subid 24 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.24
+ * Description:
+
+  number of entries in the duplicate detection mechanism on the
+  application interface
+  of the DAN or the interlink of the RedBox for which more than one duplicate was
+  received.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntMultiC data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntMultiC_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntMultiC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntMultiC_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntMultiC_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntMultiC_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntMultiC data.
+ * copy (* lreCntMultiC_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntMultiC_val_ptr ) = rowreq_ctx->data.lreCntMultiC;
+
+    return MFD_SUCCESS;
+} /* lreCntMultiC_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntOwnRxA
+ * lreCntOwnRxA is subid 25 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.25
+ * Description:
+
+  number of HSR tagged frames received on Port A that
+  originated from this
+  device. Frames originate from this device if the source MAC matches the
+  MAC of the LRE, or if the source MAC appears in the proxy node table (if
+  implemented). Applicable only to HSR.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntOwnRxA data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntOwnRxA_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntOwnRxA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntOwnRxA_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntOwnRxA_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntOwnRxA_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntOwnRxA data.
+ * copy (* lreCntOwnRxA_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntOwnRxA_val_ptr ) = rowreq_ctx->data.lreCntOwnRxA;
+
+    return MFD_SUCCESS;
+} /* lreCntOwnRxA_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreInterfaceStatsEntry.lreCntOwnRxB
+ * lreCntOwnRxB is subid 26 of lreInterfaceStatsEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.1.1.26
+ * Description:
+
+  number of HSR tagged frames received on Port B that
+  originated from this
+  device. Frames originate from this device if the source MAC matches the
+  MAC of the LRE, or if the source MAC appears in the proxy node table (if
+  implemented). Applicable only to HSR.
+  Initial value = 0.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is COUNTER (based on perltype COUNTER)
+ * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreCntOwnRxB data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreCntOwnRxB_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreCntOwnRxB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntOwnRxB_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreCntOwnRxB_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreCntOwnRxB_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreCntOwnRxB data.
+ * copy (* lreCntOwnRxB_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreCntOwnRxB_val_ptr ) = rowreq_ctx->data.lreCntOwnRxB;
+
+    return MFD_SUCCESS;
+} /* lreCntOwnRxB_get */
+
+
+
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_get.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_get.h
new file mode 100644
index 0000000..5f0b82d
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_get.h
@@ -0,0 +1,83 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ *
+ * @file lreInterfaceStatsTable_data_get.h
+ *
+ * @addtogroup get
+ *
+ * Prototypes for get functions
+ *
+ * @{
+ */
+#ifndef LREINTERFACESTATSTABLE_DATA_GET_H
+#define LREINTERFACESTATSTABLE_DATA_GET_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* *********************************************************************
+ * GET function declarations
+ */
+
+/* *********************************************************************
+ * GET Table declarations
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceStatsTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceStatsTable is subid 1 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.1, length: 9
+*/
+    /*
+     * indexes
+     */
+
+    int lreCntTxA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntTxA_val_ptr );
+    int lreCntTxB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntTxB_val_ptr );
+    int lreCntTxC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntTxC_val_ptr );
+    int lreCntErrWrongLanA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntErrWrongLanA_val_ptr );
+    int lreCntErrWrongLanB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntErrWrongLanB_val_ptr );
+    int lreCntErrWrongLanC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntErrWrongLanC_val_ptr );
+    int lreCntRxA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntRxA_val_ptr );
+    int lreCntRxB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntRxB_val_ptr );
+    int lreCntRxC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntRxC_val_ptr );
+    int lreCntErrorsA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntErrorsA_val_ptr );
+    int lreCntErrorsB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntErrorsB_val_ptr );
+    int lreCntErrorsC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntErrorsC_val_ptr );
+    int lreCntNodes_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, long * lreCntNodes_val_ptr );
+    int lreCntProxyNodes_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, long * lreCntProxyNodes_val_ptr );
+    int lreCntUniqueA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntUniqueA_val_ptr );
+    int lreCntUniqueB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntUniqueB_val_ptr );
+    int lreCntUniqueC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntUniqueC_val_ptr );
+    int lreCntDuplicateA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntDuplicateA_val_ptr );
+    int lreCntDuplicateB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntDuplicateB_val_ptr );
+    int lreCntDuplicateC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntDuplicateC_val_ptr );
+    int lreCntMultiA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntMultiA_val_ptr );
+    int lreCntMultiB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntMultiB_val_ptr );
+    int lreCntMultiC_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntMultiC_val_ptr );
+    int lreCntOwnRxA_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntOwnRxA_val_ptr );
+    int lreCntOwnRxB_get( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long * lreCntOwnRxB_val_ptr );
+
+
+int lreInterfaceStatsTable_indexes_set_tbl_idx(lreInterfaceStatsTable_mib_index *tbl_idx, u_long lreInterfaceStatsIndex_val);
+int lreInterfaceStatsTable_indexes_set(lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, u_long lreInterfaceStatsIndex_val);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACESTATSTABLE_DATA_GET_H */
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_set.c b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_set.c
new file mode 100644
index 0000000..e133414
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_set.c
@@ -0,0 +1,25 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ *
+ */
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreInterfaceStatsTable.h"
+
+
+/** @defgroup data_set data_set: Routines to set data
+ *
+ * These routines are used to set the value for individual objects. The
+ * row context is passed, along with the new value.
+ * 
+ * @{
+ */
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_set.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_set.h
new file mode 100644
index 0000000..9e88aa4
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_data_set.h
@@ -0,0 +1,27 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $ 
+ *
+ * $Id:$
+ */
+#ifndef LREINTERFACESTATSTABLE_DATA_SET_H
+#define LREINTERFACESTATSTABLE_DATA_SET_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* *********************************************************************
+ * SET function declarations
+ */
+
+/* *********************************************************************
+ * SET Table declarations
+ */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACESTATSTABLE_DATA_SET_H */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_enums.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_enums.h
new file mode 100644
index 0000000..fa2dd87
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_enums.h
@@ -0,0 +1,40 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  $
+ *
+ * $Id:$
+ */
+#ifndef LREINTERFACESTATSTABLE_ENUMS_H
+#define LREINTERFACESTATSTABLE_ENUMS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+ /*
+ * NOTES on enums
+ * ==============
+ *
+ * Value Mapping
+ * -------------
+ * If the values for your data type don't exactly match the
+ * possible values defined by the mib, you should map them
+ * below. For example, a boolean flag (1/0) is usually represented
+ * as a TruthValue in a MIB, which maps to the values (1/2).
+ *
+ */
+/*************************************************************************
+ *************************************************************************
+ *
+ * enum definitions for table lreInterfaceStatsTable
+ *
+ *************************************************************************
+ *************************************************************************/
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACESTATSTABLE_ENUMS_H */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_interface.c b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_interface.c
new file mode 100644
index 0000000..0c25604
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_interface.c
@@ -0,0 +1,1034 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $ 
+ *
+ * $Id:$
+ */
+/*
+ * *********************************************************************
+ * *********************************************************************
+ * *********************************************************************
+ * ***                                                               ***
+ * ***  NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE  ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***       THIS FILE DOES NOT CONTAIN ANY USER EDITABLE CODE.      ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***       THE GENERATED CODE IS INTERNAL IMPLEMENTATION, AND      ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***    IS SUBJECT TO CHANGE WITHOUT WARNING IN FUTURE RELEASES.   ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * *********************************************************************
+ * *********************************************************************
+ * *********************************************************************
+ */
+
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreInterfaceStatsTable.h"
+
+
+#include <net-snmp/agent/table_container.h>
+#include <net-snmp/library/container.h>
+
+#include "lreInterfaceStatsTable_interface.h"
+
+netsnmp_feature_require(baby_steps)
+netsnmp_feature_require(row_merge)
+netsnmp_feature_require(check_all_requests_error)
+
+#include <ctype.h>
+
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreInterfaceStatsTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreInterfaceStatsTable is subid 1 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.1, length: 9
+*/
+typedef struct lreInterfaceStatsTable_interface_ctx_s {
+
+   netsnmp_container              *container;
+   netsnmp_cache                  *cache;
+
+   lreInterfaceStatsTable_registration *      user_ctx;
+   
+   netsnmp_table_registration_info  tbl_info;
+
+   netsnmp_baby_steps_access_methods access_multiplexer;
+
+} lreInterfaceStatsTable_interface_ctx;
+
+static lreInterfaceStatsTable_interface_ctx lreInterfaceStatsTable_if_ctx;
+
+static void _lreInterfaceStatsTable_container_init(
+    lreInterfaceStatsTable_interface_ctx *if_ctx);
+static void _lreInterfaceStatsTable_container_shutdown(
+    lreInterfaceStatsTable_interface_ctx *if_ctx);
+
+
+netsnmp_container *
+lreInterfaceStatsTable_container_get( void )
+{
+    return lreInterfaceStatsTable_if_ctx.container;
+}
+
+lreInterfaceStatsTable_registration *
+lreInterfaceStatsTable_registration_get( void )
+{
+    return lreInterfaceStatsTable_if_ctx.user_ctx;
+}
+
+lreInterfaceStatsTable_registration *
+lreInterfaceStatsTable_registration_set( lreInterfaceStatsTable_registration * newreg )
+{
+    lreInterfaceStatsTable_registration * old = lreInterfaceStatsTable_if_ctx.user_ctx;
+    lreInterfaceStatsTable_if_ctx.user_ctx = newreg;
+    return old;
+}
+
+int
+lreInterfaceStatsTable_container_size( void )
+{
+    return CONTAINER_SIZE(lreInterfaceStatsTable_if_ctx.container);
+}
+
+/*
+ * mfd multiplexer modes
+ */
+static Netsnmp_Node_Handler _mfd_lreInterfaceStatsTable_pre_request;
+static Netsnmp_Node_Handler _mfd_lreInterfaceStatsTable_post_request;
+static Netsnmp_Node_Handler _mfd_lreInterfaceStatsTable_object_lookup;
+static Netsnmp_Node_Handler _mfd_lreInterfaceStatsTable_get_values;
+/**
+ * @internal
+ * Initialize the table lreInterfaceStatsTable 
+ *    (Define its contents and how it's structured)
+ */
+void
+_lreInterfaceStatsTable_initialize_interface(lreInterfaceStatsTable_registration * reg_ptr,  u_long flags)
+{
+    netsnmp_baby_steps_access_methods *access_multiplexer =
+        &lreInterfaceStatsTable_if_ctx.access_multiplexer;
+    netsnmp_table_registration_info *tbl_info = &lreInterfaceStatsTable_if_ctx.tbl_info;
+    netsnmp_handler_registration *reginfo;
+    netsnmp_mib_handler *handler;
+    int    mfd_modes = 0;
+
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:_lreInterfaceStatsTable_initialize_interface","called\n"));
+
+
+    /*************************************************
+     *
+     * save interface context for lreInterfaceStatsTable
+     */
+    /*
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(tbl_info,
+                                  ASN_UNSIGNED, /** index: lreInterfaceStatsIndex */
+                             0);
+
+    /*  Define the minimum and maximum accessible columns.  This
+        optimizes retrieval. */
+    tbl_info->min_column = LREINTERFACESTATSTABLE_MIN_COL;
+    tbl_info->max_column = LREINTERFACESTATSTABLE_MAX_COL;
+
+    /*
+     * save users context
+     */
+    lreInterfaceStatsTable_if_ctx.user_ctx = reg_ptr;
+
+    /*
+     * call data access initialization code
+     */
+    lreInterfaceStatsTable_init_data(reg_ptr);
+
+    /*
+     * set up the container
+     */
+    _lreInterfaceStatsTable_container_init(&lreInterfaceStatsTable_if_ctx);
+    if (NULL == lreInterfaceStatsTable_if_ctx.container) {
+        snmp_log(LOG_ERR,"could not initialize container for lreInterfaceStatsTable\n");
+        return;
+    }
+    
+    /*
+     * access_multiplexer: REQUIRED wrapper for get request handling
+     */
+    access_multiplexer->object_lookup = _mfd_lreInterfaceStatsTable_object_lookup;
+    access_multiplexer->get_values = _mfd_lreInterfaceStatsTable_get_values;
+
+    /*
+     * no wrappers yet
+     */
+    access_multiplexer->pre_request = _mfd_lreInterfaceStatsTable_pre_request;
+    access_multiplexer->post_request = _mfd_lreInterfaceStatsTable_post_request;
+
+#ifndef NETSNMP_DISABLE_SET_SUPPORT
+#endif
+
+    /*************************************************
+     *
+     * Create a registration, save our reg data, register table.
+     */
+    DEBUGMSGTL(("lreInterfaceStatsTable:init_lreInterfaceStatsTable",
+                "Registering lreInterfaceStatsTable as a mibs-for-dummies table.\n"));		 
+    handler = netsnmp_baby_steps_access_multiplexer_get(access_multiplexer);
+    reginfo = netsnmp_handler_registration_create("lreInterfaceStatsTable", handler,
+                                                  lreInterfaceStatsTable_oid,
+                                                  lreInterfaceStatsTable_oid_size,
+                                                  HANDLER_CAN_BABY_STEP |
+#if !(defined(NETSNMP_NO_WRITE_SUPPORT) || defined(NETSNMP_DISABLE_SET_SUPPORT))
+                                                  HANDLER_CAN_RONLY
+#else
+                                                  HANDLER_CAN_RONLY
+#endif /* NETSNMP_NO_WRITE_SUPPORT || NETSNMP_DISABLE_SET_SUPPORT */
+                                                  );
+    if(NULL == reginfo) {
+        snmp_log(LOG_ERR,"error registering table lreInterfaceStatsTable\n");
+        return;
+    }
+    reginfo->my_reg_void = &lreInterfaceStatsTable_if_ctx;
+
+    /*************************************************
+     *
+     * set up baby steps handler, create it and inject it
+     */
+    if( access_multiplexer->object_lookup )
+        mfd_modes |= BABY_STEP_OBJECT_LOOKUP;
+    if( access_multiplexer->pre_request )
+        mfd_modes |= BABY_STEP_PRE_REQUEST;
+    if( access_multiplexer->post_request )
+        mfd_modes |= BABY_STEP_POST_REQUEST;
+    
+#if !(defined(NETSNMP_NO_WRITE_SUPPORT) || defined(NETSNMP_DISABLE_SET_SUPPORT))
+    if( access_multiplexer->set_values )
+        mfd_modes |= BABY_STEP_SET_VALUES;
+    if( access_multiplexer->irreversible_commit )
+        mfd_modes |= BABY_STEP_IRREVERSIBLE_COMMIT;
+    if( access_multiplexer->object_syntax_checks )
+        mfd_modes |= BABY_STEP_CHECK_OBJECT;
+
+    if( access_multiplexer->undo_setup )
+        mfd_modes |= BABY_STEP_UNDO_SETUP;
+    if( access_multiplexer->undo_cleanup )
+        mfd_modes |= BABY_STEP_UNDO_CLEANUP;
+    if( access_multiplexer->undo_sets )
+        mfd_modes |= BABY_STEP_UNDO_SETS;
+    
+    if( access_multiplexer->row_creation )
+        mfd_modes |= BABY_STEP_ROW_CREATE;
+    if( access_multiplexer->consistency_checks )
+        mfd_modes |= BABY_STEP_CHECK_CONSISTENCY;
+    if( access_multiplexer->commit )
+        mfd_modes |= BABY_STEP_COMMIT;
+    if( access_multiplexer->undo_commit )
+        mfd_modes |= BABY_STEP_UNDO_COMMIT;
+#endif /* NETSNMP_NO_WRITE_SUPPORT || NETSNMP_DISABLE_SET_SUPPORT */
+    
+    handler = netsnmp_baby_steps_handler_get(mfd_modes);
+    netsnmp_inject_handler(reginfo, handler);
+
+    /*************************************************
+     *
+     * inject row_merge helper with prefix rootoid_len + 2 (entry.col)
+     */
+    handler = netsnmp_get_row_merge_handler(reginfo->rootoid_len + 2);
+    netsnmp_inject_handler(reginfo, handler);
+
+    /*************************************************
+     *
+     * inject container_table helper
+     */
+    handler =
+        netsnmp_container_table_handler_get(tbl_info,
+                                            lreInterfaceStatsTable_if_ctx.container,
+                                            TABLE_CONTAINER_KEY_NETSNMP_INDEX);
+    netsnmp_inject_handler( reginfo, handler );
+
+    /*************************************************
+     *
+     * inject cache helper
+     */
+    if(NULL != lreInterfaceStatsTable_if_ctx.cache) {
+        handler = netsnmp_cache_handler_get(lreInterfaceStatsTable_if_ctx.cache);
+        netsnmp_inject_handler( reginfo, handler );
+    }
+
+    /*
+     * register table
+     */
+    netsnmp_register_table(reginfo, tbl_info);
+
+} /* _lreInterfaceStatsTable_initialize_interface */
+
+/**
+ * @internal
+ * Shutdown the table lreInterfaceStatsTable
+ */
+void
+_lreInterfaceStatsTable_shutdown_interface(lreInterfaceStatsTable_registration * reg_ptr)
+{
+    /*
+     * shutdown the container
+     */
+    _lreInterfaceStatsTable_container_shutdown(&lreInterfaceStatsTable_if_ctx);
+}
+
+void
+lreInterfaceStatsTable_valid_columns_set(netsnmp_column_info *vc)
+{
+    lreInterfaceStatsTable_if_ctx.tbl_info.valid_columns = vc;
+} /* lreInterfaceStatsTable_valid_columns_set */
+
+/**
+ * @internal
+ * convert the index component stored in the context to an oid
+ */
+int
+lreInterfaceStatsTable_index_to_oid(netsnmp_index *oid_idx,
+                         lreInterfaceStatsTable_mib_index *mib_idx)
+{
+    int err = SNMP_ERR_NOERROR;
+    
+    /*
+     * temp storage for parsing indexes
+     */
+    /*
+     * lreInterfaceStatsIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+     */
+    netsnmp_variable_list var_lreInterfaceStatsIndex;
+
+    /*
+     * set up varbinds
+     */
+    memset( &var_lreInterfaceStatsIndex, 0x00, sizeof(var_lreInterfaceStatsIndex) );
+    var_lreInterfaceStatsIndex.type = ASN_UNSIGNED;
+
+    /*
+     * chain temp index varbinds together
+     */
+    var_lreInterfaceStatsIndex.next_variable =  NULL;
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_index_to_oid","called\n"));
+
+        /* lreInterfaceStatsIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h */
+    snmp_set_var_value(&var_lreInterfaceStatsIndex, &mib_idx->lreInterfaceStatsIndex, sizeof(mib_idx->lreInterfaceStatsIndex));
+
+
+    err = build_oid_noalloc(oid_idx->oids, oid_idx->len, &oid_idx->len,
+                           NULL, 0, &var_lreInterfaceStatsIndex);
+    if(err)
+        snmp_log(LOG_ERR,"error %d converting index to oid\n", err);
+
+    /*
+     * parsing may have allocated memory. free it.
+     */
+    snmp_reset_var_buffers( &var_lreInterfaceStatsIndex );
+
+    return err;
+} /* lreInterfaceStatsTable_index_to_oid */
+
+/**
+ * extract lreInterfaceStatsTable indexes from a netsnmp_index
+ *
+ * @retval SNMP_ERR_NOERROR  : no error
+ * @retval SNMP_ERR_GENERR   : error
+ */
+int
+lreInterfaceStatsTable_index_from_oid(netsnmp_index *oid_idx,
+                         lreInterfaceStatsTable_mib_index *mib_idx)
+{
+    int err = SNMP_ERR_NOERROR;
+    
+    /*
+     * temp storage for parsing indexes
+     */
+    /*
+     * lreInterfaceStatsIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+     */
+    netsnmp_variable_list var_lreInterfaceStatsIndex;
+
+    /*
+     * set up varbinds
+     */
+    memset( &var_lreInterfaceStatsIndex, 0x00, sizeof(var_lreInterfaceStatsIndex) );
+    var_lreInterfaceStatsIndex.type = ASN_UNSIGNED;
+
+    /*
+     * chain temp index varbinds together
+     */
+    var_lreInterfaceStatsIndex.next_variable =  NULL;
+
+
+    DEBUGMSGTL(("verbose:lreInterfaceStatsTable:lreInterfaceStatsTable_index_from_oid","called\n"));
+
+    /*
+     * parse the oid into the individual index components
+     */
+    err = parse_oid_indexes( oid_idx->oids, oid_idx->len,
+                             &var_lreInterfaceStatsIndex );
+    if (err == SNMP_ERR_NOERROR) {
+        /*
+         * copy out values
+         */
+    mib_idx->lreInterfaceStatsIndex = *((u_long *)var_lreInterfaceStatsIndex.val.string);
+
+
+    }
+
+    /*
+     * parsing may have allocated memory. free it.
+     */
+    snmp_reset_var_buffers( &var_lreInterfaceStatsIndex );
+
+    return err;
+} /* lreInterfaceStatsTable_index_from_oid */
+
+
+/* *********************************************************************
+ * @internal
+ * allocate resources for a lreInterfaceStatsTable_rowreq_ctx
+ */
+lreInterfaceStatsTable_rowreq_ctx *
+lreInterfaceStatsTable_allocate_rowreq_ctx(void *user_init_ctx)
+{
+    lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx =
+                  SNMP_MALLOC_TYPEDEF(lreInterfaceStatsTable_rowreq_ctx);
+
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:lreInterfaceStatsTable_allocate_rowreq_ctx","called\n"));
+
+    if(NULL == rowreq_ctx) {
+        snmp_log(LOG_ERR,"Couldn't allocate memory for a "
+                 "lreInterfaceStatsTable_rowreq_ctx.\n");
+        return NULL;
+    }
+
+    rowreq_ctx->oid_idx.oids = rowreq_ctx->oid_tmp;
+
+    rowreq_ctx->lreInterfaceStatsTable_data_list = NULL;
+
+    /*
+     * if we allocated data, call init routine
+     */
+    if (!(rowreq_ctx->rowreq_flags & MFD_ROW_DATA_FROM_USER)) {
+        if(SNMPERR_SUCCESS !=
+            lreInterfaceStatsTable_rowreq_ctx_init(rowreq_ctx, user_init_ctx)) {
+           lreInterfaceStatsTable_release_rowreq_ctx(rowreq_ctx);
+           rowreq_ctx = NULL;
+        }
+    }
+
+    return rowreq_ctx;
+} /* lreInterfaceStatsTable_allocate_rowreq_ctx */
+
+/*
+ * @internal
+ * release resources for a lreInterfaceStatsTable_rowreq_ctx
+ */
+void
+lreInterfaceStatsTable_release_rowreq_ctx(lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:lreInterfaceStatsTable_release_rowreq_ctx","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+    
+    lreInterfaceStatsTable_rowreq_ctx_cleanup(rowreq_ctx);
+
+    /*
+     * free index oid pointer
+     */
+    if(rowreq_ctx->oid_idx.oids != rowreq_ctx->oid_tmp)
+        free(rowreq_ctx->oid_idx.oids);
+
+    SNMP_FREE(rowreq_ctx);
+} /* lreInterfaceStatsTable_release_rowreq_ctx */
+
+/**
+ * @internal
+ * wrapper
+ */
+static int
+_mfd_lreInterfaceStatsTable_pre_request(netsnmp_mib_handler *handler,
+                            netsnmp_handler_registration *reginfo,
+                            netsnmp_agent_request_info *agtreq_info,
+                            netsnmp_request_info *requests)
+{
+    int rc;
+
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:_mfd_lreInterfaceStatsTable_pre_request",
+                "called\n"));
+    
+    if (1 != netsnmp_row_merge_status_first(reginfo, agtreq_info)) {
+        DEBUGMSGTL(("internal:lreInterfaceStatsTable",
+                    "skipping additional pre_request\n"));
+        return SNMP_ERR_NOERROR;
+    }
+        
+    rc = lreInterfaceStatsTable_pre_request(lreInterfaceStatsTable_if_ctx.user_ctx);
+    if (MFD_SUCCESS != rc) {
+        /*
+         * nothing we can do about it but log it
+         */
+        DEBUGMSGTL(("lreInterfaceStatsTable","error %d from "
+                    "lreInterfaceStatsTable_pre_request\n", rc));
+        netsnmp_request_set_error_all(requests, SNMP_VALIDATE_ERR(rc));
+    }
+    
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceStatsTable_pre_request */
+
+/**
+ * @internal
+ * wrapper
+ */
+static int
+_mfd_lreInterfaceStatsTable_post_request(netsnmp_mib_handler *handler,
+                             netsnmp_handler_registration *reginfo,
+                             netsnmp_agent_request_info *agtreq_info,
+                             netsnmp_request_info *requests)
+{
+    lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx = (lreInterfaceStatsTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+    int rc, packet_rc;
+
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:_mfd_lreInterfaceStatsTable_post_request",
+                "called\n"));
+
+    /*
+     * release row context, if deleted
+     */
+    if (rowreq_ctx && (rowreq_ctx->rowreq_flags & MFD_ROW_DELETED))
+        lreInterfaceStatsTable_release_rowreq_ctx(rowreq_ctx);
+
+    /*
+     * wait for last call before calling user
+     */
+    if (1 != netsnmp_row_merge_status_last(reginfo, agtreq_info)) {
+        DEBUGMSGTL(("internal:lreInterfaceStatsTable",
+                    "waiting for last post_request\n"));
+        return SNMP_ERR_NOERROR;
+    }
+    
+    packet_rc = netsnmp_check_all_requests_error(agtreq_info->asp, 0);
+    rc = lreInterfaceStatsTable_post_request(lreInterfaceStatsTable_if_ctx.user_ctx,packet_rc);
+    if (MFD_SUCCESS != rc) {
+        /*
+         * nothing we can do about it but log it
+         */
+        DEBUGMSGTL(("lreInterfaceStatsTable","error %d from "
+                    "lreInterfaceStatsTable_post_request\n", rc));
+    }
+    
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceStatsTable_post_request */
+
+/**
+ * @internal
+ * wrapper
+ */
+static int
+_mfd_lreInterfaceStatsTable_object_lookup(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    int                    rc = SNMP_ERR_NOERROR;
+    lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx = (lreInterfaceStatsTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+    
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:_mfd_lreInterfaceStatsTable_object_lookup","called\n"));
+
+    /*
+     * get our context from mfd
+     * lreInterfaceStatsTable_interface_ctx *if_ctx =
+     *             (lreInterfaceStatsTable_interface_ctx *)reginfo->my_reg_void;
+     */
+
+    if(NULL == rowreq_ctx) {
+        rc = SNMP_ERR_NOCREATION;
+    }
+
+    if (MFD_SUCCESS != rc)
+        netsnmp_request_set_error_all(requests, rc);
+    else
+        lreInterfaceStatsTable_row_prep(rowreq_ctx);
+
+    return SNMP_VALIDATE_ERR(rc);
+} /* _mfd_lreInterfaceStatsTable_object_lookup */
+
+/***********************************************************************
+ *
+ * GET processing
+ *
+ ***********************************************************************/
+/*
+ * @internal
+ * Retrieve the value for a particular column
+ */
+NETSNMP_STATIC_INLINE int
+_lreInterfaceStatsTable_get_column( lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx,
+                       netsnmp_variable_list *var, int column )
+{
+    int rc = SNMPERR_SUCCESS;
+    
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:_mfd_lreInterfaceStatsTable_get_column",
+                "called for %d\n", column));
+
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    switch(column) {
+
+    /* lreCntTxA(2)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTTXA:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntTxA_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntTxB(3)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTTXB:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntTxB_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntTxC(4)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTTXC:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntTxC_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntErrWrongLanA(5)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTERRWRONGLANA:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntErrWrongLanA_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntErrWrongLanB(6)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTERRWRONGLANB:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntErrWrongLanB_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntErrWrongLanC(7)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTERRWRONGLANC:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntErrWrongLanC_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntRxA(8)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTRXA:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntRxA_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntRxB(9)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTRXB:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntRxB_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntRxC(10)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTRXC:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntRxC_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntErrorsA(11)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTERRORSA:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntErrorsA_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntErrorsB(12)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTERRORSB:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntErrorsB_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntErrorsC(13)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTERRORSC:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntErrorsC_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntNodes(14)/INTEGER32/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTNODES:
+    var->val_len = sizeof(long);
+    var->type = ASN_INTEGER;
+rc = lreCntNodes_get(rowreq_ctx, (long *)var->val.string );
+        break;
+
+    /* lreCntProxyNodes(15)/INTEGER32/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTPROXYNODES:
+    var->val_len = sizeof(long);
+    var->type = ASN_INTEGER;
+rc = lreCntProxyNodes_get(rowreq_ctx, (long *)var->val.string );
+        break;
+
+    /* lreCntUniqueA(16)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTUNIQUEA:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntUniqueA_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntUniqueB(17)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTUNIQUEB:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntUniqueB_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntUniqueC(18)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTUNIQUEC:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntUniqueC_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntDuplicateA(19)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTDUPLICATEA:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntDuplicateA_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntDuplicateB(20)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTDUPLICATEB:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntDuplicateB_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntDuplicateC(21)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTDUPLICATEC:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntDuplicateC_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntMultiA(22)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTMULTIA:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntMultiA_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntMultiB(23)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTMULTIB:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntMultiB_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntMultiC(24)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTMULTIC:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntMultiC_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntOwnRxA(25)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTOWNRXA:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntOwnRxA_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreCntOwnRxB(26)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRECNTOWNRXB:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_COUNTER;
+rc = lreCntOwnRxB_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+     default:
+        if (LREINTERFACESTATSTABLE_MIN_COL <= column && column <= LREINTERFACESTATSTABLE_MAX_COL) {
+            DEBUGMSGTL(("internal:lreInterfaceStatsTable:_mfd_lreInterfaceStatsTable_get_column",
+                "assume column %d is reserved\n", column));
+            rc = MFD_SKIP;
+        } else {
+            snmp_log(LOG_ERR,
+                "unknown column %d in _lreInterfaceStatsTable_get_column\n", column);
+        }
+        break;
+    }
+
+    return rc;
+} /* _lreInterfaceStatsTable_get_column */
+
+int
+_mfd_lreInterfaceStatsTable_get_values(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx = (lreInterfaceStatsTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+    netsnmp_table_request_info * tri;
+    u_char                     * old_string;
+    void                      (*dataFreeHook)(void *);
+    int                        rc;
+
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:_mfd_lreInterfaceStatsTable_get_values","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+    
+    for(;requests; requests = requests->next) {
+        /*
+         * save old pointer, so we can free it if replaced
+         */
+        old_string = requests->requestvb->val.string;
+        dataFreeHook = requests->requestvb->dataFreeHook;
+        if(NULL == requests->requestvb->val.string) {
+            requests->requestvb->val.string = requests->requestvb->buf;
+            requests->requestvb->val_len = sizeof(requests->requestvb->buf);
+        }
+        else if(requests->requestvb->buf == requests->requestvb->val.string) {
+            if(requests->requestvb->val_len != sizeof(requests->requestvb->buf))
+                requests->requestvb->val_len = sizeof(requests->requestvb->buf);
+        }
+
+        /*
+         * get column data
+         */
+        tri = netsnmp_extract_table_info(requests);
+        if(NULL == tri)
+            continue;
+        
+        rc = _lreInterfaceStatsTable_get_column(rowreq_ctx, requests->requestvb, tri->colnum);
+        if(rc) {
+            if(MFD_SKIP == rc) {
+                requests->requestvb->type = SNMP_NOSUCHINSTANCE;
+                rc = SNMP_ERR_NOERROR;
+            }
+        }
+        else if (NULL == requests->requestvb->val.string) {
+            snmp_log(LOG_ERR,"NULL varbind data pointer!\n");
+            rc = SNMP_ERR_GENERR;
+        }
+        if(rc)
+            netsnmp_request_set_error(requests, SNMP_VALIDATE_ERR(rc));
+
+        /*
+         * if the buffer wasn't used previously for the old data (i.e. it
+         * was allcoated memory)  and the get routine replaced the pointer,
+         * we need to free the previous pointer.
+         */
+        if(old_string && (old_string != requests->requestvb->buf) &&
+           (requests->requestvb->val.string != old_string)) {
+            if(dataFreeHook)
+                (*dataFreeHook)(old_string);
+            else
+                free(old_string);
+        }
+    } /* for results */
+
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreInterfaceStatsTable_get_values */
+
+/***********************************************************************
+ *
+ * SET processing
+ *
+ ***********************************************************************/
+
+/*
+ * SET PROCESSING NOT APPLICABLE (per MIB or user setting)
+ */
+/***********************************************************************
+ *
+ * DATA ACCESS
+ *
+ ***********************************************************************/
+static void _container_free(netsnmp_container *container);
+
+/**
+ * @internal
+ */
+static int
+_cache_load(netsnmp_cache *cache, void *vmagic)
+{
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:_cache_load","called\n"));
+
+    if((NULL == cache) || (NULL == cache->magic)) {
+        snmp_log(LOG_ERR, "invalid cache for lreInterfaceStatsTable_cache_load\n");
+        return -1;
+    }
+
+    /** should only be called for an invalid or expired cache */
+    netsnmp_assert((0 == cache->valid) || (1 == cache->expired));
+    
+    /*
+     * call user code
+     */
+    return lreInterfaceStatsTable_container_load((netsnmp_container*)cache->magic);
+} /* _cache_load */
+
+/**
+ * @internal
+ */
+static void
+_cache_free(netsnmp_cache *cache, void *magic)
+{
+    netsnmp_container *container;
+
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:_cache_free","called\n"));
+
+    if((NULL == cache) || (NULL == cache->magic)) {
+        snmp_log(LOG_ERR, "invalid cache in lreInterfaceStatsTable_cache_free\n");
+        return;
+    }
+
+    container = (netsnmp_container*)cache->magic;
+
+    _container_free(container);
+} /* _cache_free */
+
+/**
+ * @internal
+ */
+static void
+_container_item_free(lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx, void *context)
+{
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:_container_item_free","called\n"));
+
+    if(NULL == rowreq_ctx)
+        return;
+
+    lreInterfaceStatsTable_release_rowreq_ctx(rowreq_ctx);
+} /* _container_item_free */
+
+/**
+ * @internal
+ */
+static void
+_container_free(netsnmp_container *container)
+{
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:_container_free","called\n"));
+
+    if (NULL == container) {
+        snmp_log(LOG_ERR, "invalid container in lreInterfaceStatsTable_container_free\n");
+        return;
+    }
+
+    /*
+     * call user code
+     */
+    lreInterfaceStatsTable_container_free(container);
+    
+    /*
+     * free all items. inefficient, but easy.
+     */
+    CONTAINER_CLEAR(container,
+                    (netsnmp_container_obj_func *)_container_item_free,
+                    NULL);
+} /* _container_free */
+
+/**
+ * @internal
+ * initialize the container with functions or wrappers
+ */
+void
+_lreInterfaceStatsTable_container_init(lreInterfaceStatsTable_interface_ctx *if_ctx)
+{
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:_lreInterfaceStatsTable_container_init","called\n"));
+
+    /*
+     * cache init
+     */
+    if_ctx->cache = netsnmp_cache_create(30, /* timeout in seconds */
+                                         _cache_load, _cache_free,
+                                         lreInterfaceStatsTable_oid,
+                                         lreInterfaceStatsTable_oid_size);
+
+    if(NULL == if_ctx->cache) {
+        snmp_log(LOG_ERR, "error creating cache for lreInterfaceStatsTable\n");
+        return;
+    }
+
+    if_ctx->cache->flags = NETSNMP_CACHE_DONT_INVALIDATE_ON_SET;
+
+    lreInterfaceStatsTable_container_init(&if_ctx->container, if_ctx->cache);
+    if(NULL == if_ctx->container)
+        if_ctx->container = netsnmp_container_find("lreInterfaceStatsTable:table_container");
+    if(NULL == if_ctx->container) {
+        snmp_log(LOG_ERR,"error creating container in "
+                 "lreInterfaceStatsTable_container_init\n");
+        return;
+    }
+
+    if (NULL != if_ctx->cache)
+        if_ctx->cache->magic = (void*)if_ctx->container;
+} /* _lreInterfaceStatsTable_container_init */
+
+/**
+ * @internal
+ * shutdown the container with functions or wrappers
+ */
+void
+_lreInterfaceStatsTable_container_shutdown(lreInterfaceStatsTable_interface_ctx *if_ctx)
+{
+    DEBUGMSGTL(("internal:lreInterfaceStatsTable:_lreInterfaceStatsTable_container_shutdown","called\n"));
+
+    lreInterfaceStatsTable_container_shutdown(if_ctx->container);
+
+    _container_free(if_ctx->container);
+
+} /* _lreInterfaceStatsTable_container_shutdown */
+
+
+lreInterfaceStatsTable_rowreq_ctx *
+lreInterfaceStatsTable_row_find_by_mib_index(lreInterfaceStatsTable_mib_index *mib_idx)
+{
+    lreInterfaceStatsTable_rowreq_ctx   *rowreq_ctx;
+    oid                      oid_tmp[MAX_OID_LEN];
+    netsnmp_index            oid_idx;
+    int                      rc;
+
+    /*
+     * set up storage for OID
+     */
+    oid_idx.oids = oid_tmp;
+    oid_idx.len = sizeof(oid_tmp)/sizeof(oid);
+
+    /*
+     * convert
+     */
+    rc = lreInterfaceStatsTable_index_to_oid(&oid_idx, mib_idx);
+    if (MFD_SUCCESS != rc)
+        return NULL;
+
+    rowreq_ctx = (lreInterfaceStatsTable_rowreq_ctx*)CONTAINER_FIND(lreInterfaceStatsTable_if_ctx.container, &oid_idx);
+
+    return rowreq_ctx;
+}
+
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_interface.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_interface.h
new file mode 100644
index 0000000..6ac0fdd
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_interface.h
@@ -0,0 +1,84 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+/** @ingroup interface: Routines to interface to Net-SNMP
+ *
+ * \warning This code should not be modified, called directly,
+ *          or used to interpret functionality. It is subject to
+ *          change at any time.
+ * 
+ * @{
+ */
+/*
+ * *********************************************************************
+ * *********************************************************************
+ * *********************************************************************
+ * ***                                                               ***
+ * ***  NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE  ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***       THIS FILE DOES NOT CONTAIN ANY USER EDITABLE CODE.      ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***       THE GENERATED CODE IS INTERNAL IMPLEMENTATION, AND      ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***    IS SUBJECT TO CHANGE WITHOUT WARNING IN FUTURE RELEASES.   ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * *********************************************************************
+ * *********************************************************************
+ * *********************************************************************
+ */
+#ifndef LREINTERFACESTATSTABLE_INTERFACE_H
+#define LREINTERFACESTATSTABLE_INTERFACE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include "lreInterfaceStatsTable.h"
+
+
+/* ********************************************************************
+ * Table declarations
+ */
+
+/* PUBLIC interface initialization routine */
+void _lreInterfaceStatsTable_initialize_interface(lreInterfaceStatsTable_registration * user_ctx,
+                                    u_long flags);
+void _lreInterfaceStatsTable_shutdown_interface(lreInterfaceStatsTable_registration * user_ctx);
+
+lreInterfaceStatsTable_registration *
+lreInterfaceStatsTable_registration_get( void );
+
+lreInterfaceStatsTable_registration *
+lreInterfaceStatsTable_registration_set( lreInterfaceStatsTable_registration * newreg );
+
+netsnmp_container *lreInterfaceStatsTable_container_get( void );
+int lreInterfaceStatsTable_container_size( void );
+
+    lreInterfaceStatsTable_rowreq_ctx * lreInterfaceStatsTable_allocate_rowreq_ctx(void *);
+void lreInterfaceStatsTable_release_rowreq_ctx(lreInterfaceStatsTable_rowreq_ctx *rowreq_ctx);
+
+int lreInterfaceStatsTable_index_to_oid(netsnmp_index *oid_idx,
+                            lreInterfaceStatsTable_mib_index *mib_idx);
+int lreInterfaceStatsTable_index_from_oid(netsnmp_index *oid_idx,
+                              lreInterfaceStatsTable_mib_index *mib_idx);
+
+/*
+ * access to certain internals. use with caution!
+ */
+void lreInterfaceStatsTable_valid_columns_set(netsnmp_column_info *vc);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACESTATSTABLE_INTERFACE_H */
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_oids.h b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_oids.h
new file mode 100644
index 0000000..2452639
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreInterfaceStatsTable/lreInterfaceStatsTable_oids.h
@@ -0,0 +1,81 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  $
+ *
+ * $Id:$
+ */
+#ifndef LREINTERFACESTATSTABLE_OIDS_H
+#define LREINTERFACESTATSTABLE_OIDS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* column number definitions for table lreInterfaceStatsTable */
+#define LREINTERFACESTATSTABLE_OID              1,0,62439,2,21,1,1,0,1
+
+
+#define COLUMN_LREINTERFACESTATSINDEX         1
+    
+#define COLUMN_LRECNTTXA         2
+    
+#define COLUMN_LRECNTTXB         3
+    
+#define COLUMN_LRECNTTXC         4
+    
+#define COLUMN_LRECNTERRWRONGLANA         5
+    
+#define COLUMN_LRECNTERRWRONGLANB         6
+    
+#define COLUMN_LRECNTERRWRONGLANC         7
+    
+#define COLUMN_LRECNTRXA         8
+    
+#define COLUMN_LRECNTRXB         9
+    
+#define COLUMN_LRECNTRXC         10
+    
+#define COLUMN_LRECNTERRORSA         11
+    
+#define COLUMN_LRECNTERRORSB         12
+    
+#define COLUMN_LRECNTERRORSC         13
+    
+#define COLUMN_LRECNTNODES         14
+    
+#define COLUMN_LRECNTPROXYNODES         15
+    
+#define COLUMN_LRECNTUNIQUEA         16
+    
+#define COLUMN_LRECNTUNIQUEB         17
+    
+#define COLUMN_LRECNTUNIQUEC         18
+    
+#define COLUMN_LRECNTDUPLICATEA         19
+    
+#define COLUMN_LRECNTDUPLICATEB         20
+    
+#define COLUMN_LRECNTDUPLICATEC         21
+    
+#define COLUMN_LRECNTMULTIA         22
+    
+#define COLUMN_LRECNTMULTIB         23
+    
+#define COLUMN_LRECNTMULTIC         24
+    
+#define COLUMN_LRECNTOWNRXA         25
+    
+#define COLUMN_LRECNTOWNRXB         26
+    
+
+#define LREINTERFACESTATSTABLE_MIN_COL   COLUMN_LRECNTTXA
+#define LREINTERFACESTATSTABLE_MAX_COL   COLUMN_LRECNTOWNRXB
+    
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LREINTERFACESTATSTABLE_OIDS_H */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreInterfaceStatsIndex.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreInterfaceStatsIndex.m2d
new file mode 100644
index 0000000..69942dd
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreInterfaceStatsIndex.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreInterfaceStatsIndex
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreNodesIndex.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreNodesIndex.m2d
new file mode 100644
index 0000000..9bdbfc3
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreNodesIndex.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreNodesIndex
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreNodesMacAddress.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreNodesMacAddress.m2d
new file mode 100644
index 0000000..7780ce4
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreNodesMacAddress.m2d
@@ -0,0 +1,43 @@
+########################################################################
+##
+## mib2c node setting for lreNodesMacAddress
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = char@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 1@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
+########################################################################
+## Allow realloc when data size exceeds length? If your data
+## store for this node is a pointer allocated with one of the
+## alloc family functions, you can set this to 1 to use realloc
+## when a new value length exceeds the old lenght. If you are
+## using a fixed size buffer, this value should be 0.
+##
+## @eval $m2c_node_realloc = 0@
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreRemNodeType.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreRemNodeType.m2d
new file mode 100644
index 0000000..8888e89
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreRemNodeType.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreRemNodeType
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreTimeLastSeenA.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreTimeLastSeenA.m2d
new file mode 100644
index 0000000..aa64781
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreTimeLastSeenA.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreTimeLastSeenA
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreTimeLastSeenB.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreTimeLastSeenB.m2d
new file mode 100644
index 0000000..30e8329
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/node-lreTimeLastSeenB.m2d
@@ -0,0 +1,35 @@
+########################################################################
+##
+## mib2c node setting for lreTimeLastSeenB
+##
+## Remove the '##' comment delimeter to change settings
+##
+########################################################################
+## Node declaration type? This is the C type to be used when
+## declaring a variable to hold a value for this column. It
+## is strongly recommended that you do not change this value.
+## If you do, it is likely to break lots of generated code that
+## you will have to fix.
+##
+## @eval $m2c_decl = u_long@
+##
+########################################################################
+## Generate/use mapping functions? Useful if the MIB defines
+## a different format or enumerations than you data store uses.
+##
+## @eval $m2c_node_skip_mapping = 1@
+##
+########################################################################
+## Need a length for the value? Most OCTET-STRING based values will
+## need a length, most other types will not. Do not change this one
+## unless you know what you are doing! You will almost certainly need
+## to fix lots of generated code if you do.
+##
+## @eval $m2c_node_needlength = 0@
+##
+########################################################################
+## Skip get? Set this to 1 if you do not want to implement a value
+## for this column.
+##
+## @eval $m2c_node_skip_get = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/table-lreNodesTable.m2d b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/table-lreNodesTable.m2d
new file mode 100644
index 0000000..bd5a39c
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/defaults/table-lreNodesTable.m2d
@@ -0,0 +1,103 @@
+## ########################################################################
+##
+## mib2c Table setting for lreNodesTable
+##
+## ########################################################################
+##
+## User context structure type
+##
+@eval $m2c_context_reg = "netsnmp_data_list"@
+##
+## ########################################################################
+##
+## Allocate data structure in row structure? (vs embedd)
+##
+@eval $m2c_data_allocate = 0@
+##
+## ########################################################################
+##
+## Generate code to cache data?
+##
+@eval $m2c_data_cache = 1@
+##
+## ########################################################################
+##
+## Data context structure type
+##
+@eval $m2c_data_context = "generated"@ [generated|NAME]
+##
+## ########################################################################
+##
+## Generate function to initialize row context when created?
+##
+@eval $m2c_data_init = 1@
+##
+## ########################################################################
+##
+## Persistence of data context
+## // 0:persistent, 1:semi-transient, 2:transient
+##
+@eval $m2c_data_transient = 2@
+##
+## ########################################################################
+##
+## Include some example code?
+##
+@eval $m2c_include_examples = 1@
+##
+## ########################################################################
+##
+## Generate code for irreversible_commit mode?
+##
+@eval $m2c_irreversible_commit = 0@
+##
+## ########################################################################
+##
+## Data access method
+##
+@eval $m2c_table_access = "container-cached"@
+##
+## ########################################################################
+##
+## Generate row dependency function?
+##
+@eval $m2c_table_dependencies = 0@
+##
+## ########################################################################
+##
+## Generate data store/restore functions for persistent storage?
+##
+@eval $m2c_table_persistent = 0@
+##
+## ########################################################################
+##
+## Generate code for dynamic row creation?
+##
+@eval $m2c_table_row_creation = 0@
+##
+## ########################################################################
+##
+## Generate code for settable objects?
+##
+@eval $m2c_table_settable = 0@
+##
+## ########################################################################
+##
+## Skip mapping between data context and MIB formats?
+## // 0:generate maps, 1:skip maps, -1:skip unless enum/oid
+##
+@eval $m2c_table_skip_mapping = 1@
+##
+## ########################################################################
+##
+## Generate code for sparse tables?
+##
+@eval $m2c_table_sparse = 0@
+##
+## ########################################################################
+##
+## Generate Makefile/AgentX code?
+##
+@eval $mfd_generate_makefile = 0@
+@eval $mfd_generate_subagent = 0@
+##
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable-README-FIRST.txt b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable-README-FIRST.txt
new file mode 100644
index 0000000..fb19985
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable-README-FIRST.txt
@@ -0,0 +1,167 @@
+************************************************************************
+lreNodesTable README
+------------------------------------------------------------------------
+This document describes the results of the mib2c code generation
+system using the mfd code generation template.  The resulting files
+are documented both in this README file as well as per-table specific
+README files.  All of the files generated by this run of mib2c will
+begin with the lreNodesTable prefix.
+
+Quick Start
+-----------
+For those interested in a quick start, to get a pseudo-todo list, try
+this command in directory with the generated code:
+
+ grep -n "TODO:" *.[ch] | sed 's/\([^ ]*\) \(.*\)TODO\(.*\)/\3 (\1)/' | sort -n
+
+Key:
+  :o: Optional
+  :r: Recommended
+  :M: Mandatory
+  :A: Advanced users
+
+This will give you and ordered list of places in the code that you
+may (or must) take a closer look at).
+
+You may also want to take a look at the on-line tutorial, found here:
+
+    http://www.net-snmp.org/tutorial/tutorial-5/toolkit/mfd/index.html
+
+
+MIBs For Dummies Overview
+-------------------------
+The MIBs For Dummies (MFD) configuration files have been written to help
+SNMP novices implement SNMP MIBs. This section will be a brief
+introduction to some of the general concepts you should be familar with.
+
+  Managed Information Base (MIB)
+  ------------------------------
+  A SNMP MIB (Managed information base) is a text file that describes the
+  syntax for some set of data objects. The MIB creates a correlation
+  between an ASCII name for an object and a number OID (Object Identifier).
+  The SNMP protocol communicates information using the OIDs, and the MIB
+  allows tools to display a name, which we humans find easier to deal with.
+
+  To use an analogy, a MIB is much like a menu at a restaurant. If you've
+  ever been to a reataurant and ordered a meal, and later received a bill
+  that simply had '#6' on it, you get the idea. The name is easier for
+  the customers to remember, and the waiters and chefs use the number for
+  efficency.
+
+
+    Scalars
+    -------
+    A scalar variable is a unique object in a MIB which can represent
+    a single value. For example, the SNMP standard MIB-II defines a
+    variable, sysContact.0, which is a string containing the contact
+    information for the person in charge of a particular agent. Note
+    that scalar variable always end with '.0'.
+    
+
+    Rows and Tables
+    ---------------
+    When a group of related attributes occur more than once, they can be
+    grouped together in a table. A table has an index, which uniquely
+    identifies a particular row, and data columns, which contain the
+    attributes for that row.
+
+    For example, the SNMP standard MIB-II defines a table, ifTable, which
+    contains information on the ethernet interfaces on a system.
+    
+
+  Data Structures
+  ---------------
+  The code generated by the MFD configuration files has a few important
+  structures.
+
+
+    The Data Context
+    ----------------
+    The data context structure should contain the necessary information
+    to provide the data for the columns in a given row. As long as you
+    can extract the data for a column for the data context, the data context
+    can be anything you want: a pointer to an existing structure, the
+    parameters needed for a function call or an actual copy of the data.
+
+    By default, a data context structure is generated with storage for
+    all the data in a row. Information on changing the default is presented
+    later on in this help.
+
+
+    The MIB Context
+    ---------------
+    The MIB context structure is generated with storage for all the
+    indexes of a table. This data will be used when searching for the
+    correct row to process for a request.
+
+
+    The Row Request Context
+    -----------------------
+    Each table will have a unique data structure for holding data during
+    the processing of a particular row. The row request context contains
+    the registration context (that you supply during initilization),
+    the data context, the MIB context, the undo context (for settable
+    tables) and other data. There is also a netsnmp_data_list, which can
+    be used to temporary storage during processing.
+
+
+    The Table Registration Pointer
+    ------------------------------
+    During initilization, you may provide a pointer to arbitrary data for
+    you own use. This pointer will be saved in the row request context,
+    and is passed as a parameter to several functions. It is not required,
+    and is provided as a way for you to access table specific data in
+    the generated code.
+
+
+
+These files are top-level files potentially useful for all the tables: 
+------------------------------------------------------------------------
+
+  File    : lreNodesTable_Makefile
+  ----------------------------------------------------------------------
+  Purpose : Make file for compiling a (sub)agent.  This file is only
+            useful if you don't want to compile your code directly
+            into the Net-SNMP master agent.
+  Editable: Optional
+  Usage   : make -f lreNodesTable_Makefile
+
+
+  File    : lreNodesTable_subagent.c
+  ----------------------------------------------------------------------
+  Purpose : This file contains a main() function for an agent or
+            sub-agent and is compiled using the Makefile above.
+
+
+
+
+Table specific README files
+------------------------------------------------------------------------
+Each table for which code was generated has its own README file
+describing the files specifically associated with each table.  You
+should probably read these next:
+
+   lreNodesTable-README-lreNodesTable.txt
+
+
+
+These are miscellaneous auto-generated code files you generally
+shouldn't edit.  They contain code that ties your code together with
+the Net-SNMP agent.
+------------------------------------------------------------------------
+  File    : lreNodesTable.h
+  Purpose : Header file for the module set.  Includes config_require
+            macros to auto-load the other code pieces when compiled
+            into the agent.
+
+  File    : lreNodesTable_oids.h
+  Purpose : C #define definitions of the tables, columns, and OIDs
+
+  File    : lreNodesTable_enums.h
+  Purpose : C #define definitions of the enumerated type values for
+            each column of each table that requires them.
+
+  File    : lreNodesTable_interface.c
+  Purpose : MFD interface to Net-SNMP.  This auto-generated code ties the
+            functions you will fill out to the code that the agent needs.
+
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable-README-lreNodesTable.txt b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable-README-lreNodesTable.txt
new file mode 100644
index 0000000..daff8d7
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable-README-lreNodesTable.txt
@@ -0,0 +1,552 @@
+************************************************************************
+lreNodesTable README
+------------------------------------------------------------------------
+  This readme file describes the code generated by mib2c (using the MIBs
+  for Dummies (MFD) configuration file). The code generated was
+  generated specifically for the following SNMP table:
+
+     lreNodesTable
+
+  Your code will be called when the snmp agent receives requests for
+  the lreNodesTable table.  The agent will start by looking for the right
+  row in your existing data to operate on, if one exists.
+
+
+  Configuration Variables
+  ------------------------------------------------------------
+  Some variables used for code generation may be set to affect the code
+  generation. You may override these variables by setting them in the
+  file defaults/table-lreNodesTable.m2d, and then re-running mib2c.
+
+    m2c_table_settable (currently '0')
+    --------------------------------------------------------
+    This variable determines whether or not code is generated to support
+    MIB object which have an access of read-write or read-create. The
+    default is set based on whether or not the table contains writable
+    objects, but can be over-ridden.
+
+    Syntax: @eval $m2c_table_settable = 0@
+
+
+    m2c_table_dependencies (currently '0')
+    --------------------------------------------------------
+    This variable determines whether or not code is generated to support
+    checking dependencies between columns, rows or tables. The default
+    is set based on whether or not the table contains writable objects,
+    but can be over-ridden.
+
+    Syntax: @eval $m2c_table_dependencies = 0@
+
+
+    m2c_table_row_creation (currently '0')
+    --------------------------------------------------------
+    This variable determines whether or not code is generated to support
+    checking creation of new rows via SNMP. The default is set based on
+    whether or not the table contains read-create objects, but can be
+    over-ridden.
+
+    Syntax: @eval $m2c_table_row_creation = 0@
+
+
+    m2c_context_reg (currently 'netsnmp_data_list')
+    --------------------------------------------------------
+    This variable contains the structure name to typedef for the
+    lreNodesTable_registration.
+
+    During initilization, you will provide a pointer to a structure of
+    this type. This pointer is used as a parameter to many functions so
+    that you have access to your registration data. The default is a
+    netsnmp_data_list pointer, which will allow you to keep multiple
+    pointers tagged by a text name. If you have a new or existing structure
+    you would rather use, you can redefine this variable.
+    
+
+    To avoid regenerating code, you may also change this typedef directly
+    in the lreNodesTable.h header.
+
+    Syntax: @eval $m2c_context_reg = "struct my_registration_context@
+
+
+    m2c_data_context (currently 'generated')
+    --------------------------------------------------------
+    This variable contains the structure name to typedef for the
+    lreNodesTable_data.
+
+    This typedef is used in the row request context structure for the table,
+    lreNodesTable_rowreq_ctx.
+
+    The typedef in the primary table context will be used for the data and
+    undo structure types. This structure should contain all the data
+    needed for all the columns in the table. The default is 'generated',
+    which will cuase a new data strcuture to be generated with data members
+    for each column.
+
+    To avoid regenerating code, you may also change this typedef directly
+    in the lreNodesTable.h header.
+
+    Syntax: @eval $m2c_data_context = "struct my_data_context"@
+
+
+    m2c_data_allocate (currently '0')
+    --------------------------------------------------------
+    This variable determines whether or not the data context (see above)
+    requires memory to be allocated. The default generated data structure
+    does not. If you are using a custom data context which needs to
+    allocate memory, override this value and two additional functions
+    will be generated:
+
+      lreNodesTable_allocate_data
+      lreNodesTable_release_data
+
+    Syntax: @eval $m2c_data_allocate = 1@
+
+
+    m2c_data_init (currently '1')
+    --------------------------------------------------------
+    This variable determines whether or not the data context (see above)
+    or any other items you have added to the table context requires
+    initialization. The default generated data structure does not. If you
+    are using a custom data context or have added items needing initialization
+    to the table context, override this value and two additional functions
+    will be generated:
+
+      lreNodesTable_rowreq_ctx_init
+      lreNodesTable_rowreq_ctx_cleanup
+
+    Syntax: @eval 1 = 1@
+
+
+    m2c_table_access (currently 'container-cached')
+    ------------------------------------------------------------------
+    This variable determines which data interface will be use to generate
+    code for looking up data for a given index. The default is the
+    'container-cached' access code, which caches the data in a netsnmp-
+    container (usually a sorted array).
+
+    Available options can be determined by checking for mib2c configuration
+    files that begin with 'mfd-access-*'.
+
+    Syntax: @eval $m2c_table_access = 'container-cached'@
+
+ 
+    m2c_include_examples (currently '1')
+    ------------------------------------------------------------------
+    This variable determines whether or not to generate example code. The
+    default is to generate example code.
+
+    Syntax: @eval $m2c_include_examples = 0@
+
+
+    m2c_data_transient (currently '2')
+    ------------------------------------------------------------------
+    This variable determines how the generated example code deals with the
+    data during data lookup. See the table readme file for details on how
+    the current table access method interprets this value. In general,
+    a value of 0 indicates persistent data, 1 indicates semi-transient and
+    2 indicates transient data.
+
+    Syntax: @eval $m2c_data_transient = 0@
+
+
+ Index(es) for the lreNodesTable table
+  ------------------------------------------------------------
+  The index(es) for the lreNodesTable table are:
+
+     lreInterfaceStatsIndex:
+        Syntax:      UNSIGNED32
+        DataType:    UNSIGNED32
+        ASN type:    ASN_UNSIGNED
+        C-code type: u_long
+     lreNodesIndex:
+        Syntax:      UNSIGNED32
+        DataType:    UNSIGNED32
+        ASN type:    ASN_UNSIGNED
+        C-code type: u_long
+
+  You should know how to set all these values from your data context,
+  lreNodesTable_data.
+
+
+************************************************************************
+lreNodesTable File Overview
+------------------------------------------------------------------------
+  Several files have been generated to implement the lreNodesTable
+  table. We'll go through these files, one by one, explaining each and
+  letting you know which you need to edit.
+
+
+File: lreNodesTable_data_access.[c|h]
+------------------------------------------------------------------------
+  The lreNodesTable_data_access file contains the interface to your data in
+  its raw format.  These functions are used to build the row cache or 
+  locate the row (depending on the table access method).
+
+  Set MIB context
+  -----------------
+  TODO : Set MIB index values
+  FUNC : lreNodesTable_indexes_set
+  WHERE: lreNodesTable_data_access.c
+
+  This is a convenience function for setting the index context from
+  the native C data. Where necessary, value mapping should be done.
+
+  This function should update the table index values (found in
+  tbl_idx) for the given raw data.
+
+  
+  container summary
+  ------------------------
+    The container data access code is for cases when you want to
+    store your data in the agent/sub-agent.
+
+    ... to be continued...
+
+
+  cache summary
+  ------------------------
+    The container-cached data access code is for cases when you want to
+    cache your data in the agent/sub-agent.
+
+    ... to be continued...
+
+
+
+
+File: lreNodesTable_enums.h
+------------------------------------------------------------------------
+  This file contains macros for mapping enumeration values when the
+  enumerated values defined by the MIB do not match the values used
+  internally.
+
+  Review this file to see if any values need to be updated.
+
+
+File: lreNodesTable_data_get.c
+------------------------------------------------------------------------
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreNodesMacAddress_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreTimeLastSeenA_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreTimeLastSeenB_get
+
+  Get data for column
+  -------------------
+  TODO : retrieve column data from raw data
+  FUNC : lreRemNodeType_get
+
+
+
+File: lreNodesTable_data_set.c
+------------------------------------------------------------------------
+
+  This table does not support set requests.
+
+
+************************************************************************
+lreNodesTable Reference
+------------------------------------------------------------------------
+
+Function flow
+----------------------------------------------------
+To give you the general idea of how the functions flow works, this
+example flow is from a complete table implementation.
+
+NOTE: Depending on your configuration, some of the functions used in the
+      examples below  may not have been generated for the
+      lreNodesTable table.
+
+      Conversely, the examples below may not include some functions that
+      were generated for the lreNodesTable table.
+
+To watch the flow of the lreNodesTable table, use the
+following debug tokens:
+
+        snmp_agent
+        helper:table:req
+        lreNodesTable
+        verbose:lreNodesTable
+        internal:lreNodesTable
+
+e.g.
+        snmpd -f -Le -DlreNodesTable,verbose:lreNodesTable,internal:lreNodesTable
+
+
+Initialization
+--------------------------------
+init_xxxTable: called                           xxx.c
+   initialize_table_xxxTable                    xxx.c
+      _xxxTable_initialize_interface            xxx_interface.c
+         xxxTable_init_data                     xxx_data_access.c
+      _xxxTable_container_init                  xxx_interface.c
+         xxxTable_container_init                xxx_data_access.c
+
+
+GET Request
+--------------------------------
+_cache_load                                     xxx_interface.c
+   xxxTable_cache_load                          xxx_data_access.c
+      xxxTable_allocate_rowreq_ctx              xxx_interface.c
+         xxxTable_allocate_data                 xxx_data_get.c
+         xxxTable_rowreq_ctx_init               xxx_data_get.c
+      xxxTable_indexes_set                      xxx_data_get.c
+         xxxTable_indexes_set_tbl_idx           xxx_data_get.c
+
+xxxTable_pre_request                              
+
+_mfd_xxxTable_object_lookup                     xxx_interface.c
+   xxxTable_row_prep                            xxx_data_access.c
+
+_mfd_xxxTable_get_values                        xxx_interface.c
+   _mfd_xxxTable_get_column                     xxx_interface.c
+      yyy_get                                   xxx_data_get.c
+
+xxxTable_post_request
+
+
+GETNEXT Request
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request                            ...
+_mfd_xxxTable_object_lookup                     ...
+_mfd_xxxTable_get_values                        ...
+xxxTable_post_request                           ...
+
+
+SET Request: success
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request
+_mfd_xxxTable_object_lookup                     ...
+
+_mfd_xxxTable_check_objects                     xxx_interface.c
+   _xxxTable_check_column                       xxx_interface.c
+      yyy_check_value                           xxx_data_set.c
+
+_mfd_xxxTable_undo_setup                        xxx_interface.c
+   xxxTable_allocate_data                       ...
+   xxxTable_undo_setup                          xxx_interface.c
+      _xxxTable_undo_setup_column               xxx_interface.c
+         yyy_undo_setup                         xxx_data_set.c
+
+_mfd_xxxTable_set_values                        xxx_interface.c
+   _xxxTable_set_column                         xxx_interface.c
+      yyy_set                                   xxx_data_set.c
+
+_mfd_xxxTable_check_dependencies                xxx_interface.c
+   xxxTable_check_dependencies                  xxx_data_set.c
+
+_mfd_xxxTable_commit                            xxx_interface.c
+   xxxTable_commit                              xxx_data_set.c
+
+_mfd_xxxTable_undo_cleanup                      xxx_interface.c
+   xxxTable_undo_cleanup                        xxx_data_set.c
+      xxxTable_release_data                     ...
+
+xxxTable_post_request                           ...
+
+
+SET Request: row creation
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request
+
+_mfd_xxxTable_object_lookup                     ...
+   xxxTable_index_from_oid                      xxx_interface.c
+   xxxTable_allocate_rowreq_ctx                 ...
+      ...
+   _xxxTable_check_indexes                      xxx_interface.c
+      yyy_check_index                           xxx_data_set.c
+      xxxTable_validate_index                   xxx_data_set.c
+
+_mfd_xxxTable_check_objects                     ...
+   _xxxTable_check_column                       ...
+      yyy_check_value                           ...
+   _xxxTable_check_column                       ...
+      yyy_check_value                           ...
+
+_mfd_xxxTable_undo_setup                        ...
+_mfd_xxxTable_set_values                        ...
+_mfd_xxxTable_check_dependencies                ...
+_mfd_xxxTable_commit                            ...
+_mfd_xxxTable_undo_cleanup                      ...
+xxxTable_post_request                           ...
+
+
+SET Resuest: value error
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request                            ...
+_mfd_xxxTable_object_lookup                     ...
+
+_mfd_xxxTable_check_objects                     ...
+   _xxxTable_check_column                       ...
+      yyy_check_value                           ...
+      ERROR:"yyy value not supported"
+
+xxxTable_post_request                           ...
+
+
+SET Request: commit failure
+--------------------------------
+_cache_load                                     ...
+xxxTable_pre_request                            ...
+_mfd_xxxTable_object_lookup                     ...
+_mfd_xxxTable_check_objects                     ...
+_mfd_xxxTable_undo_setup                        ...
+_mfd_xxxTable_set_values                        ...
+_mfd_xxxTable_check_dependencies                ...
+
+_mfd_xxxTable_commit                            ...
+   xxxTable_commit                              ...
+   ERROR: bad rc -1
+
+_mfd_xxxTable_undo_commit                       xxx_interface.c
+   xxxTable_undo_commit                         xxx_data_set.c
+
+_mfd_xxxTable_undo_values                       xxx_interface.c
+   _xxxTable_undo_column                        xxx_interface.c
+      yyy_undo                                  xxx_data_set.c
+
+_mfd_xxxTable_undo_cleanup                      ...
+xxxTable_post_request                           ...
+
+
+Row release (user initiated)
+--------------------------------
+xxxTable_release_rowreq_ctx                     xxx_interface.c
+   xxxTable_rowreq_ctx_cleanup                  xxx_data_get.c
+   xxxTable_release_data                        xxx_data_get.c
+
+
+
+Table / column details
+----------------------------------------------------
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreNodesTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreNodesTable is subid 2 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.2, length: 9
+*/
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreNodesEntry.lreNodesIndex
+ * lreNodesIndex is subid 1 of lreNodesEntry.
+ * Its status is Current, and its access level is NoAccess.
+ * OID: .1.0.62439.2.21.1.1.0.2.1.1
+ * Description:
+Unique value for each node in the LRE's node table.
+ *
+ * Attributes:
+ *   accessible 0     isscalar 0     enums  0      hasdefval 0
+ *   readable   0     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
+ * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
+ *
+ *
+ *
+ * NOTE: NODE lreNodesIndex IS NOT ACCESSIBLE
+ *
+ *
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreNodesEntry.lreNodesMacAddress
+ * lreNodesMacAddress is subid 2 of lreNodesEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.2.1.2
+ * Description:
+Each MAC address corresponds to a single Doubly Attached Node
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 1      hashint   1
+ *   settable   0
+ *   hint: 1x:
+ *
+ * Ranges:  6;
+ *
+ * Its syntax is MacAddress (based on perltype OCTETSTR)
+ * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
+ * This data type requires a length.  (Max 6)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreNodesEntry.lreTimeLastSeenA
+ * lreTimeLastSeenA is subid 3 of lreNodesEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.2.1.3
+ * Description:
+
+  Time in TimeTicks (1/100s) since the last frame from this
+  remote LRE was
+  received over LAN A. Initialized with a value of 0 upon node registration
+  in the node table.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is TICKS (based on perltype TICKS)
+ * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreNodesEntry.lreTimeLastSeenB
+ * lreTimeLastSeenB is subid 4 of lreNodesEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.2.1.4
+ * Description:
+
+  Time in TimeTicks (1/100s) since the last frame from this
+  remote LRE was
+  received over LAN B. Initialized with a value of 0 upon node registration
+  in the node table.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is TICKS (based on perltype TICKS)
+ * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
+ */
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreNodesEntry.lreRemNodeType
+ * lreRemNodeType is subid 5 of lreNodesEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.2.1.5
+ * Description:
+DAN type, as indicated in the received supervision frame
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ * Enum range: 5/8. Values:  danp(0), redboxp(1), vdanp(2), danh(3), redboxh(4), vdanh(5)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+
+
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable.c b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable.c
new file mode 100644
index 0000000..5c2b29d
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable.c
@@ -0,0 +1,202 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $ 
+ *
+ * $Id:$
+ */
+/** \page MFD helper for lreNodesTable
+ *
+ * \section intro Introduction
+ * Introductory text.
+ *
+ */
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreNodesTable.h"
+
+#include <net-snmp/agent/mib_modules.h>
+
+#include "lreNodesTable_interface.h"
+
+const oid lreNodesTable_oid[] = { LRENODESTABLE_OID };
+const int lreNodesTable_oid_size = OID_LENGTH(lreNodesTable_oid);
+
+    lreNodesTable_registration  lreNodesTable_user_context;
+
+void initialize_table_lreNodesTable(void);
+void shutdown_table_lreNodesTable(void);
+
+
+/**
+ * Initializes the lreNodesTable module
+ */
+void
+init_lreNodesTable(void)
+{
+    DEBUGMSGTL(("verbose:lreNodesTable:init_lreNodesTable","called\n"));
+
+    /*
+     * TODO:300:o: Perform lreNodesTable one-time module initialization.
+     */
+     
+    /*
+     * here we initialize all the tables we're planning on supporting
+     */
+    if (should_init("lreNodesTable"))
+        initialize_table_lreNodesTable();
+
+} /* init_lreNodesTable */
+
+/**
+ * Shut-down the lreNodesTable module (agent is exiting)
+ */
+void
+shutdown_lreNodesTable(void)
+{
+    if (should_init("lreNodesTable"))
+        shutdown_table_lreNodesTable();
+
+}
+
+/**
+ * Initialize the table lreNodesTable 
+ *    (Define its contents and how it's structured)
+ */
+void
+initialize_table_lreNodesTable(void)
+{
+    lreNodesTable_registration * user_context;
+    u_long flags;
+
+    DEBUGMSGTL(("verbose:lreNodesTable:initialize_table_lreNodesTable","called\n"));
+
+    /*
+     * TODO:301:o: Perform lreNodesTable one-time table initialization.
+     */
+
+    /*
+     * TODO:302:o: |->Initialize lreNodesTable user context
+     * if you'd like to pass in a pointer to some data for this
+     * table, allocate or set it up here.
+     */
+    /*
+     * a netsnmp_data_list is a simple way to store void pointers. A simple
+     * string token is used to add, find or remove pointers.
+     */
+    user_context = netsnmp_create_data_list("lreNodesTable", NULL, NULL);
+    
+    /*
+     * No support for any flags yet, but in the future you would
+     * set any flags here.
+     */
+    flags = 0;
+    
+    /*
+     * call interface initialization code
+     */
+    _lreNodesTable_initialize_interface(user_context, flags);
+} /* initialize_table_lreNodesTable */
+
+/**
+ * Shutdown the table lreNodesTable 
+ */
+void
+shutdown_table_lreNodesTable(void)
+{
+    /*
+     * call interface shutdown code
+     */
+    _lreNodesTable_shutdown_interface(&lreNodesTable_user_context);
+}
+
+/**
+ * extra context initialization (eg default values)
+ *
+ * @param rowreq_ctx    : row request context
+ * @param user_init_ctx : void pointer for user (parameter to rowreq_ctx_allocate)
+ *
+ * @retval MFD_SUCCESS  : no errors
+ * @retval MFD_ERROR    : error (context allocate will fail)
+ */
+int
+lreNodesTable_rowreq_ctx_init(lreNodesTable_rowreq_ctx *rowreq_ctx,
+                           void *user_init_ctx)
+{
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_rowreq_ctx_init","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+    
+    /*
+     * TODO:210:o: |-> Perform extra lreNodesTable rowreq initialization. (eg DEFVALS)
+     */
+
+    return MFD_SUCCESS;
+} /* lreNodesTable_rowreq_ctx_init */
+
+/**
+ * extra context cleanup
+ *
+ */
+void lreNodesTable_rowreq_ctx_cleanup(lreNodesTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_rowreq_ctx_cleanup","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+    
+    /*
+     * TODO:211:o: |-> Perform extra lreNodesTable rowreq cleanup.
+     */
+} /* lreNodesTable_rowreq_ctx_cleanup */
+
+/**
+ * pre-request callback
+ *
+ *
+ * @retval MFD_SUCCESS              : success.
+ * @retval MFD_ERROR                : other error
+ */
+int
+lreNodesTable_pre_request(lreNodesTable_registration * user_context)
+{
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_pre_request","called\n"));
+
+    /*
+     * TODO:510:o: Perform lreNodesTable pre-request actions.
+     */
+
+    return MFD_SUCCESS;
+} /* lreNodesTable_pre_request */
+
+/**
+ * post-request callback
+ *
+ * Note:
+ *   New rows have been inserted into the container, and
+ *   deleted rows have been removed from the container and
+ *   released.
+ *
+ * @param user_context
+ * @param rc : MFD_SUCCESS if all requests succeeded
+ *
+ * @retval MFD_SUCCESS : success.
+ * @retval MFD_ERROR   : other error (ignored)
+ */
+int
+lreNodesTable_post_request(lreNodesTable_registration * user_context, int rc)
+{
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_post_request","called\n"));
+
+    /*
+     * TODO:511:o: Perform lreNodesTable post-request actions.
+     */
+
+    return MFD_SUCCESS;
+} /* lreNodesTable_post_request */
+
+
+/** @{ */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable.h b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable.h
new file mode 100644
index 0000000..326e1a6
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable.h
@@ -0,0 +1,206 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+#ifndef LRENODESTABLE_H
+#define LRENODESTABLE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/** @addtogroup misc misc: Miscellaneous routines
+ *
+ * @{
+ */
+#include <net-snmp/library/asn1.h>
+
+/* other required module components */
+    /* *INDENT-OFF*  */
+config_add_mib(IEC-62439-3-MIB)
+config_require(IEC-62439-3-MIB/lreNodesTable/lreNodesTable_interface)
+config_require(IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_access)
+config_require(IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_get)
+config_require(IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_set)
+    /* *INDENT-ON*  */
+
+/* OID and column number definitions for lreNodesTable */
+#include "lreNodesTable_oids.h"
+
+/* enum definions */
+#include "lreNodesTable_enums.h"
+
+/* *********************************************************************
+ * function declarations
+ */
+void init_lreNodesTable(void);
+void shutdown_lreNodesTable(void);
+
+/* *********************************************************************
+ * Table declarations
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreNodesTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreNodesTable is subid 2 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.2, length: 9
+*/
+/* *********************************************************************
+ * When you register your mib, you get to provide a generic
+ * pointer that will be passed back to you for most of the
+ * functions calls.
+ *
+ * TODO:100:r: Review all context structures
+ */
+    /*
+     * TODO:101:o: |-> Review lreNodesTable registration context.
+     */
+typedef netsnmp_data_list lreNodesTable_registration;
+
+/**********************************************************************/
+/*
+ * TODO:110:r: |-> Review lreNodesTable data context structure.
+ * This structure is used to represent the data for lreNodesTable.
+ */
+/*
+ * This structure contains storage for all the columns defined in the
+ * lreNodesTable.
+ */
+typedef struct lreNodesTable_data_s {
+    
+        /*
+         * lreNodesMacAddress(2)/MacAddress/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/H
+         */
+   char   lreNodesMacAddress[6];
+size_t      lreNodesMacAddress_len; /* # of char elements, not bytes */
+    
+        /*
+         * lreTimeLastSeenA(3)/TICKS/ASN_TIMETICKS/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreTimeLastSeenA;
+    
+        /*
+         * lreTimeLastSeenB(4)/TICKS/ASN_TIMETICKS/u_long(u_long)//l/A/w/e/r/d/h
+         */
+   u_long   lreTimeLastSeenB;
+    
+        /*
+         * lreRemNodeType(5)/INTEGER/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h
+         */
+   u_long   lreRemNodeType;
+    
+} lreNodesTable_data;
+
+
+/*
+ * TODO:120:r: |-> Review lreNodesTable mib index.
+ * This structure is used to represent the index for lreNodesTable.
+ */
+typedef struct lreNodesTable_mib_index_s {
+
+        /*
+         * lreInterfaceStatsIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+         */
+   u_long   lreInterfaceStatsIndex;
+
+        /*
+         * lreNodesIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+         */
+   u_long   lreNodesIndex;
+
+
+} lreNodesTable_mib_index;
+
+    /*
+     * TODO:121:r: |   |-> Review lreNodesTable max index length.
+     * If you KNOW that your indexes will never exceed a certain
+     * length, update this macro to that length.
+*/
+#define MAX_lreNodesTable_IDX_LEN     2
+
+
+/* *********************************************************************
+ * TODO:130:o: |-> Review lreNodesTable Row request (rowreq) context.
+ * When your functions are called, you will be passed a
+ * lreNodesTable_rowreq_ctx pointer.
+ */
+typedef struct lreNodesTable_rowreq_ctx_s {
+
+    /** this must be first for container compare to work */
+    netsnmp_index        oid_idx;
+    oid                  oid_tmp[MAX_lreNodesTable_IDX_LEN];
+    
+    lreNodesTable_mib_index        tbl_idx;
+    
+    lreNodesTable_data              data;
+
+    /*
+     * flags per row. Currently, the first (lower) 8 bits are reserved
+     * for the user. See mfd.h for other flags.
+     */
+    u_int                       rowreq_flags;
+
+    /*
+     * TODO:131:o: |   |-> Add useful data to lreNodesTable rowreq context.
+     */
+    
+    /*
+     * storage for future expansion
+     */
+    netsnmp_data_list             *lreNodesTable_data_list;
+
+} lreNodesTable_rowreq_ctx;
+
+typedef struct lreNodesTable_ref_rowreq_ctx_s {
+    lreNodesTable_rowreq_ctx *rowreq_ctx;
+} lreNodesTable_ref_rowreq_ctx;
+
+/* *********************************************************************
+ * function prototypes
+ */
+    int lreNodesTable_pre_request(lreNodesTable_registration * user_context);
+    int lreNodesTable_post_request(lreNodesTable_registration * user_context,
+        int rc);
+
+    int lreNodesTable_rowreq_ctx_init(lreNodesTable_rowreq_ctx *rowreq_ctx,
+                                   void *user_init_ctx);
+    void lreNodesTable_rowreq_ctx_cleanup(lreNodesTable_rowreq_ctx *rowreq_ctx);
+
+
+    lreNodesTable_rowreq_ctx *
+                  lreNodesTable_row_find_by_mib_index(lreNodesTable_mib_index *mib_idx);
+
+extern const oid lreNodesTable_oid[];
+extern const int lreNodesTable_oid_size;
+
+
+#include "lreNodesTable_interface.h"
+#include "lreNodesTable_data_access.h"
+#include "lreNodesTable_data_get.h"
+#include "lreNodesTable_data_set.h"
+
+/*
+ * DUMMY markers, ignore
+ *
+ * TODO:099:x: *************************************************************
+ * TODO:199:x: *************************************************************
+ * TODO:299:x: *************************************************************
+ * TODO:399:x: *************************************************************
+ * TODO:499:x: *************************************************************
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LRENODESTABLE_H */
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_access.c b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_access.c
new file mode 100644
index 0000000..03e9163
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_access.c
@@ -0,0 +1,427 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $ 
+ *
+ * $Id:$
+ */
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreNodesTable.h"
+
+
+#include "lreNodesTable_data_access.h"
+
+/** @ingroup interface
+ * @addtogroup data_access data_access: Routines to access data
+ *
+ * These routines are used to locate the data used to satisfy
+ * requests.
+ * 
+ * @{
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreNodesTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreNodesTable is subid 2 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.2, length: 9
+*/
+
+/**
+ * initialization for lreNodesTable data access
+ *
+ * This function is called during startup to allow you to
+ * allocate any resources you need for the data table.
+ *
+ * @param lreNodesTable_reg
+ *        Pointer to lreNodesTable_registration
+ *
+ * @retval MFD_SUCCESS : success.
+ * @retval MFD_ERROR   : unrecoverable error.
+ */
+int
+lreNodesTable_init_data(lreNodesTable_registration * lreNodesTable_reg)
+{
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_init_data","called\n"));
+
+    /*
+     * TODO:303:o: Initialize lreNodesTable data.
+     */
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+    /*
+     * if you are the sole writer for the file, you could
+     * open it here. However, as stated earlier, we are assuming
+     * the worst case, which in this case means that the file is
+     * written to by someone else, and might not even exist when
+     * we start up. So we can't do anything here.
+     */
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+
+    return MFD_SUCCESS;
+} /* lreNodesTable_init_data */
+
+/**
+ * container overview
+ *
+ */
+
+/**
+ * container initialization
+ *
+ * @param container_ptr_ptr A pointer to a container pointer. If you
+ *        create a custom container, use this parameter to return it
+ *        to the MFD helper. If set to NULL, the MFD helper will
+ *        allocate a container for you.
+ * @param  cache A pointer to a cache structure. You can set the timeout
+ *         and other cache flags using this pointer.
+ *
+ *  This function is called at startup to allow you to customize certain
+ *  aspects of the access method. For the most part, it is for advanced
+ *  users. The default code should suffice for most cases. If no custom
+ *  container is allocated, the MFD code will create one for your.
+ *
+ *  This is also the place to set up cache behavior. The default, to
+ *  simply set the cache timeout, will work well with the default
+ *  container. If you are using a custom container, you may want to
+ *  look at the cache helper documentation to see if there are any
+ *  flags you want to set.
+ *
+ * @remark
+ *  This would also be a good place to do any initialization needed
+ *  for you data source. For example, opening a connection to another
+ *  process that will supply the data, opening a database, etc.
+ */
+void
+lreNodesTable_container_init(netsnmp_container **container_ptr_ptr,
+                             netsnmp_cache *cache)
+{
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_container_init","called\n"));
+    
+    if (NULL == container_ptr_ptr) {
+        snmp_log(LOG_ERR,"bad container param to lreNodesTable_container_init\n");
+        return;
+    }
+
+    /*
+     * For advanced users, you can use a custom container. If you
+     * do not create one, one will be created for you.
+     */
+    *container_ptr_ptr = NULL;
+
+    if (NULL == cache) {
+        snmp_log(LOG_ERR,"bad cache param to lreNodesTable_container_init\n");
+        return;
+    }
+
+    /*
+     * TODO:345:A: Set up lreNodesTable cache properties.
+     *
+     * Also for advanced users, you can set parameters for the
+     * cache. Do not change the magic pointer, as it is used
+     * by the MFD helper. To completely disable caching, set
+     * cache->enabled to 0.
+     */
+    cache->timeout = LRENODESTABLE_CACHE_TIMEOUT; /* seconds */
+} /* lreNodesTable_container_init */
+
+/**
+ * container shutdown
+ *
+ * @param container_ptr A pointer to the container.
+ *
+ *  This function is called at shutdown to allow you to customize certain
+ *  aspects of the access method. For the most part, it is for advanced
+ *  users. The default code should suffice for most cases.
+ *
+ *  This function is called before lreNodesTable_container_free().
+ *
+ * @remark
+ *  This would also be a good place to do any cleanup needed
+ *  for you data source. For example, closing a connection to another
+ *  process that supplied the data, closing a database, etc.
+ */
+void
+lreNodesTable_container_shutdown(netsnmp_container *container_ptr)
+{
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_container_shutdown","called\n"));
+    
+    if (NULL == container_ptr) {
+        snmp_log(LOG_ERR,"bad params to lreNodesTable_container_shutdown\n");
+        return;
+    }
+
+} /* lreNodesTable_container_shutdown */
+
+/**
+ * load initial data
+ *
+ * TODO:350:M: Implement lreNodesTable data load
+ * This function will also be called by the cache helper to load
+ * the container again (after the container free function has been
+ * called to free the previous contents).
+ *
+ * @param container container to which items should be inserted
+ *
+ * @retval MFD_SUCCESS              : success.
+ * @retval MFD_RESOURCE_UNAVAILABLE : Can't access data source
+ * @retval MFD_ERROR                : other error.
+ *
+ *  This function is called to load the index(es) (and data, optionally)
+ *  for the every row in the data set.
+ *
+ * @remark
+ *  While loading the data, the only important thing is the indexes.
+ *  If access to your data is cheap/fast (e.g. you have a pointer to a
+ *  structure in memory), it would make sense to update the data here.
+ *  If, however, the accessing the data invovles more work (e.g. parsing
+ *  some other existing data, or peforming calculations to derive the data),
+ *  then you can limit yourself to setting the indexes and saving any
+ *  information you will need later. Then use the saved information in
+ *  lreNodesTable_row_prep() for populating data.
+ *
+ * @note
+ *  If you need consistency between rows (like you want statistics
+ *  for each row to be from the same time frame), you should set all
+ *  data here.
+ *
+ */
+int
+lreNodesTable_container_load(netsnmp_container *container)
+{
+    lreNodesTable_rowreq_ctx *rowreq_ctx;
+    size_t                 count = 0;
+
+    /*
+     * temporary storage for index values
+     */
+        /*
+         * lreInterfaceStatsIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+         */
+   u_long   lreInterfaceStatsIndex;
+        /*
+         * lreNodesIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+         */
+   u_long   lreNodesIndex;
+
+    
+    /*
+     * this example code is based on a data source that is a
+     * text file to be read and parsed.
+     */
+    FILE *filep;
+    char line[MAX_LINE_SIZE];
+
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_container_load","called\n"));
+
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+    /*
+     * open our data file.
+     */
+    filep = fopen("/etc/dummy.conf", "r");
+    if(NULL ==  filep) {
+        return MFD_RESOURCE_UNAVAILABLE;
+    }
+
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+    /*
+     * TODO:351:M: |-> Load/update data in the lreNodesTable container.
+     * loop over your lreNodesTable data, allocate a rowreq context,
+     * set the index(es) [and data, optionally] and insert into
+     * the container.
+     */
+    while( 1 ) {
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+    /*
+     * get a line (skip blank lines)
+     */
+    do {
+        if (!fgets(line, sizeof(line), filep)) {
+            /* we're done */
+            fclose(filep);
+            filep = NULL;
+        }
+    } while (filep && (line[0] == '\n'));
+
+    /*
+     * check for end of data
+     */
+    if(NULL == filep)
+        break;
+
+    /*
+     * parse line into variables
+     */
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+
+        /*
+         * TODO:352:M: |   |-> set indexes in new lreNodesTable rowreq context.
+         * data context will be set from the param (unless NULL,
+         *      in which case a new data context will be allocated)
+         */
+        rowreq_ctx = lreNodesTable_allocate_rowreq_ctx(NULL);
+        if (NULL == rowreq_ctx) {
+            snmp_log(LOG_ERR, "memory allocation failed\n");
+            return MFD_RESOURCE_UNAVAILABLE;
+        }
+        if(MFD_SUCCESS != lreNodesTable_indexes_set(rowreq_ctx
+                               , lreInterfaceStatsIndex
+                               , lreNodesIndex
+               )) {
+            snmp_log(LOG_ERR,"error setting index while loading "
+                     "lreNodesTable data.\n");
+            lreNodesTable_release_rowreq_ctx(rowreq_ctx);
+            continue;
+        }
+
+        /*
+         * TODO:352:r: |   |-> populate lreNodesTable data context.
+         * Populate data context here. (optionally, delay until row prep)
+         */
+    /*
+     * TRANSIENT or semi-TRANSIENT data:
+     * copy data or save any info needed to do it in row_prep.
+     */
+    /*
+     * setup/save data for lreNodesMacAddress
+     * lreNodesMacAddress(2)/MacAddress/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/H
+     */
+    /** no mapping */
+    /*
+     * make sure there is enough space for lreNodesMacAddress data
+     */
+    if ((NULL == rowreq_ctx->data.lreNodesMacAddress) ||
+        (rowreq_ctx->data.lreNodesMacAddress_len <
+         (lreNodesMacAddress_len* sizeof(lreNodesMacAddress[0])))) {
+        snmp_log(LOG_ERR,"not enough space for value (lreNodesMacAddress)\n");
+        return MFD_ERROR;
+    }
+    rowreq_ctx->data.lreNodesMacAddress_len = lreNodesMacAddress_len* sizeof(lreNodesMacAddress[0]);
+    memcpy( rowreq_ctx->data.lreNodesMacAddress, lreNodesMacAddress, lreNodesMacAddress_len* sizeof(lreNodesMacAddress[0]) );
+    
+    /*
+     * setup/save data for lreTimeLastSeenA
+     * lreTimeLastSeenA(3)/TICKS/ASN_TIMETICKS/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreTimeLastSeenA = lreTimeLastSeenA;
+    
+    /*
+     * setup/save data for lreTimeLastSeenB
+     * lreTimeLastSeenB(4)/TICKS/ASN_TIMETICKS/u_long(u_long)//l/A/w/e/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreTimeLastSeenB = lreTimeLastSeenB;
+    
+    /*
+     * setup/save data for lreRemNodeType
+     * lreRemNodeType(5)/INTEGER/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h
+     */
+    /** no mapping */
+    rowreq_ctx->data.lreRemNodeType = lreRemNodeType;
+    
+        
+        /*
+         * insert into table container
+         */
+        CONTAINER_INSERT(container, rowreq_ctx);
+        ++count;
+    }
+
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+    if(NULL != filep)
+        fclose(filep);
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+
+    DEBUGMSGT(("verbose:lreNodesTable:lreNodesTable_container_load",
+               "inserted %d records\n", count));
+
+    return MFD_SUCCESS;
+} /* lreNodesTable_container_load */
+
+/**
+ * container clean up
+ *
+ * @param container container with all current items
+ *
+ *  This optional callback is called prior to all
+ *  item's being removed from the container. If you
+ *  need to do any processing before that, do it here.
+ *
+ * @note
+ *  The MFD helper will take care of releasing all the row contexts.
+ *
+ */
+void
+lreNodesTable_container_free(netsnmp_container *container)
+{
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_container_free","called\n"));
+
+    /*
+     * TODO:380:M: Free lreNodesTable container data.
+     */
+} /* lreNodesTable_container_free */
+
+/**
+ * prepare row for processing.
+ *
+ *  When the agent has located the row for a request, this function is
+ *  called to prepare the row for processing. If you fully populated
+ *  the data context during the index setup phase, you may not need to
+ *  do anything.
+ *
+ * @param rowreq_ctx pointer to a context.
+ *
+ * @retval MFD_SUCCESS     : success.
+ * @retval MFD_ERROR       : other error.
+ */
+int
+lreNodesTable_row_prep( lreNodesTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_row_prep","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    /*
+     * TODO:390:o: Prepare row for request.
+     * If populating row data was delayed, this is the place to
+     * fill in the row for this request.
+     */
+
+    return MFD_SUCCESS;
+} /* lreNodesTable_row_prep */
+
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_access.h b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_access.h
new file mode 100644
index 0000000..9d9eb76
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_access.h
@@ -0,0 +1,76 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+#ifndef LRENODESTABLE_DATA_ACCESS_H
+#define LRENODESTABLE_DATA_ACCESS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* *********************************************************************
+ * function declarations
+ */
+
+/* *********************************************************************
+ * Table declarations
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreNodesTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreNodesTable is subid 2 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.2, length: 9
+*/
+
+
+    int lreNodesTable_init_data(lreNodesTable_registration * lreNodesTable_reg);
+
+
+    /*
+     * TODO:180:o: Review lreNodesTable cache timeout.
+     * The number of seconds before the cache times out
+     */
+#define LRENODESTABLE_CACHE_TIMEOUT   60
+
+void lreNodesTable_container_init(netsnmp_container **container_ptr_ptr,
+                             netsnmp_cache *cache);
+void lreNodesTable_container_shutdown(netsnmp_container *container_ptr);
+
+int lreNodesTable_container_load(netsnmp_container *container);
+void lreNodesTable_container_free(netsnmp_container *container);
+
+int lreNodesTable_cache_load(netsnmp_container *container);
+void lreNodesTable_cache_free(netsnmp_container *container);
+
+    /*
+    ***************************************************
+    ***             START EXAMPLE CODE              ***
+    ***---------------------------------------------***/
+/* *********************************************************************
+ * Since we have no idea how you really access your data, we'll go with
+ * a worst case example: a flat text file.
+ */
+#define MAX_LINE_SIZE 256
+    /*
+    ***---------------------------------------------***
+    ***              END  EXAMPLE CODE              ***
+    ***************************************************/
+    int lreNodesTable_row_prep( lreNodesTable_rowreq_ctx *rowreq_ctx);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LRENODESTABLE_DATA_ACCESS_H */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_get.c b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_get.c
new file mode 100644
index 0000000..c56cbcc
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_get.c
@@ -0,0 +1,364 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $ 
+ *
+ * $Id:$
+ */
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreNodesTable.h"
+
+
+/** @defgroup data_get data_get: Routines to get data
+ *
+ * TODO:230:M: Implement lreNodesTable get routines.
+ * TODO:240:M: Implement lreNodesTable mapping routines (if any).
+ *
+ * These routine are used to get the value for individual objects. The
+ * row context is passed, along with a pointer to the memory where the
+ * value should be copied.
+ *
+ * @{
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreNodesTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreNodesTable is subid 2 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.2, length: 9
+*/
+
+/* ---------------------------------------------------------------------
+ * TODO:200:r: Implement lreNodesTable data context functions.
+ */
+
+
+/**
+ * set mib index(es)
+ *
+ * @param tbl_idx mib index structure
+ * @param lreInterfaceStatsIndex_val
+ * @param lreNodesIndex_val
+ *
+ * @retval MFD_SUCCESS     : success.
+ * @retval MFD_ERROR       : other error.
+ *
+ * @remark
+ *  This convenience function is useful for setting all the MIB index
+ *  components with a single function call. It is assume that the C values
+ *  have already been mapped from their native/rawformat to the MIB format.
+ */
+int
+lreNodesTable_indexes_set_tbl_idx(lreNodesTable_mib_index *tbl_idx, u_long lreInterfaceStatsIndex_val, u_long lreNodesIndex_val)
+{
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_indexes_set_tbl_idx","called\n"));
+
+    /* lreInterfaceStatsIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h */
+    tbl_idx->lreInterfaceStatsIndex = lreInterfaceStatsIndex_val;
+    
+    /* lreNodesIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h */
+    tbl_idx->lreNodesIndex = lreNodesIndex_val;
+    
+
+    return MFD_SUCCESS;
+} /* lreNodesTable_indexes_set_tbl_idx */
+
+/**
+ * @internal
+ * set row context indexes
+ *
+ * @param reqreq_ctx the row context that needs updated indexes
+ *
+ * @retval MFD_SUCCESS     : success.
+ * @retval MFD_ERROR       : other error.
+ *
+ * @remark
+ *  This function sets the mib indexs, then updates the oid indexs
+ *  from the mib index.
+ */
+int
+lreNodesTable_indexes_set(lreNodesTable_rowreq_ctx *rowreq_ctx, u_long lreInterfaceStatsIndex_val, u_long lreNodesIndex_val)
+{
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_indexes_set","called\n"));
+
+    if(MFD_SUCCESS != lreNodesTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
+                                   , lreInterfaceStatsIndex_val
+                                   , lreNodesIndex_val
+           ))
+        return MFD_ERROR;
+
+    /*
+     * convert mib index to oid index
+     */
+    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
+    if(0 != lreNodesTable_index_to_oid(&rowreq_ctx->oid_idx,
+                                    &rowreq_ctx->tbl_idx)) {
+        return MFD_ERROR;
+    }
+
+    return MFD_SUCCESS;
+} /* lreNodesTable_indexes_set */
+
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreNodesEntry.lreNodesMacAddress
+ * lreNodesMacAddress is subid 2 of lreNodesEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.2.1.2
+ * Description:
+Each MAC address corresponds to a single Doubly Attached Node
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 1      hashint   1
+ *   settable   0
+ *   hint: 1x:
+ *
+ * Ranges:  6;
+ *
+ * Its syntax is MacAddress (based on perltype OCTETSTR)
+ * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
+ * This data type requires a length.  (Max 6)
+ */
+/**
+ * Extract the current value of the lreNodesMacAddress data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreNodesMacAddress_val_ptr_ptr
+ *        Pointer to storage for a char variable
+ * @param lreNodesMacAddress_val_ptr_len_ptr
+ *        Pointer to a size_t. On entry, it will contain the size (in bytes)
+ *        pointed to by lreNodesMacAddress.
+ *        On exit, this value should contain the data size (in bytes).
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+*
+ * @note If you need more than (*lreNodesMacAddress_val_ptr_len_ptr) bytes of memory,
+ *       allocate it using malloc() and update lreNodesMacAddress_val_ptr_ptr.
+ *       <b>DO NOT</b> free the previous pointer.
+ *       The MFD helper will release the memory you allocate.
+ *
+ * @remark If you call this function yourself, you are responsible
+ *         for checking if the pointer changed, and freeing any
+ *         previously allocated memory. (Not necessary if you pass
+ *         in a pointer to static memory, obviously.)
+ */
+int
+lreNodesMacAddress_get( lreNodesTable_rowreq_ctx *rowreq_ctx, char **lreNodesMacAddress_val_ptr_ptr, size_t *lreNodesMacAddress_val_ptr_len_ptr )
+{
+   /** we should have a non-NULL pointer and enough storage */
+   netsnmp_assert( (NULL != lreNodesMacAddress_val_ptr_ptr) && (NULL != *lreNodesMacAddress_val_ptr_ptr));
+   netsnmp_assert( NULL != lreNodesMacAddress_val_ptr_len_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesMacAddress_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreNodesMacAddress data.
+ * copy (* lreNodesMacAddress_val_ptr_ptr ) data and (* lreNodesMacAddress_val_ptr_len_ptr ) from rowreq_ctx->data
+ */
+    /*
+     * make sure there is enough space for lreNodesMacAddress data
+     */
+    if ((NULL == (* lreNodesMacAddress_val_ptr_ptr )) ||
+        ((* lreNodesMacAddress_val_ptr_len_ptr ) <
+         (rowreq_ctx->data.lreNodesMacAddress_len* sizeof(rowreq_ctx->data.lreNodesMacAddress[0])))) {
+        /*
+         * allocate space for lreNodesMacAddress data
+         */
+        (* lreNodesMacAddress_val_ptr_ptr ) = malloc(rowreq_ctx->data.lreNodesMacAddress_len* sizeof(rowreq_ctx->data.lreNodesMacAddress[0]));
+        if(NULL == (* lreNodesMacAddress_val_ptr_ptr )) {
+            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.lreNodesMacAddress)\n");
+            return MFD_ERROR;
+        }
+    }
+    (* lreNodesMacAddress_val_ptr_len_ptr ) = rowreq_ctx->data.lreNodesMacAddress_len* sizeof(rowreq_ctx->data.lreNodesMacAddress[0]);
+    memcpy( (* lreNodesMacAddress_val_ptr_ptr ), rowreq_ctx->data.lreNodesMacAddress, rowreq_ctx->data.lreNodesMacAddress_len* sizeof(rowreq_ctx->data.lreNodesMacAddress[0]) );
+
+    return MFD_SUCCESS;
+} /* lreNodesMacAddress_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreNodesEntry.lreTimeLastSeenA
+ * lreTimeLastSeenA is subid 3 of lreNodesEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.2.1.3
+ * Description:
+
+  Time in TimeTicks (1/100s) since the last frame from this
+  remote LRE was
+  received over LAN A. Initialized with a value of 0 upon node registration
+  in the node table.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is TICKS (based on perltype TICKS)
+ * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreTimeLastSeenA data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreTimeLastSeenA_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreTimeLastSeenA_get( lreNodesTable_rowreq_ctx *rowreq_ctx, u_long * lreTimeLastSeenA_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreTimeLastSeenA_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreNodesTable:lreTimeLastSeenA_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreTimeLastSeenA data.
+ * copy (* lreTimeLastSeenA_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreTimeLastSeenA_val_ptr ) = rowreq_ctx->data.lreTimeLastSeenA;
+
+    return MFD_SUCCESS;
+} /* lreTimeLastSeenA_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreNodesEntry.lreTimeLastSeenB
+ * lreTimeLastSeenB is subid 4 of lreNodesEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.2.1.4
+ * Description:
+
+  Time in TimeTicks (1/100s) since the last frame from this
+  remote LRE was
+  received over LAN B. Initialized with a value of 0 upon node registration
+  in the node table.
+  
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  0      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ *
+ * Its syntax is TICKS (based on perltype TICKS)
+ * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
+ */
+/**
+ * Extract the current value of the lreTimeLastSeenB data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreTimeLastSeenB_val_ptr
+ *        Pointer to storage for a u_long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreTimeLastSeenB_get( lreNodesTable_rowreq_ctx *rowreq_ctx, u_long * lreTimeLastSeenB_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreTimeLastSeenB_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreNodesTable:lreTimeLastSeenB_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreTimeLastSeenB data.
+ * copy (* lreTimeLastSeenB_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreTimeLastSeenB_val_ptr ) = rowreq_ctx->data.lreTimeLastSeenB;
+
+    return MFD_SUCCESS;
+} /* lreTimeLastSeenB_get */
+
+/*---------------------------------------------------------------------
+ * IEC-62439-3-MIB::lreNodesEntry.lreRemNodeType
+ * lreRemNodeType is subid 5 of lreNodesEntry.
+ * Its status is Current, and its access level is ReadOnly.
+ * OID: .1.0.62439.2.21.1.1.0.2.1.5
+ * Description:
+DAN type, as indicated in the received supervision frame
+ *
+ * Attributes:
+ *   accessible 1     isscalar 0     enums  1      hasdefval 0
+ *   readable   1     iscolumn 1     ranges 0      hashint   0
+ *   settable   0
+ *
+ * Enum range: 5/8. Values:  danp(0), redboxp(1), vdanp(2), danh(3), redboxh(4), vdanh(5)
+ *
+ * Its syntax is INTEGER (based on perltype INTEGER)
+ * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
+ */
+/**
+ * Extract the current value of the lreRemNodeType data.
+ *
+ * Set a value using the data context for the row.
+ *
+ * @param rowreq_ctx
+ *        Pointer to the row request context.
+ * @param lreRemNodeType_val_ptr
+ *        Pointer to storage for a long variable
+ *
+ * @retval MFD_SUCCESS         : success
+ * @retval MFD_SKIP            : skip this node (no value for now)
+ * @retval MFD_ERROR           : Any other error
+ */
+int
+lreRemNodeType_get( lreNodesTable_rowreq_ctx *rowreq_ctx, u_long * lreRemNodeType_val_ptr )
+{
+   /** we should have a non-NULL pointer */
+   netsnmp_assert( NULL != lreRemNodeType_val_ptr );
+
+
+    DEBUGMSGTL(("verbose:lreNodesTable:lreRemNodeType_get","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+/*
+ * TODO:231:o: |-> Extract the current value of the lreRemNodeType data.
+ * copy (* lreRemNodeType_val_ptr ) from rowreq_ctx->data
+ */
+    (* lreRemNodeType_val_ptr ) = rowreq_ctx->data.lreRemNodeType;
+
+    return MFD_SUCCESS;
+} /* lreRemNodeType_get */
+
+
+
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_get.h b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_get.h
new file mode 100644
index 0000000..35bc34f
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_get.h
@@ -0,0 +1,62 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ *
+ * @file lreNodesTable_data_get.h
+ *
+ * @addtogroup get
+ *
+ * Prototypes for get functions
+ *
+ * @{
+ */
+#ifndef LRENODESTABLE_DATA_GET_H
+#define LRENODESTABLE_DATA_GET_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* *********************************************************************
+ * GET function declarations
+ */
+
+/* *********************************************************************
+ * GET Table declarations
+ */
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreNodesTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreNodesTable is subid 2 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.2, length: 9
+*/
+    /*
+     * indexes
+     */
+
+    int lreNodesMacAddress_get( lreNodesTable_rowreq_ctx *rowreq_ctx, char **lreNodesMacAddress_val_ptr_ptr, size_t *lreNodesMacAddress_val_ptr_len_ptr );
+    int lreTimeLastSeenA_get( lreNodesTable_rowreq_ctx *rowreq_ctx, u_long * lreTimeLastSeenA_val_ptr );
+    int lreTimeLastSeenB_get( lreNodesTable_rowreq_ctx *rowreq_ctx, u_long * lreTimeLastSeenB_val_ptr );
+    int lreRemNodeType_get( lreNodesTable_rowreq_ctx *rowreq_ctx, u_long * lreRemNodeType_val_ptr );
+
+
+int lreNodesTable_indexes_set_tbl_idx(lreNodesTable_mib_index *tbl_idx, u_long lreInterfaceStatsIndex_val, u_long lreNodesIndex_val);
+int lreNodesTable_indexes_set(lreNodesTable_rowreq_ctx *rowreq_ctx, u_long lreInterfaceStatsIndex_val, u_long lreNodesIndex_val);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LRENODESTABLE_DATA_GET_H */
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_set.c b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_set.c
new file mode 100644
index 0000000..26dc8f9
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_set.c
@@ -0,0 +1,25 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ *
+ */
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreNodesTable.h"
+
+
+/** @defgroup data_set data_set: Routines to set data
+ *
+ * These routines are used to set the value for individual objects. The
+ * row context is passed, along with the new value.
+ * 
+ * @{
+ */
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_set.h b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_set.h
new file mode 100644
index 0000000..2b4005d
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_data_set.h
@@ -0,0 +1,27 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $ 
+ *
+ * $Id:$
+ */
+#ifndef LRENODESTABLE_DATA_SET_H
+#define LRENODESTABLE_DATA_SET_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* *********************************************************************
+ * SET function declarations
+ */
+
+/* *********************************************************************
+ * SET Table declarations
+ */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LRENODESTABLE_DATA_SET_H */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_enums.h b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_enums.h
new file mode 100644
index 0000000..c880b6e
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_enums.h
@@ -0,0 +1,60 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  $
+ *
+ * $Id:$
+ */
+#ifndef LRENODESTABLE_ENUMS_H
+#define LRENODESTABLE_ENUMS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+ /*
+ * NOTES on enums
+ * ==============
+ *
+ * Value Mapping
+ * -------------
+ * If the values for your data type don't exactly match the
+ * possible values defined by the mib, you should map them
+ * below. For example, a boolean flag (1/0) is usually represented
+ * as a TruthValue in a MIB, which maps to the values (1/2).
+ *
+ */
+/*************************************************************************
+ *************************************************************************
+ *
+ * enum definitions for table lreNodesTable
+ *
+ *************************************************************************
+ *************************************************************************/
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * lreRemNodeType (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef LREREMNODETYPE_ENUMS
+#define LREREMNODETYPE_ENUMS
+
+#define LREREMNODETYPE_DANP  0 
+#define LREREMNODETYPE_REDBOXP  1 
+#define LREREMNODETYPE_VDANP  2 
+#define LREREMNODETYPE_DANH  3 
+#define LREREMNODETYPE_REDBOXH  4 
+#define LREREMNODETYPE_VDANH  5 
+
+#endif /* LREREMNODETYPE_ENUMS */
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LRENODESTABLE_ENUMS_H */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_interface.c b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_interface.c
new file mode 100644
index 0000000..3a61fd7
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_interface.c
@@ -0,0 +1,903 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $ 
+ *
+ * $Id:$
+ */
+/*
+ * *********************************************************************
+ * *********************************************************************
+ * *********************************************************************
+ * ***                                                               ***
+ * ***  NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE  ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***       THIS FILE DOES NOT CONTAIN ANY USER EDITABLE CODE.      ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***       THE GENERATED CODE IS INTERNAL IMPLEMENTATION, AND      ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***    IS SUBJECT TO CHANGE WITHOUT WARNING IN FUTURE RELEASES.   ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * *********************************************************************
+ * *********************************************************************
+ * *********************************************************************
+ */
+
+/* standard Net-SNMP includes */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-features.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/* include our parent header */
+#include "lreNodesTable.h"
+
+
+#include <net-snmp/agent/table_container.h>
+#include <net-snmp/library/container.h>
+
+#include "lreNodesTable_interface.h"
+
+netsnmp_feature_require(baby_steps)
+netsnmp_feature_require(row_merge)
+netsnmp_feature_require(check_all_requests_error)
+
+#include <ctype.h>
+
+/**********************************************************************
+ **********************************************************************
+ ***
+ *** Table lreNodesTable
+ ***
+ **********************************************************************
+ **********************************************************************/
+/*
+ * IEC-62439-3-MIB::lreNodesTable is subid 2 of lreStatisticsInterfaces.
+ * Its status is Current.
+ * OID: .1.0.62439.2.21.1.1.0.2, length: 9
+*/
+typedef struct lreNodesTable_interface_ctx_s {
+
+   netsnmp_container              *container;
+   netsnmp_cache                  *cache;
+
+   lreNodesTable_registration *      user_ctx;
+   
+   netsnmp_table_registration_info  tbl_info;
+
+   netsnmp_baby_steps_access_methods access_multiplexer;
+
+} lreNodesTable_interface_ctx;
+
+static lreNodesTable_interface_ctx lreNodesTable_if_ctx;
+
+static void _lreNodesTable_container_init(
+    lreNodesTable_interface_ctx *if_ctx);
+static void _lreNodesTable_container_shutdown(
+    lreNodesTable_interface_ctx *if_ctx);
+
+
+netsnmp_container *
+lreNodesTable_container_get( void )
+{
+    return lreNodesTable_if_ctx.container;
+}
+
+lreNodesTable_registration *
+lreNodesTable_registration_get( void )
+{
+    return lreNodesTable_if_ctx.user_ctx;
+}
+
+lreNodesTable_registration *
+lreNodesTable_registration_set( lreNodesTable_registration * newreg )
+{
+    lreNodesTable_registration * old = lreNodesTable_if_ctx.user_ctx;
+    lreNodesTable_if_ctx.user_ctx = newreg;
+    return old;
+}
+
+int
+lreNodesTable_container_size( void )
+{
+    return CONTAINER_SIZE(lreNodesTable_if_ctx.container);
+}
+
+/*
+ * mfd multiplexer modes
+ */
+static Netsnmp_Node_Handler _mfd_lreNodesTable_pre_request;
+static Netsnmp_Node_Handler _mfd_lreNodesTable_post_request;
+static Netsnmp_Node_Handler _mfd_lreNodesTable_object_lookup;
+static Netsnmp_Node_Handler _mfd_lreNodesTable_get_values;
+/**
+ * @internal
+ * Initialize the table lreNodesTable 
+ *    (Define its contents and how it's structured)
+ */
+void
+_lreNodesTable_initialize_interface(lreNodesTable_registration * reg_ptr,  u_long flags)
+{
+    netsnmp_baby_steps_access_methods *access_multiplexer =
+        &lreNodesTable_if_ctx.access_multiplexer;
+    netsnmp_table_registration_info *tbl_info = &lreNodesTable_if_ctx.tbl_info;
+    netsnmp_handler_registration *reginfo;
+    netsnmp_mib_handler *handler;
+    int    mfd_modes = 0;
+
+    DEBUGMSGTL(("internal:lreNodesTable:_lreNodesTable_initialize_interface","called\n"));
+
+
+    /*************************************************
+     *
+     * save interface context for lreNodesTable
+     */
+    /*
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(tbl_info,
+                                  ASN_UNSIGNED, /** index: lreInterfaceStatsIndex */
+                                  ASN_UNSIGNED, /** index: lreNodesIndex */
+                             0);
+
+    /*  Define the minimum and maximum accessible columns.  This
+        optimizes retrieval. */
+    tbl_info->min_column = LRENODESTABLE_MIN_COL;
+    tbl_info->max_column = LRENODESTABLE_MAX_COL;
+
+    /*
+     * save users context
+     */
+    lreNodesTable_if_ctx.user_ctx = reg_ptr;
+
+    /*
+     * call data access initialization code
+     */
+    lreNodesTable_init_data(reg_ptr);
+
+    /*
+     * set up the container
+     */
+    _lreNodesTable_container_init(&lreNodesTable_if_ctx);
+    if (NULL == lreNodesTable_if_ctx.container) {
+        snmp_log(LOG_ERR,"could not initialize container for lreNodesTable\n");
+        return;
+    }
+    
+    /*
+     * access_multiplexer: REQUIRED wrapper for get request handling
+     */
+    access_multiplexer->object_lookup = _mfd_lreNodesTable_object_lookup;
+    access_multiplexer->get_values = _mfd_lreNodesTable_get_values;
+
+    /*
+     * no wrappers yet
+     */
+    access_multiplexer->pre_request = _mfd_lreNodesTable_pre_request;
+    access_multiplexer->post_request = _mfd_lreNodesTable_post_request;
+
+#ifndef NETSNMP_DISABLE_SET_SUPPORT
+#endif
+
+    /*************************************************
+     *
+     * Create a registration, save our reg data, register table.
+     */
+    DEBUGMSGTL(("lreNodesTable:init_lreNodesTable",
+                "Registering lreNodesTable as a mibs-for-dummies table.\n"));		 
+    handler = netsnmp_baby_steps_access_multiplexer_get(access_multiplexer);
+    reginfo = netsnmp_handler_registration_create("lreNodesTable", handler,
+                                                  lreNodesTable_oid,
+                                                  lreNodesTable_oid_size,
+                                                  HANDLER_CAN_BABY_STEP |
+#if !(defined(NETSNMP_NO_WRITE_SUPPORT) || defined(NETSNMP_DISABLE_SET_SUPPORT))
+                                                  HANDLER_CAN_RONLY
+#else
+                                                  HANDLER_CAN_RONLY
+#endif /* NETSNMP_NO_WRITE_SUPPORT || NETSNMP_DISABLE_SET_SUPPORT */
+                                                  );
+    if(NULL == reginfo) {
+        snmp_log(LOG_ERR,"error registering table lreNodesTable\n");
+        return;
+    }
+    reginfo->my_reg_void = &lreNodesTable_if_ctx;
+
+    /*************************************************
+     *
+     * set up baby steps handler, create it and inject it
+     */
+    if( access_multiplexer->object_lookup )
+        mfd_modes |= BABY_STEP_OBJECT_LOOKUP;
+    if( access_multiplexer->pre_request )
+        mfd_modes |= BABY_STEP_PRE_REQUEST;
+    if( access_multiplexer->post_request )
+        mfd_modes |= BABY_STEP_POST_REQUEST;
+    
+#if !(defined(NETSNMP_NO_WRITE_SUPPORT) || defined(NETSNMP_DISABLE_SET_SUPPORT))
+    if( access_multiplexer->set_values )
+        mfd_modes |= BABY_STEP_SET_VALUES;
+    if( access_multiplexer->irreversible_commit )
+        mfd_modes |= BABY_STEP_IRREVERSIBLE_COMMIT;
+    if( access_multiplexer->object_syntax_checks )
+        mfd_modes |= BABY_STEP_CHECK_OBJECT;
+
+    if( access_multiplexer->undo_setup )
+        mfd_modes |= BABY_STEP_UNDO_SETUP;
+    if( access_multiplexer->undo_cleanup )
+        mfd_modes |= BABY_STEP_UNDO_CLEANUP;
+    if( access_multiplexer->undo_sets )
+        mfd_modes |= BABY_STEP_UNDO_SETS;
+    
+    if( access_multiplexer->row_creation )
+        mfd_modes |= BABY_STEP_ROW_CREATE;
+    if( access_multiplexer->consistency_checks )
+        mfd_modes |= BABY_STEP_CHECK_CONSISTENCY;
+    if( access_multiplexer->commit )
+        mfd_modes |= BABY_STEP_COMMIT;
+    if( access_multiplexer->undo_commit )
+        mfd_modes |= BABY_STEP_UNDO_COMMIT;
+#endif /* NETSNMP_NO_WRITE_SUPPORT || NETSNMP_DISABLE_SET_SUPPORT */
+    
+    handler = netsnmp_baby_steps_handler_get(mfd_modes);
+    netsnmp_inject_handler(reginfo, handler);
+
+    /*************************************************
+     *
+     * inject row_merge helper with prefix rootoid_len + 2 (entry.col)
+     */
+    handler = netsnmp_get_row_merge_handler(reginfo->rootoid_len + 2);
+    netsnmp_inject_handler(reginfo, handler);
+
+    /*************************************************
+     *
+     * inject container_table helper
+     */
+    handler =
+        netsnmp_container_table_handler_get(tbl_info,
+                                            lreNodesTable_if_ctx.container,
+                                            TABLE_CONTAINER_KEY_NETSNMP_INDEX);
+    netsnmp_inject_handler( reginfo, handler );
+
+    /*************************************************
+     *
+     * inject cache helper
+     */
+    if(NULL != lreNodesTable_if_ctx.cache) {
+        handler = netsnmp_cache_handler_get(lreNodesTable_if_ctx.cache);
+        netsnmp_inject_handler( reginfo, handler );
+    }
+
+    /*
+     * register table
+     */
+    netsnmp_register_table(reginfo, tbl_info);
+
+} /* _lreNodesTable_initialize_interface */
+
+/**
+ * @internal
+ * Shutdown the table lreNodesTable
+ */
+void
+_lreNodesTable_shutdown_interface(lreNodesTable_registration * reg_ptr)
+{
+    /*
+     * shutdown the container
+     */
+    _lreNodesTable_container_shutdown(&lreNodesTable_if_ctx);
+}
+
+void
+lreNodesTable_valid_columns_set(netsnmp_column_info *vc)
+{
+    lreNodesTable_if_ctx.tbl_info.valid_columns = vc;
+} /* lreNodesTable_valid_columns_set */
+
+/**
+ * @internal
+ * convert the index component stored in the context to an oid
+ */
+int
+lreNodesTable_index_to_oid(netsnmp_index *oid_idx,
+                         lreNodesTable_mib_index *mib_idx)
+{
+    int err = SNMP_ERR_NOERROR;
+    
+    /*
+     * temp storage for parsing indexes
+     */
+    /*
+     * lreInterfaceStatsIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+     */
+    netsnmp_variable_list var_lreInterfaceStatsIndex;
+    /*
+     * lreNodesIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+     */
+    netsnmp_variable_list var_lreNodesIndex;
+
+    /*
+     * set up varbinds
+     */
+    memset( &var_lreInterfaceStatsIndex, 0x00, sizeof(var_lreInterfaceStatsIndex) );
+    var_lreInterfaceStatsIndex.type = ASN_UNSIGNED;
+    memset( &var_lreNodesIndex, 0x00, sizeof(var_lreNodesIndex) );
+    var_lreNodesIndex.type = ASN_UNSIGNED;
+
+    /*
+     * chain temp index varbinds together
+     */
+    var_lreInterfaceStatsIndex.next_variable =  &var_lreNodesIndex; var_lreNodesIndex.next_variable =  NULL;
+
+
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_index_to_oid","called\n"));
+
+        /* lreInterfaceStatsIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h */
+    snmp_set_var_value(&var_lreInterfaceStatsIndex, &mib_idx->lreInterfaceStatsIndex, sizeof(mib_idx->lreInterfaceStatsIndex));
+
+        /* lreNodesIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h */
+    snmp_set_var_value(&var_lreNodesIndex, &mib_idx->lreNodesIndex, sizeof(mib_idx->lreNodesIndex));
+
+
+    err = build_oid_noalloc(oid_idx->oids, oid_idx->len, &oid_idx->len,
+                           NULL, 0, &var_lreInterfaceStatsIndex);
+    if(err)
+        snmp_log(LOG_ERR,"error %d converting index to oid\n", err);
+
+    /*
+     * parsing may have allocated memory. free it.
+     */
+    snmp_reset_var_buffers( &var_lreInterfaceStatsIndex );
+
+    return err;
+} /* lreNodesTable_index_to_oid */
+
+/**
+ * extract lreNodesTable indexes from a netsnmp_index
+ *
+ * @retval SNMP_ERR_NOERROR  : no error
+ * @retval SNMP_ERR_GENERR   : error
+ */
+int
+lreNodesTable_index_from_oid(netsnmp_index *oid_idx,
+                         lreNodesTable_mib_index *mib_idx)
+{
+    int err = SNMP_ERR_NOERROR;
+    
+    /*
+     * temp storage for parsing indexes
+     */
+    /*
+     * lreInterfaceStatsIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+     */
+    netsnmp_variable_list var_lreInterfaceStatsIndex;
+    /*
+     * lreNodesIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h
+     */
+    netsnmp_variable_list var_lreNodesIndex;
+
+    /*
+     * set up varbinds
+     */
+    memset( &var_lreInterfaceStatsIndex, 0x00, sizeof(var_lreInterfaceStatsIndex) );
+    var_lreInterfaceStatsIndex.type = ASN_UNSIGNED;
+    memset( &var_lreNodesIndex, 0x00, sizeof(var_lreNodesIndex) );
+    var_lreNodesIndex.type = ASN_UNSIGNED;
+
+    /*
+     * chain temp index varbinds together
+     */
+    var_lreInterfaceStatsIndex.next_variable =  &var_lreNodesIndex; var_lreNodesIndex.next_variable =  NULL;
+
+
+    DEBUGMSGTL(("verbose:lreNodesTable:lreNodesTable_index_from_oid","called\n"));
+
+    /*
+     * parse the oid into the individual index components
+     */
+    err = parse_oid_indexes( oid_idx->oids, oid_idx->len,
+                             &var_lreInterfaceStatsIndex );
+    if (err == SNMP_ERR_NOERROR) {
+        /*
+         * copy out values
+         */
+    mib_idx->lreInterfaceStatsIndex = *((u_long *)var_lreInterfaceStatsIndex.val.string);
+    mib_idx->lreNodesIndex = *((u_long *)var_lreNodesIndex.val.string);
+
+
+    }
+
+    /*
+     * parsing may have allocated memory. free it.
+     */
+    snmp_reset_var_buffers( &var_lreInterfaceStatsIndex );
+
+    return err;
+} /* lreNodesTable_index_from_oid */
+
+
+/* *********************************************************************
+ * @internal
+ * allocate resources for a lreNodesTable_rowreq_ctx
+ */
+lreNodesTable_rowreq_ctx *
+lreNodesTable_allocate_rowreq_ctx(void *user_init_ctx)
+{
+    lreNodesTable_rowreq_ctx *rowreq_ctx =
+                  SNMP_MALLOC_TYPEDEF(lreNodesTable_rowreq_ctx);
+
+    DEBUGMSGTL(("internal:lreNodesTable:lreNodesTable_allocate_rowreq_ctx","called\n"));
+
+    if(NULL == rowreq_ctx) {
+        snmp_log(LOG_ERR,"Couldn't allocate memory for a "
+                 "lreNodesTable_rowreq_ctx.\n");
+        return NULL;
+    }
+
+    rowreq_ctx->oid_idx.oids = rowreq_ctx->oid_tmp;
+
+    rowreq_ctx->lreNodesTable_data_list = NULL;
+
+    /*
+     * if we allocated data, call init routine
+     */
+    if (!(rowreq_ctx->rowreq_flags & MFD_ROW_DATA_FROM_USER)) {
+        if(SNMPERR_SUCCESS !=
+            lreNodesTable_rowreq_ctx_init(rowreq_ctx, user_init_ctx)) {
+           lreNodesTable_release_rowreq_ctx(rowreq_ctx);
+           rowreq_ctx = NULL;
+        }
+    }
+
+    return rowreq_ctx;
+} /* lreNodesTable_allocate_rowreq_ctx */
+
+/*
+ * @internal
+ * release resources for a lreNodesTable_rowreq_ctx
+ */
+void
+lreNodesTable_release_rowreq_ctx(lreNodesTable_rowreq_ctx *rowreq_ctx)
+{
+    DEBUGMSGTL(("internal:lreNodesTable:lreNodesTable_release_rowreq_ctx","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+    
+    lreNodesTable_rowreq_ctx_cleanup(rowreq_ctx);
+
+    /*
+     * free index oid pointer
+     */
+    if(rowreq_ctx->oid_idx.oids != rowreq_ctx->oid_tmp)
+        free(rowreq_ctx->oid_idx.oids);
+
+    SNMP_FREE(rowreq_ctx);
+} /* lreNodesTable_release_rowreq_ctx */
+
+/**
+ * @internal
+ * wrapper
+ */
+static int
+_mfd_lreNodesTable_pre_request(netsnmp_mib_handler *handler,
+                            netsnmp_handler_registration *reginfo,
+                            netsnmp_agent_request_info *agtreq_info,
+                            netsnmp_request_info *requests)
+{
+    int rc;
+
+    DEBUGMSGTL(("internal:lreNodesTable:_mfd_lreNodesTable_pre_request",
+                "called\n"));
+    
+    if (1 != netsnmp_row_merge_status_first(reginfo, agtreq_info)) {
+        DEBUGMSGTL(("internal:lreNodesTable",
+                    "skipping additional pre_request\n"));
+        return SNMP_ERR_NOERROR;
+    }
+        
+    rc = lreNodesTable_pre_request(lreNodesTable_if_ctx.user_ctx);
+    if (MFD_SUCCESS != rc) {
+        /*
+         * nothing we can do about it but log it
+         */
+        DEBUGMSGTL(("lreNodesTable","error %d from "
+                    "lreNodesTable_pre_request\n", rc));
+        netsnmp_request_set_error_all(requests, SNMP_VALIDATE_ERR(rc));
+    }
+    
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreNodesTable_pre_request */
+
+/**
+ * @internal
+ * wrapper
+ */
+static int
+_mfd_lreNodesTable_post_request(netsnmp_mib_handler *handler,
+                             netsnmp_handler_registration *reginfo,
+                             netsnmp_agent_request_info *agtreq_info,
+                             netsnmp_request_info *requests)
+{
+    lreNodesTable_rowreq_ctx *rowreq_ctx = (lreNodesTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+    int rc, packet_rc;
+
+    DEBUGMSGTL(("internal:lreNodesTable:_mfd_lreNodesTable_post_request",
+                "called\n"));
+
+    /*
+     * release row context, if deleted
+     */
+    if (rowreq_ctx && (rowreq_ctx->rowreq_flags & MFD_ROW_DELETED))
+        lreNodesTable_release_rowreq_ctx(rowreq_ctx);
+
+    /*
+     * wait for last call before calling user
+     */
+    if (1 != netsnmp_row_merge_status_last(reginfo, agtreq_info)) {
+        DEBUGMSGTL(("internal:lreNodesTable",
+                    "waiting for last post_request\n"));
+        return SNMP_ERR_NOERROR;
+    }
+    
+    packet_rc = netsnmp_check_all_requests_error(agtreq_info->asp, 0);
+    rc = lreNodesTable_post_request(lreNodesTable_if_ctx.user_ctx,packet_rc);
+    if (MFD_SUCCESS != rc) {
+        /*
+         * nothing we can do about it but log it
+         */
+        DEBUGMSGTL(("lreNodesTable","error %d from "
+                    "lreNodesTable_post_request\n", rc));
+    }
+    
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreNodesTable_post_request */
+
+/**
+ * @internal
+ * wrapper
+ */
+static int
+_mfd_lreNodesTable_object_lookup(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    int                    rc = SNMP_ERR_NOERROR;
+    lreNodesTable_rowreq_ctx *rowreq_ctx = (lreNodesTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+    
+    DEBUGMSGTL(("internal:lreNodesTable:_mfd_lreNodesTable_object_lookup","called\n"));
+
+    /*
+     * get our context from mfd
+     * lreNodesTable_interface_ctx *if_ctx =
+     *             (lreNodesTable_interface_ctx *)reginfo->my_reg_void;
+     */
+
+    if(NULL == rowreq_ctx) {
+        rc = SNMP_ERR_NOCREATION;
+    }
+
+    if (MFD_SUCCESS != rc)
+        netsnmp_request_set_error_all(requests, rc);
+    else
+        lreNodesTable_row_prep(rowreq_ctx);
+
+    return SNMP_VALIDATE_ERR(rc);
+} /* _mfd_lreNodesTable_object_lookup */
+
+/***********************************************************************
+ *
+ * GET processing
+ *
+ ***********************************************************************/
+/*
+ * @internal
+ * Retrieve the value for a particular column
+ */
+NETSNMP_STATIC_INLINE int
+_lreNodesTable_get_column( lreNodesTable_rowreq_ctx *rowreq_ctx,
+                       netsnmp_variable_list *var, int column )
+{
+    int rc = SNMPERR_SUCCESS;
+    
+    DEBUGMSGTL(("internal:lreNodesTable:_mfd_lreNodesTable_get_column",
+                "called for %d\n", column));
+
+
+    netsnmp_assert(NULL != rowreq_ctx);
+
+    switch(column) {
+
+    /* lreNodesMacAddress(2)/MacAddress/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/H */
+    case COLUMN_LRENODESMACADDRESS:
+    var->type = ASN_OCTET_STR;
+rc = lreNodesMacAddress_get(rowreq_ctx, (char **)&var->val.string, &var->val_len );
+        break;
+
+    /* lreTimeLastSeenA(3)/TICKS/ASN_TIMETICKS/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRETIMELASTSEENA:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_TIMETICKS;
+rc = lreTimeLastSeenA_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreTimeLastSeenB(4)/TICKS/ASN_TIMETICKS/u_long(u_long)//l/A/w/e/r/d/h */
+    case COLUMN_LRETIMELASTSEENB:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_TIMETICKS;
+rc = lreTimeLastSeenB_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+    /* lreRemNodeType(5)/INTEGER/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h */
+    case COLUMN_LREREMNODETYPE:
+    var->val_len = sizeof(u_long);
+    var->type = ASN_INTEGER;
+rc = lreRemNodeType_get(rowreq_ctx, (u_long *)var->val.string );
+        break;
+
+     default:
+        if (LRENODESTABLE_MIN_COL <= column && column <= LRENODESTABLE_MAX_COL) {
+            DEBUGMSGTL(("internal:lreNodesTable:_mfd_lreNodesTable_get_column",
+                "assume column %d is reserved\n", column));
+            rc = MFD_SKIP;
+        } else {
+            snmp_log(LOG_ERR,
+                "unknown column %d in _lreNodesTable_get_column\n", column);
+        }
+        break;
+    }
+
+    return rc;
+} /* _lreNodesTable_get_column */
+
+int
+_mfd_lreNodesTable_get_values(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *agtreq_info,
+                         netsnmp_request_info *requests)
+{
+    lreNodesTable_rowreq_ctx *rowreq_ctx = (lreNodesTable_rowreq_ctx*)
+                  netsnmp_container_table_row_extract(requests);
+    netsnmp_table_request_info * tri;
+    u_char                     * old_string;
+    void                      (*dataFreeHook)(void *);
+    int                        rc;
+
+    DEBUGMSGTL(("internal:lreNodesTable:_mfd_lreNodesTable_get_values","called\n"));
+
+    netsnmp_assert(NULL != rowreq_ctx);
+    
+    for(;requests; requests = requests->next) {
+        /*
+         * save old pointer, so we can free it if replaced
+         */
+        old_string = requests->requestvb->val.string;
+        dataFreeHook = requests->requestvb->dataFreeHook;
+        if(NULL == requests->requestvb->val.string) {
+            requests->requestvb->val.string = requests->requestvb->buf;
+            requests->requestvb->val_len = sizeof(requests->requestvb->buf);
+        }
+        else if(requests->requestvb->buf == requests->requestvb->val.string) {
+            if(requests->requestvb->val_len != sizeof(requests->requestvb->buf))
+                requests->requestvb->val_len = sizeof(requests->requestvb->buf);
+        }
+
+        /*
+         * get column data
+         */
+        tri = netsnmp_extract_table_info(requests);
+        if(NULL == tri)
+            continue;
+        
+        rc = _lreNodesTable_get_column(rowreq_ctx, requests->requestvb, tri->colnum);
+        if(rc) {
+            if(MFD_SKIP == rc) {
+                requests->requestvb->type = SNMP_NOSUCHINSTANCE;
+                rc = SNMP_ERR_NOERROR;
+            }
+        }
+        else if (NULL == requests->requestvb->val.string) {
+            snmp_log(LOG_ERR,"NULL varbind data pointer!\n");
+            rc = SNMP_ERR_GENERR;
+        }
+        if(rc)
+            netsnmp_request_set_error(requests, SNMP_VALIDATE_ERR(rc));
+
+        /*
+         * if the buffer wasn't used previously for the old data (i.e. it
+         * was allcoated memory)  and the get routine replaced the pointer,
+         * we need to free the previous pointer.
+         */
+        if(old_string && (old_string != requests->requestvb->buf) &&
+           (requests->requestvb->val.string != old_string)) {
+            if(dataFreeHook)
+                (*dataFreeHook)(old_string);
+            else
+                free(old_string);
+        }
+    } /* for results */
+
+    return SNMP_ERR_NOERROR;
+} /* _mfd_lreNodesTable_get_values */
+
+/***********************************************************************
+ *
+ * SET processing
+ *
+ ***********************************************************************/
+
+/*
+ * SET PROCESSING NOT APPLICABLE (per MIB or user setting)
+ */
+/***********************************************************************
+ *
+ * DATA ACCESS
+ *
+ ***********************************************************************/
+static void _container_free(netsnmp_container *container);
+
+/**
+ * @internal
+ */
+static int
+_cache_load(netsnmp_cache *cache, void *vmagic)
+{
+    DEBUGMSGTL(("internal:lreNodesTable:_cache_load","called\n"));
+
+    if((NULL == cache) || (NULL == cache->magic)) {
+        snmp_log(LOG_ERR, "invalid cache for lreNodesTable_cache_load\n");
+        return -1;
+    }
+
+    /** should only be called for an invalid or expired cache */
+    netsnmp_assert((0 == cache->valid) || (1 == cache->expired));
+    
+    /*
+     * call user code
+     */
+    return lreNodesTable_container_load((netsnmp_container*)cache->magic);
+} /* _cache_load */
+
+/**
+ * @internal
+ */
+static void
+_cache_free(netsnmp_cache *cache, void *magic)
+{
+    netsnmp_container *container;
+
+    DEBUGMSGTL(("internal:lreNodesTable:_cache_free","called\n"));
+
+    if((NULL == cache) || (NULL == cache->magic)) {
+        snmp_log(LOG_ERR, "invalid cache in lreNodesTable_cache_free\n");
+        return;
+    }
+
+    container = (netsnmp_container*)cache->magic;
+
+    _container_free(container);
+} /* _cache_free */
+
+/**
+ * @internal
+ */
+static void
+_container_item_free(lreNodesTable_rowreq_ctx *rowreq_ctx, void *context)
+{
+    DEBUGMSGTL(("internal:lreNodesTable:_container_item_free","called\n"));
+
+    if(NULL == rowreq_ctx)
+        return;
+
+    lreNodesTable_release_rowreq_ctx(rowreq_ctx);
+} /* _container_item_free */
+
+/**
+ * @internal
+ */
+static void
+_container_free(netsnmp_container *container)
+{
+    DEBUGMSGTL(("internal:lreNodesTable:_container_free","called\n"));
+
+    if (NULL == container) {
+        snmp_log(LOG_ERR, "invalid container in lreNodesTable_container_free\n");
+        return;
+    }
+
+    /*
+     * call user code
+     */
+    lreNodesTable_container_free(container);
+    
+    /*
+     * free all items. inefficient, but easy.
+     */
+    CONTAINER_CLEAR(container,
+                    (netsnmp_container_obj_func *)_container_item_free,
+                    NULL);
+} /* _container_free */
+
+/**
+ * @internal
+ * initialize the container with functions or wrappers
+ */
+void
+_lreNodesTable_container_init(lreNodesTable_interface_ctx *if_ctx)
+{
+    DEBUGMSGTL(("internal:lreNodesTable:_lreNodesTable_container_init","called\n"));
+
+    /*
+     * cache init
+     */
+    if_ctx->cache = netsnmp_cache_create(30, /* timeout in seconds */
+                                         _cache_load, _cache_free,
+                                         lreNodesTable_oid,
+                                         lreNodesTable_oid_size);
+
+    if(NULL == if_ctx->cache) {
+        snmp_log(LOG_ERR, "error creating cache for lreNodesTable\n");
+        return;
+    }
+
+    if_ctx->cache->flags = NETSNMP_CACHE_DONT_INVALIDATE_ON_SET;
+
+    lreNodesTable_container_init(&if_ctx->container, if_ctx->cache);
+    if(NULL == if_ctx->container)
+        if_ctx->container = netsnmp_container_find("lreNodesTable:table_container");
+    if(NULL == if_ctx->container) {
+        snmp_log(LOG_ERR,"error creating container in "
+                 "lreNodesTable_container_init\n");
+        return;
+    }
+
+    if (NULL != if_ctx->cache)
+        if_ctx->cache->magic = (void*)if_ctx->container;
+} /* _lreNodesTable_container_init */
+
+/**
+ * @internal
+ * shutdown the container with functions or wrappers
+ */
+void
+_lreNodesTable_container_shutdown(lreNodesTable_interface_ctx *if_ctx)
+{
+    DEBUGMSGTL(("internal:lreNodesTable:_lreNodesTable_container_shutdown","called\n"));
+
+    lreNodesTable_container_shutdown(if_ctx->container);
+
+    _container_free(if_ctx->container);
+
+} /* _lreNodesTable_container_shutdown */
+
+
+lreNodesTable_rowreq_ctx *
+lreNodesTable_row_find_by_mib_index(lreNodesTable_mib_index *mib_idx)
+{
+    lreNodesTable_rowreq_ctx   *rowreq_ctx;
+    oid                      oid_tmp[MAX_OID_LEN];
+    netsnmp_index            oid_idx;
+    int                      rc;
+
+    /*
+     * set up storage for OID
+     */
+    oid_idx.oids = oid_tmp;
+    oid_idx.len = sizeof(oid_tmp)/sizeof(oid);
+
+    /*
+     * convert
+     */
+    rc = lreNodesTable_index_to_oid(&oid_idx, mib_idx);
+    if (MFD_SUCCESS != rc)
+        return NULL;
+
+    rowreq_ctx = (lreNodesTable_rowreq_ctx*)CONTAINER_FIND(lreNodesTable_if_ctx.container, &oid_idx);
+
+    return rowreq_ctx;
+}
+
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_interface.h b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_interface.h
new file mode 100644
index 0000000..1466d57
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_interface.h
@@ -0,0 +1,84 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *       version $ of $
+ *
+ * $Id:$
+ */
+/** @ingroup interface: Routines to interface to Net-SNMP
+ *
+ * \warning This code should not be modified, called directly,
+ *          or used to interpret functionality. It is subject to
+ *          change at any time.
+ * 
+ * @{
+ */
+/*
+ * *********************************************************************
+ * *********************************************************************
+ * *********************************************************************
+ * ***                                                               ***
+ * ***  NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE  ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***       THIS FILE DOES NOT CONTAIN ANY USER EDITABLE CODE.      ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***       THE GENERATED CODE IS INTERNAL IMPLEMENTATION, AND      ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * ***    IS SUBJECT TO CHANGE WITHOUT WARNING IN FUTURE RELEASES.   ***
+ * ***                                                               ***
+ * ***                                                               ***
+ * *********************************************************************
+ * *********************************************************************
+ * *********************************************************************
+ */
+#ifndef LRENODESTABLE_INTERFACE_H
+#define LRENODESTABLE_INTERFACE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include "lreNodesTable.h"
+
+
+/* ********************************************************************
+ * Table declarations
+ */
+
+/* PUBLIC interface initialization routine */
+void _lreNodesTable_initialize_interface(lreNodesTable_registration * user_ctx,
+                                    u_long flags);
+void _lreNodesTable_shutdown_interface(lreNodesTable_registration * user_ctx);
+
+lreNodesTable_registration *
+lreNodesTable_registration_get( void );
+
+lreNodesTable_registration *
+lreNodesTable_registration_set( lreNodesTable_registration * newreg );
+
+netsnmp_container *lreNodesTable_container_get( void );
+int lreNodesTable_container_size( void );
+
+    lreNodesTable_rowreq_ctx * lreNodesTable_allocate_rowreq_ctx(void *);
+void lreNodesTable_release_rowreq_ctx(lreNodesTable_rowreq_ctx *rowreq_ctx);
+
+int lreNodesTable_index_to_oid(netsnmp_index *oid_idx,
+                            lreNodesTable_mib_index *mib_idx);
+int lreNodesTable_index_from_oid(netsnmp_index *oid_idx,
+                              lreNodesTable_mib_index *mib_idx);
+
+/*
+ * access to certain internals. use with caution!
+ */
+void lreNodesTable_valid_columns_set(netsnmp_column_info *vc);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LRENODESTABLE_INTERFACE_H */
+/** @} */
diff --git a/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_oids.h b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_oids.h
new file mode 100644
index 0000000..8c25355
--- /dev/null
+++ b/agent/mibgroup/IEC-62439-3-MIB/lreNodesTable/lreNodesTable_oids.h
@@ -0,0 +1,39 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  $
+ *
+ * $Id:$
+ */
+#ifndef LRENODESTABLE_OIDS_H
+#define LRENODESTABLE_OIDS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* column number definitions for table lreNodesTable */
+#define LRENODESTABLE_OID              1,0,62439,2,21,1,1,0,2
+
+
+#define COLUMN_LRENODESINDEX         1
+    
+#define COLUMN_LRENODESMACADDRESS         2
+    
+#define COLUMN_LRETIMELASTSEENA         3
+    
+#define COLUMN_LRETIMELASTSEENB         4
+    
+#define COLUMN_LREREMNODETYPE         5
+    
+
+#define LRENODESTABLE_MIN_COL   COLUMN_LRENODESMACADDRESS
+#define LRENODESTABLE_MAX_COL   COLUMN_LREREMNODETYPE
+    
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LRENODESTABLE_OIDS_H */
-- 
1.9.1

